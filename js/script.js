/*!jQuery Migrate v3.3.2 | (c) OpenJS Foundation and other contributors | jquery.org/license*/"undefined" == typeof jQuery.migrateMute && (jQuery.migrateMute = !0), function (t) { "use strict"; "function" == typeof define && define.amd ? define(["jquery"], function (e) { return t(e, window) }) : "object" == typeof module && module.exports ? module.exports = t(require("jquery"), window) : t(jQuery, window) }(function (s, n) { "use strict"; function e(e) { return 0 <= function (e, t) { for (var r = /^(\d+)\.(\d+)\.(\d+)/, n = r.exec(e) || [], o = r.exec(t) || [], i = 1; i <= 3; i++) { if (+o[i] < +n[i]) return 1; if (+n[i] < +o[i]) return -1 } return 0 }(s.fn.jquery, e) } s.migrateVersion = "3.3.2", n.console && n.console.log && (s && e("3.0.0") || n.console.log("JQMIGRATE: jQuery 3.0.0+ REQUIRED"), s.migrateWarnings && n.console.log("JQMIGRATE: Migrate plugin loaded multiple times"), n.console.log("JQMIGRATE: Migrate is installed" + (s.migrateMute ? "" : " with logging active") + ", version " + s.migrateVersion)); var r = {}; function u(e) { var t = n.console; s.migrateDeduplicateWarnings && r[e] || (r[e] = !0, s.migrateWarnings.push(e), t && t.warn && !s.migrateMute && (t.warn("JQMIGRATE: " + e), s.migrateTrace && t.trace && t.trace())) } function t(e, t, r, n) { Object.defineProperty(e, t, { configurable: !0, enumerable: !0, get: function () { return u(n), r }, set: function (e) { u(n), r = e } }) } function o(e, t, r, n) { e[t] = function () { return u(n), r.apply(this, arguments) } } s.migrateDeduplicateWarnings = !0, s.migrateWarnings = [], void 0 === s.migrateTrace && (s.migrateTrace = !0), s.migrateReset = function () { r = {}, s.migrateWarnings.length = 0 }, "BackCompat" === n.document.compatMode && u("jQuery is not compatible with Quirks Mode"); var i, a, c, d = {}, l = s.fn.init, p = s.find, f = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/, y = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/g, m = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; for (i in s.fn.init = function (e) { var t = Array.prototype.slice.call(arguments); return "string" == typeof e && "#" === e && (u("jQuery( '#' ) is not a valid selector"), t[0] = []), l.apply(this, t) }, s.fn.init.prototype = s.fn, s.find = function (t) { var r = Array.prototype.slice.call(arguments); if ("string" == typeof t && f.test(t)) try { n.document.querySelector(t) } catch (e) { t = t.replace(y, function (e, t, r, n) { return "[" + t + r + '"' + n + '"]' }); try { n.document.querySelector(t), u("Attribute selector with '#' must be quoted: " + r[0]), r[0] = t } catch (e) { u("Attribute selector with '#' was not fixed: " + r[0]) } } return p.apply(this, r) }, p) Object.prototype.hasOwnProperty.call(p, i) && (s.find[i] = p[i]); o(s.fn, "size", function () { return this.length }, "jQuery.fn.size() is deprecated and removed; use the .length property"), o(s, "parseJSON", function () { return JSON.parse.apply(null, arguments) }, "jQuery.parseJSON is deprecated; use JSON.parse"), o(s, "holdReady", s.holdReady, "jQuery.holdReady is deprecated"), o(s, "unique", s.uniqueSort, "jQuery.unique is deprecated; use jQuery.uniqueSort"), t(s.expr, "filters", s.expr.pseudos, "jQuery.expr.filters is deprecated; use jQuery.expr.pseudos"), t(s.expr, ":", s.expr.pseudos, "jQuery.expr[':'] is deprecated; use jQuery.expr.pseudos"), e("3.1.1") && o(s, "trim", function (e) { return null == e ? "" : (e + "").replace(m, "") }, "jQuery.trim is deprecated; use String.prototype.trim"), e("3.2.0") && (o(s, "nodeName", function (e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() }, "jQuery.nodeName is deprecated"), o(s, "isArray", Array.isArray, "jQuery.isArray is deprecated; use Array.isArray")), e("3.3.0") && (o(s, "isNumeric", function (e) { var t = typeof e; return ("number" == t || "string" == t) && !isNaN(e - parseFloat(e)) }, "jQuery.isNumeric() is deprecated"), s.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { d["[object " + t + "]"] = t.toLowerCase() }), o(s, "type", function (e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? d[Object.prototype.toString.call(e)] || "object" : typeof e }, "jQuery.type is deprecated"), o(s, "isFunction", function (e) { return "function" == typeof e }, "jQuery.isFunction() is deprecated"), o(s, "isWindow", function (e) { return null != e && e === e.window }, "jQuery.isWindow() is deprecated")), s.ajax && (a = s.ajax, c = /(=)\?(?=&|$)|\?\?/, s.ajax = function () { var e = a.apply(this, arguments); return e.promise && (o(e, "success", e.done, "jQXHR.success is deprecated and removed"), o(e, "error", e.fail, "jQXHR.error is deprecated and removed"), o(e, "complete", e.always, "jQXHR.complete is deprecated and removed")), e }, e("4.0.0") || s.ajaxPrefilter("+json", function (e) { !1 !== e.jsonp && (c.test(e.url) || "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && c.test(e.data)) && u("JSON-to-JSONP auto-promotion is deprecated") })); var g = s.fn.removeAttr, h = s.fn.toggleClass, v = /\S+/g; function j(e) { return e.replace(/-([a-z])/g, function (e, t) { return t.toUpperCase() }) } s.fn.removeAttr = function (e) { var r = this; return s.each(e.match(v), function (e, t) { s.expr.match.bool.test(t) && (u("jQuery.fn.removeAttr no longer sets boolean properties: " + t), r.prop(t, !1)) }), g.apply(this, arguments) }; var Q, b = !(s.fn.toggleClass = function (t) { return void 0 !== t && "boolean" != typeof t ? h.apply(this, arguments) : (u("jQuery.fn.toggleClass( boolean ) is deprecated"), this.each(function () { var e = this.getAttribute && this.getAttribute("class") || ""; e && s.data(this, "__className__", e), this.setAttribute && this.setAttribute("class", !e && !1 !== t && s.data(this, "__className__") || "") })) }), w = /^[a-z]/, x = /^(?:Border(?:Top|Right|Bottom|Left)?(?:Width|)|(?:Margin|Padding)?(?:Top|Right|Bottom|Left)?|(?:Min|Max)?(?:Width|Height))$/; s.swap && s.each(["height", "width", "reliableMarginRight"], function (e, t) { var r = s.cssHooks[t] && s.cssHooks[t].get; r && (s.cssHooks[t].get = function () { var e; return b = !0, e = r.apply(this, arguments), b = !1, e }) }), s.swap = function (e, t, r, n) { var o, i, a = {}; for (i in b || u("jQuery.swap() is undocumented and deprecated"), t) a[i] = e.style[i], e.style[i] = t[i]; for (i in o = r.apply(e, n || []), t) e.style[i] = a[i]; return o }, e("3.4.0") && "undefined" != typeof Proxy && (s.cssProps = new Proxy(s.cssProps || {}, { set: function () { return u("JQMIGRATE: jQuery.cssProps is deprecated"), Reflect.set.apply(this, arguments) } })), s.cssNumber || (s.cssNumber = {}), Q = s.fn.css, s.fn.css = function (e, t) { var r, n, o = this; return e && "object" == typeof e && !Array.isArray(e) ? (s.each(e, function (e, t) { s.fn.css.call(o, e, t) }), this) : ("number" == typeof t && (r = j(e), n = r, w.test(n) && x.test(n[0].toUpperCase() + n.slice(1)) || s.cssNumber[r] || u('Number-typed values are deprecated for jQuery.fn.css( "' + e + '", value )')), Q.apply(this, arguments)) }; var A, k, S, M, N = s.data; s.data = function (e, t, r) { var n, o, i; if (t && "object" == typeof t && 2 === arguments.length) { for (i in n = s.hasData(e) && N.call(this, e), o = {}, t) i !== j(i) ? (u("jQuery.data() always sets/gets camelCased names: " + i), n[i] = t[i]) : o[i] = t[i]; return N.call(this, e, o), t } return t && "string" == typeof t && t !== j(t) && (n = s.hasData(e) && N.call(this, e)) && t in n ? (u("jQuery.data() always sets/gets camelCased names: " + t), 2 < arguments.length && (n[t] = r), n[t]) : N.apply(this, arguments) }, s.fx && (S = s.Tween.prototype.run, M = function (e) { return e }, s.Tween.prototype.run = function () { 1 < s.easing[this.easing].length && (u("'jQuery.easing." + this.easing.toString() + "' should use only one argument"), s.easing[this.easing] = M), S.apply(this, arguments) }, A = s.fx.interval || 13, k = "jQuery.fx.interval is deprecated", n.requestAnimationFrame && Object.defineProperty(s.fx, "interval", { configurable: !0, enumerable: !0, get: function () { return n.document.hidden || u(k), A }, set: function (e) { u(k), A = e } })); var R = s.fn.load, H = s.event.add, C = s.event.fix; s.event.props = [], s.event.fixHooks = {}, t(s.event.props, "concat", s.event.props.concat, "jQuery.event.props.concat() is deprecated and removed"), s.event.fix = function (e) { var t, r = e.type, n = this.fixHooks[r], o = s.event.props; if (o.length) { u("jQuery.event.props are deprecated and removed: " + o.join()); while (o.length) s.event.addProp(o.pop()) } if (n && !n._migrated_ && (n._migrated_ = !0, u("jQuery.event.fixHooks are deprecated and removed: " + r), (o = n.props) && o.length)) while (o.length) s.event.addProp(o.pop()); return t = C.call(this, e), n && n.filter ? n.filter(t, e) : t }, s.event.add = function (e, t) { return e === n && "load" === t && "complete" === n.document.readyState && u("jQuery(window).on('load'...) called after load event occurred"), H.apply(this, arguments) }, s.each(["load", "unload", "error"], function (e, t) { s.fn[t] = function () { var e = Array.prototype.slice.call(arguments, 0); return "load" === t && "string" == typeof e[0] ? R.apply(this, e) : (u("jQuery.fn." + t + "() is deprecated"), e.splice(0, 0, t), arguments.length ? this.on.apply(this, e) : (this.triggerHandler.apply(this, e), this)) } }), s.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, r) { s.fn[r] = function (e, t) { return u("jQuery.fn." + r + "() event shorthand is deprecated"), 0 < arguments.length ? this.on(r, null, e, t) : this.trigger(r) } }), s(function () { s(n.document).triggerHandler("ready") }), s.event.special.ready = { setup: function () { this === n.document && u("'ready' event is deprecated") } }, s.fn.extend({ bind: function (e, t, r) { return u("jQuery.fn.bind() is deprecated"), this.on(e, null, t, r) }, unbind: function (e, t) { return u("jQuery.fn.unbind() is deprecated"), this.off(e, null, t) }, delegate: function (e, t, r, n) { return u("jQuery.fn.delegate() is deprecated"), this.on(t, e, r, n) }, undelegate: function (e, t, r) { return u("jQuery.fn.undelegate() is deprecated"), 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", r) }, hover: function (e, t) { return u("jQuery.fn.hover() is deprecated"), this.on("mouseenter", e).on("mouseleave", t || e) } }); function T(e) { var t = n.document.implementation.createHTMLDocument(""); return t.body.innerHTML = e, t.body && t.body.innerHTML } function P(e) { var t = e.replace(O, "<$1></$2>"); t !== e && T(e) !== T(t) && u("HTML tags must be properly nested and closed: " + e) } var O = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, q = s.htmlPrefilter; s.UNSAFE_restoreLegacyHtmlPrefilter = function () { s.htmlPrefilter = function (e) { return P(e), e.replace(O, "<$1></$2>") } }, s.htmlPrefilter = function (e) { return P(e), q(e) }; var D, _ = s.fn.offset; s.fn.offset = function () { var e = this[0]; return !e || e.nodeType && e.getBoundingClientRect ? _.apply(this, arguments) : (u("jQuery.fn.offset() requires a valid DOM element"), arguments.length ? this : void 0) }, s.ajax && (D = s.param, s.param = function (e, t) { var r = s.ajaxSettings && s.ajaxSettings.traditional; return void 0 === t && r && (u("jQuery.param() no longer uses jQuery.ajaxSettings.traditional"), t = r), D.call(this, e, t) }); var E, F, J = s.fn.andSelf || s.fn.addBack; return s.fn.andSelf = function () { return u("jQuery.fn.andSelf() is deprecated and removed, use jQuery.fn.addBack()"), J.apply(this, arguments) }, s.Deferred && (E = s.Deferred, F = [["resolve", "done", s.Callbacks("once memory"), s.Callbacks("once memory"), "resolved"], ["reject", "fail", s.Callbacks("once memory"), s.Callbacks("once memory"), "rejected"], ["notify", "progress", s.Callbacks("memory"), s.Callbacks("memory")]], s.Deferred = function (e) { var i = E(), a = i.promise(); return i.pipe = a.pipe = function () { var o = arguments; return u("deferred.pipe() is deprecated"), s.Deferred(function (n) { s.each(F, function (e, t) { var r = "function" == typeof o[e] && o[e]; i[t[1]](function () { var e = r && r.apply(this, arguments); e && "function" == typeof e.promise ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[t[0] + "With"](this === a ? n.promise() : this, r ? [e] : arguments) }) }), o = null }).promise() }, e && e.call(i, i), i }, s.Deferred.exceptionHook = E.exceptionHook), s });; var runtime = function (a) { "use strict"; var u, t = Object.prototype, h = t.hasOwnProperty, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", e = r.asyncIterator || "@@asyncIterator", o = r.toStringTag || "@@toStringTag"; function i(t, r, e) { return Object.defineProperty(t, r, { value: e, enumerable: !0, configurable: !0, writable: !0 }), t[r] } try { i({}, "") } catch (t) { i = function (t, r, e) { return t[r] = e } } function c(t, r, e, n) { var o, i, a, c, r = r && r.prototype instanceof v ? r : v, r = Object.create(r.prototype), n = new j(n || []); return r._invoke = (o = t, i = e, a = n, c = l, function (t, r) { if (c === p) throw new Error("Generator is already running"); if (c === y) { if ("throw" === t) throw r; return k() } for (a.method = t, a.arg = r; ;) { var e = a.delegate; if (e) { var n = function t(r, e) { var n = r.iterator[e.method]; if (n === u) { if (e.delegate = null, "throw" === e.method) { if (r.iterator.return && (e.method = "return", e.arg = u, t(r, e), "throw" === e.method)) return g; e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method") } return g } var n = f(n, r.iterator, e.arg); if ("throw" === n.type) return e.method = "throw", e.arg = n.arg, e.delegate = null, g; n = n.arg; if (!n) return e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, g; { if (!n.done) return n; e[r.resultName] = n.value, e.next = r.nextLoc, "return" !== e.method && (e.method = "next", e.arg = u) } e.delegate = null; return g }(e, a); if (n) { if (n === g) continue; return n } } if ("next" === a.method) a.sent = a._sent = a.arg; else if ("throw" === a.method) { if (c === l) throw c = y, a.arg; a.dispatchException(a.arg) } else "return" === a.method && a.abrupt("return", a.arg); c = p; n = f(o, i, a); if ("normal" === n.type) { if (c = a.done ? y : s, n.arg !== g) return { value: n.arg, done: a.done } } else "throw" === n.type && (c = y, a.method = "throw", a.arg = n.arg) } }), r } function f(t, r, e) { try { return { type: "normal", arg: t.call(r, e) } } catch (t) { return { type: "throw", arg: t } } } a.wrap = c; var l = "suspendedStart", s = "suspendedYield", p = "executing", y = "completed", g = {}; function v() { } function d() { } function m() { } var w = {}; i(w, n, function () { return this }); r = Object.getPrototypeOf, r = r && r(r(O([]))); r && r !== t && h.call(r, n) && (w = r); var L = m.prototype = v.prototype = Object.create(w); function x(t) { ["next", "throw", "return"].forEach(function (r) { i(t, r, function (t) { return this._invoke(r, t) }) }) } function b(a, c) { var r; this._invoke = function (e, n) { function t() { return new c(function (t, r) { !function r(t, e, n, o) { t = f(a[t], a, e); if ("throw" !== t.type) { var i = t.arg; return (e = i.value) && "object" == typeof e && h.call(e, "__await") ? c.resolve(e.__await).then(function (t) { r("next", t, n, o) }, function (t) { r("throw", t, n, o) }) : c.resolve(e).then(function (t) { i.value = t, n(i) }, function (t) { return r("throw", t, n, o) }) } o(t.arg) }(e, n, t, r) }) } return r = r ? r.then(t, t) : t() } } function E(t) { var r = { tryLoc: t[0] }; 1 in t && (r.catchLoc = t[1]), 2 in t && (r.finallyLoc = t[2], r.afterLoc = t[3]), this.tryEntries.push(r) } function _(t) { var r = t.completion || {}; r.type = "normal", delete r.arg, t.completion = r } function j(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(E, this), this.reset(!0) } function O(r) { if (r) { var t = r[n]; if (t) return t.call(r); if ("function" == typeof r.next) return r; if (!isNaN(r.length)) { var e = -1, t = function t() { for (; ++e < r.length;)if (h.call(r, e)) return t.value = r[e], t.done = !1, t; return t.value = u, t.done = !0, t }; return t.next = t } } return { next: k } } function k() { return { value: u, done: !0 } } return i(L, "constructor", d.prototype = m), i(m, "constructor", d), d.displayName = i(m, o, "GeneratorFunction"), a.isGeneratorFunction = function (t) { t = "function" == typeof t && t.constructor; return !!t && (t === d || "GeneratorFunction" === (t.displayName || t.name)) }, a.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, m) : (t.__proto__ = m, i(t, o, "GeneratorFunction")), t.prototype = Object.create(L), t }, a.awrap = function (t) { return { __await: t } }, x(b.prototype), i(b.prototype, e, function () { return this }), a.AsyncIterator = b, a.async = function (t, r, e, n, o) { void 0 === o && (o = Promise); var i = new b(c(t, r, e, n), o); return a.isGeneratorFunction(r) ? i : i.next().then(function (t) { return t.done ? t.value : i.next() }) }, x(L), i(L, o, "Generator"), i(L, n, function () { return this }), i(L, "toString", function () { return "[object Generator]" }), a.keys = function (e) { var t, n = []; for (t in e) n.push(t); return n.reverse(), function t() { for (; n.length;) { var r = n.pop(); if (r in e) return t.value = r, t.done = !1, t } return t.done = !0, t } }, a.values = O, j.prototype = { constructor: j, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = u, this.done = !1, this.delegate = null, this.method = "next", this.arg = u, this.tryEntries.forEach(_), !t) for (var r in this) "t" === r.charAt(0) && h.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = u) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (e) { if (this.done) throw e; var n = this; function t(t, r) { return i.type = "throw", i.arg = e, n.next = t, r && (n.method = "next", n.arg = u), !!r } for (var r = this.tryEntries.length - 1; 0 <= r; --r) { var o = this.tryEntries[r], i = o.completion; if ("root" === o.tryLoc) return t("end"); if (o.tryLoc <= this.prev) { var a = h.call(o, "catchLoc"), c = h.call(o, "finallyLoc"); if (a && c) { if (this.prev < o.catchLoc) return t(o.catchLoc, !0); if (this.prev < o.finallyLoc) return t(o.finallyLoc) } else if (a) { if (this.prev < o.catchLoc) return t(o.catchLoc, !0) } else { if (!c) throw new Error("try statement without catch or finally"); if (this.prev < o.finallyLoc) return t(o.finallyLoc) } } } }, abrupt: function (t, r) { for (var e = this.tryEntries.length - 1; 0 <= e; --e) { var n = this.tryEntries[e]; if (n.tryLoc <= this.prev && h.call(n, "finallyLoc") && this.prev < n.finallyLoc) { var o = n; break } } var i = (o = o && ("break" === t || "continue" === t) && o.tryLoc <= r && r <= o.finallyLoc ? null : o) ? o.completion : {}; return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o.finallyLoc, g) : this.complete(i) }, complete: function (t, r) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), g }, finish: function (t) { for (var r = this.tryEntries.length - 1; 0 <= r; --r) { var e = this.tryEntries[r]; if (e.finallyLoc === t) return this.complete(e.completion, e.afterLoc), _(e), g } }, catch: function (t) { for (var r = this.tryEntries.length - 1; 0 <= r; --r) { var e = this.tryEntries[r]; if (e.tryLoc === t) { var n, o = e.completion; return "throw" === o.type && (n = o.arg, _(e)), n } } throw new Error("illegal catch attempt") }, delegateYield: function (t, r, e) { return this.delegate = { iterator: O(t), resultName: r, nextLoc: e }, "next" === this.method && (this.arg = u), g } }, a }("object" == typeof module ? module.exports : {}); try { regeneratorRuntime = runtime } catch (t) { "object" == typeof globalThis ? globalThis.regeneratorRuntime = runtime : Function("r", "regeneratorRuntime = r")(runtime) }; !function (C) { "use strict"; var r, e, o; e = {}, (o = function (t) { if (e[t]) return e[t].exports; var n = e[t] = { i: t, l: !1, exports: {} }; return r[t].call(n.exports, n, n.exports, o), n.l = !0, n.exports }).m = r = [function (t, n, r) { r(1), r(67), r(68), r(72), r(79), t.exports = r(85) }, function (t, n, r) { var e = r(2), o = r(36), i = r(57), u = r(56), r = r(62); e({ target: "Array", proto: !0 }, { at: function (t) { var n = o(this), r = i(n), t = u(t), t = 0 <= t ? t : r + t; return t < 0 || r <= t ? C : n[t] } }), r("at") }, function (t, n, r) { var a = r(3), p = r(4).f, s = r(40), l = r(43), y = r(34), v = r(50), d = r(61); t.exports = function (t, n) { var r, e, o, i = t.target, u = t.global, c = t.stat, f = u ? a : c ? a[i] || y(i, {}) : (a[i] || {}).prototype; if (f) for (r in n) { if (e = n[r], o = t.noTargetGet ? (o = p(f, r)) && o.value : f[r], !d(u ? r : i + (c ? "." : "#") + r, t.forced) && o !== C) { if (typeof e == typeof o) continue; v(e, o) } (t.sham || o && o.sham) && s(e, "sham", !0), l(f, r, e, t) } } }, function (t, n) { function r(t) { return t && t.Math == Math && t } t.exports = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof global && global) || function () { return this }() || Function("return this")() }, function (t, n, r) { var e = r(5), o = r(7), i = r(8), u = r(9), c = r(10), f = r(15), a = r(35), p = r(38), s = Object.getOwnPropertyDescriptor; n.f = e ? s : function (t, n) { if (t = c(t), n = f(n), p) try { return s(t, n) } catch (t) { } if (a(t, n)) return u(!o(i.f, t, n), t[n]) } }, function (t, n, r) { r = r(6); t.exports = !r(function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] }) }, function (t, n) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, function (t, n) { var r = Function.prototype.call; t.exports = r.bind ? r.bind(r) : function () { return r.apply(r, arguments) } }, function (t, n, r) { var e = {}.propertyIsEnumerable, o = Object.getOwnPropertyDescriptor, i = o && !e.call({ 1: 2 }, 1); n.f = i ? function (t) { t = o(this, t); return !!t && t.enumerable } : e }, function (t, n) { t.exports = function (t, n) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: n } } }, function (t, n, r) { var e = r(11), o = r(14); t.exports = function (t) { return e(o(t)) } }, function (t, n, r) { var e = r(3), o = r(12), i = r(6), u = r(13), c = e.Object, f = o("".split); t.exports = i(function () { return !c("z").propertyIsEnumerable(0) }) ? function (t) { return "String" == u(t) ? f(t, "") : c(t) } : c }, function (t, n) { var r = Function.prototype, e = r.bind, o = r.call, i = e && e.bind(o); t.exports = e ? function (t) { return t && i(o, t) } : function (t) { return t && function () { return o.apply(t, arguments) } } }, function (t, n, r) { var r = r(12), e = r({}.toString), o = r("".slice); t.exports = function (t) { return o(e(t), 8, -1) } }, function (t, n, r) { var e = r(3).TypeError; t.exports = function (t) { if (t == C) throw e("Can't call method on " + t); return t } }, function (t, n, r) { var e = r(16), o = r(19); t.exports = function (t) { t = e(t, "string"); return o(t) ? t : t + "" } }, function (t, n, r) { var e = r(3), o = r(7), i = r(17), u = r(19), c = r(26), f = r(29), r = r(30), a = e.TypeError, p = r("toPrimitive"); t.exports = function (t, n) { if (!i(t) || u(t)) return t; var r = c(t, p); if (r) { if (r = o(r, t, n = n === C ? "default" : n), !i(r) || u(r)) return r; throw a("Can't convert object to primitive value") } return f(t, n = n === C ? "number" : n) } }, function (t, n, r) { var e = r(18); t.exports = function (t) { return "object" == typeof t ? null !== t : e(t) } }, function (t, n) { t.exports = function (t) { return "function" == typeof t } }, function (t, n, r) { var e = r(3), o = r(20), i = r(18), u = r(21), r = r(22), c = e.Object; t.exports = r ? function (t) { return "symbol" == typeof t } : function (t) { var n = o("Symbol"); return i(n) && u(n.prototype, c(t)) } }, function (t, n, r) { var e = r(3), o = r(18); t.exports = function (t, n) { return arguments.length < 2 ? (r = e[t], o(r) ? r : C) : e[t] && e[t][n]; var r } }, function (t, n, r) { r = r(12); t.exports = r({}.isPrototypeOf) }, function (t, n, r) { r = r(23); t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator }, function (t, n, r) { var e = r(24), r = r(6); t.exports = !!Object.getOwnPropertySymbols && !r(function () { var t = Symbol(); return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && e && e < 41 }) }, function (t, n, r) { var e, o, i = r(3), u = r(25), r = i.process, i = i.Deno, i = r && r.versions || i && i.version, i = i && i.v8; !(o = i ? 0 < (e = i.split("."))[0] && e[0] < 4 ? 1 : +(e[0] + e[1]) : o) && u && (!(e = u.match(/Edge\/(\d+)/)) || 74 <= e[1]) && (e = u.match(/Chrome\/(\d+)/)) && (o = +e[1]), t.exports = o }, function (t, n, r) { r = r(20); t.exports = r("navigator", "userAgent") || "" }, function (t, n, r) { var e = r(27); t.exports = function (t, n) { n = t[n]; return null == n ? C : e(n) } }, function (t, n, r) { var e = r(3), o = r(18), i = r(28), u = e.TypeError; t.exports = function (t) { if (o(t)) return t; throw u(i(t) + " is not a function") } }, function (t, n, r) { var e = r(3).String; t.exports = function (t) { try { return e(t) } catch (t) { return "Object" } } }, function (t, n, r) { var e = r(3), o = r(7), i = r(18), u = r(17), c = e.TypeError; t.exports = function (t, n) { var r, e; if ("string" === n && i(r = t.toString) && !u(e = o(r, t))) return e; if (i(r = t.valueOf) && !u(e = o(r, t))) return e; if ("string" !== n && i(r = t.toString) && !u(e = o(r, t))) return e; throw c("Can't convert object to primitive value") } }, function (t, n, r) { var e = r(3), o = r(31), i = r(35), u = r(37), c = r(23), f = r(22), a = o("wks"), p = e.Symbol, s = p && p.for, l = f ? p : p && p.withoutSetter || u; t.exports = function (t) { var n; return i(a, t) && (c || "string" == typeof a[t]) || (n = "Symbol." + t, c && i(p, t) ? a[t] = p[t] : a[t] = (f && s ? s : l)(n)), a[t] } }, function (t, n, r) { var e = r(32), o = r(33); (t.exports = function (t, n) { return o[t] || (o[t] = n !== C ? n : {}) })("versions", []).push({ version: "3.19.1", mode: e ? "pure" : "global", copyright: "Â© 2021 Denis Pushkarev (zloirock.ru)" }) }, function (t, n) { t.exports = !1 }, function (t, n, r) { var e = r(3), o = r(34), r = "__core-js_shared__", r = e[r] || o(r, {}); t.exports = r }, function (t, n, r) { var e = r(3), o = Object.defineProperty; t.exports = function (n, r) { try { o(e, n, { value: r, configurable: !0, writable: !0 }) } catch (t) { e[n] = r } return r } }, function (t, n, r) { var e = r(12), o = r(36), i = e({}.hasOwnProperty); t.exports = Object.hasOwn || function (t, n) { return i(o(t), n) } }, function (t, n, r) { var e = r(3), o = r(14), i = e.Object; t.exports = function (t) { return i(o(t)) } }, function (t, n, r) { var r = r(12), e = 0, o = Math.random(), i = r(1..toString); t.exports = function (t) { return "Symbol(" + (t === C ? "" : t) + ")_" + i(++e + o, 36) } }, function (t, n, r) { var e = r(5), o = r(6), i = r(39); t.exports = !e && !o(function () { return 7 != Object.defineProperty(i("div"), "a", { get: function () { return 7 } }).a }) }, function (t, n, r) { var e = r(3), r = r(17), o = e.document, i = r(o) && r(o.createElement); t.exports = function (t) { return i ? o.createElement(t) : {} } }, function (t, n, r) { var e = r(5), o = r(41), i = r(9); t.exports = e ? function (t, n, r) { return o.f(t, n, i(1, r)) } : function (t, n, r) { return t[n] = r, t } }, function (t, n, r) { var e = r(3), o = r(5), i = r(38), u = r(42), c = r(15), f = e.TypeError, a = Object.defineProperty; n.f = o ? a : function (t, n, r) { if (u(t), n = c(n), u(r), i) try { return a(t, n, r) } catch (t) { } if ("get" in r || "set" in r) throw f("Accessors not supported"); return "value" in r && (t[n] = r.value), t } }, function (t, n, r) { var e = r(3), o = r(17), i = e.String, u = e.TypeError; t.exports = function (t) { if (o(t)) return t; throw u(i(t) + " is not an object") } }, function (t, n, r) { var f = r(3), a = r(18), p = r(35), s = r(40), l = r(34), e = r(44), o = r(45), y = r(49).CONFIGURABLE, i = o.get, v = o.enforce, d = String(String).split("String"); (t.exports = function (t, n, r, e) { var o = !!e && !!e.unsafe, i = !!e && !!e.enumerable, u = !!e && !!e.noTargetGet, c = e && e.name !== C ? e.name : n; a(r) && ("Symbol(" === String(c).slice(0, 7) && (c = "[" + String(c).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!p(r, "name") || y && r.name !== c) && s(r, "name", c), (e = v(r)).source || (e.source = d.join("string" == typeof c ? c : ""))), t !== f ? (o ? !u && t[n] && (i = !0) : delete t[n], i ? t[n] = r : s(t, n, r)) : i ? t[n] = r : l(n, r) })(Function.prototype, "toString", function () { return a(this) && i(this).source || e(this) }) }, function (t, n, r) { var e = r(12), o = r(18), r = r(33), i = e(Function.toString); o(r.inspectSource) || (r.inspectSource = function (t) { return i(t) }), t.exports = r.inspectSource }, function (t, n, r) { var e, o, i, u, c, f, a, p, s = r(46), l = r(3), y = r(12), v = r(17), d = r(40), b = r(35), g = r(33), h = r(47), r = r(48), m = "Object already initialized", x = l.TypeError, l = l.WeakMap; a = s || g.state ? (e = g.state || (g.state = new l), o = y(e.get), i = y(e.has), u = y(e.set), c = function (t, n) { if (i(e, t)) throw new x(m); return n.facade = t, u(e, t, n), n }, f = function (t) { return o(e, t) || {} }, function (t) { return i(e, t) }) : (r[p = h("state")] = !0, c = function (t, n) { if (b(t, p)) throw new x(m); return n.facade = t, d(t, p, n), n }, f = function (t) { return b(t, p) ? t[p] : {} }, function (t) { return b(t, p) }), t.exports = { set: c, get: f, has: a, enforce: function (t) { return a(t) ? f(t) : c(t, {}) }, getterFor: function (r) { return function (t) { var n; if (!v(t) || (n = f(t)).type !== r) throw x("Incompatible receiver, " + r + " required"); return n } } } }, function (t, n, r) { var e = r(3), o = r(18), r = r(44), e = e.WeakMap; t.exports = o(e) && /native code/.test(r(e)) }, function (t, n, r) { var e = r(31), o = r(37), i = e("keys"); t.exports = function (t) { return i[t] || (i[t] = o(t)) } }, function (t, n) { t.exports = {} }, function (t, n, r) { var e = r(5), o = r(35), i = Function.prototype, u = e && Object.getOwnPropertyDescriptor, r = o(i, "name"), o = r && "something" === function () { }.name, i = r && (!e || e && u(i, "name").configurable); t.exports = { EXISTS: r, PROPER: o, CONFIGURABLE: i } }, function (t, n, r) { var c = r(35), f = r(51), a = r(4), p = r(41); t.exports = function (t, n) { for (var r = f(n), e = p.f, o = a.f, i = 0; i < r.length; i++) { var u = r[i]; c(t, u) || e(t, u, o(n, u)) } } }, function (t, n, r) { var e = r(20), o = r(12), i = r(52), u = r(60), c = r(42), f = o([].concat); t.exports = e("Reflect", "ownKeys") || function (t) { var n = i.f(c(t)), r = u.f; return r ? f(n, r(t)) : n } }, function (t, n, r) { var e = r(53), o = r(59).concat("length", "prototype"); n.f = Object.getOwnPropertyNames || function (t) { return e(t, o) } }, function (t, n, r) { var e = r(12), u = r(35), c = r(10), f = r(54).indexOf, a = r(48), p = e([].push); t.exports = function (t, n) { var r, e = c(t), o = 0, i = []; for (r in e) !u(a, r) && u(e, r) && p(i, r); for (; n.length > o;)u(e, r = n[o++]) && (~f(i, r) || p(i, r)); return i } }, function (t, n, r) { var f = r(10), a = r(55), p = r(57), r = function (c) { return function (t, n, r) { var e, o = f(t), i = p(o), u = a(r, i); if (c && n != n) { for (; u < i;)if ((e = o[u++]) != e) return !0 } else for (; u < i; u++)if ((c || u in o) && o[u] === n) return c || u || 0; return !c && -1 } }; t.exports = { includes: r(!0), indexOf: r(!1) } }, function (t, n, r) { var e = r(56), o = Math.max, i = Math.min; t.exports = function (t, n) { t = e(t); return t < 0 ? o(t + n, 0) : i(t, n) } }, function (t, n) { var r = Math.ceil, e = Math.floor; t.exports = function (t) { t = +t; return t != t || 0 == t ? 0 : (0 < t ? e : r)(t) } }, function (t, n, r) { var e = r(58); t.exports = function (t) { return e(t.length) } }, function (t, n, r) { var e = r(56), o = Math.min; t.exports = function (t) { return 0 < t ? o(e(t), 9007199254740991) : 0 } }, function (t, n) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, function (t, n) { n.f = Object.getOwnPropertySymbols }, function (t, n, r) { var e = r(6), o = r(18), i = /#|\.prototype\./, r = function (t, n) { t = c[u(t)]; return t == a || t != f && (o(n) ? e(n) : !!n) }, u = r.normalize = function (t) { return String(t).replace(i, ".").toLowerCase() }, c = r.data = {}, f = r.NATIVE = "N", a = r.POLYFILL = "P"; t.exports = r }, function (t, n, r) { var e = r(30), o = r(63), r = r(41), i = e("unscopables"), u = Array.prototype; u[i] == C && r.f(u, i, { configurable: !0, value: o(null) }), t.exports = function (t) { u[i][t] = !0 } }, function (t, n, r) { function e() { } function o(t) { return "<script>" + t + "</" + v + ">" } function i(t) { t.write(o("")), t.close(); var n = t.parentWindow.Object; return t = null, n } var u, c = r(42), f = r(64), a = r(59), p = r(48), s = r(66), l = r(39), r = r(47), y = "prototype", v = "script", d = r("IE_PROTO"), b = function () { try { u = new ActiveXObject("htmlfile") } catch (t) { } var t; b = "undefined" == typeof document || document.domain && u ? i(u) : ((t = l("iframe")).style.display = "none", s.appendChild(t), t.src = String("javascript:"), (t = t.contentWindow.document).open(), t.write(o("document.F=Object")), t.close(), t.F); for (var n = a.length; n--;)delete b[y][a[n]]; return b() }; p[d] = !0, t.exports = Object.create || function (t, n) { var r; return null !== t ? (e[y] = c(t), r = new e, e[y] = null, r[d] = t) : r = b(), n === C ? r : f(r, n) } }, function (t, n, r) { var e = r(5), c = r(41), f = r(42), a = r(10), p = r(65); t.exports = e ? Object.defineProperties : function (t, n) { f(t); for (var r, e = a(n), o = p(n), i = o.length, u = 0; u < i;)c.f(t, r = o[u++], e[r]); return t } }, function (t, n, r) { var e = r(53), o = r(59); t.exports = Object.keys || function (t) { return e(t, o) } }, function (t, n, r) { r = r(20); t.exports = r("document", "documentElement") }, function (t, n, r) { r(2)({ target: "Object", stat: !0 }, { hasOwn: r(35) }) }, function (t, n, r) { var e = r(2), o = r(12), i = r(14), u = r(56), c = r(69), r = r(6), f = o("".charAt); e({ target: "String", proto: !0, forced: r(function () { return "\ud842" !== "ð ®·".at(0) }) }, { at: function (t) { var n = c(i(this)), r = n.length, t = u(t), t = 0 <= t ? t : r + t; return t < 0 || r <= t ? C : f(n, t) } }) }, function (t, n, r) { var e = r(3), o = r(70), i = e.String; t.exports = function (t) { if ("Symbol" === o(t)) throw TypeError("Cannot convert a Symbol value to a string"); return i(t) } }, function (t, n, r) { var e = r(3), o = r(71), i = r(18), u = r(13), c = r(30)("toStringTag"), f = e.Object, a = "Arguments" == u(function () { return arguments }()); t.exports = o ? u : function (t) { var n; return t === C ? "Undefined" : null === t ? "Null" : "string" == typeof (t = function (t, n) { try { return t[n] } catch (t) { } }(n = f(t), c)) ? t : a ? u(n) : "Object" == (t = u(n)) && i(n.callee) ? "Arguments" : t } }, function (t, n, r) { var e = {}; e[r(30)("toStringTag")] = "z", t.exports = "[object z]" === String(e) }, function (t, n, r) { var e = r(73), o = r(57), i = r(56), u = e.aTypedArray; (0, e.exportTypedArrayMethod)("at", function (t) { var n = u(this), r = o(n), t = i(t), t = 0 <= t ? t : r + t; return t < 0 || r <= t ? C : n[t] }) }, function (t, n, r) { function e(t) { return !!s(t) && (t = y(t), l(M, t) || l(R, t)) } var o, i, u, c = r(74), f = r(5), a = r(3), p = r(18), s = r(17), l = r(35), y = r(70), v = r(28), d = r(40), b = r(43), g = r(41).f, h = r(21), m = r(75), x = r(77), O = r(30), S = r(37), w = a.Int8Array, j = w && w.prototype, r = a.Uint8ClampedArray, r = r && r.prototype, A = w && m(w), T = j && m(j), w = Object.prototype, P = a.TypeError, O = O("toStringTag"), _ = S("TYPED_ARRAY_TAG"), E = S("TYPED_ARRAY_CONSTRUCTOR"), I = c && !!x && "Opera" !== y(a.opera), c = !1, M = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, R = { BigInt64Array: 8, BigUint64Array: 8 }; for (o in M) (u = (i = a[o]) && i.prototype) ? d(u, E, i) : I = !1; for (o in R) (u = (i = a[o]) && i.prototype) && d(u, E, i); if ((!I || !p(A) || A === Function.prototype) && (A = function () { throw P("Incorrect invocation") }, I)) for (o in M) a[o] && x(a[o], A); if ((!I || !T || T === w) && (T = A.prototype, I)) for (o in M) a[o] && x(a[o].prototype, T); if (I && m(r) !== T && x(r, T), f && !l(T, O)) for (o in c = !0, g(T, O, { get: function () { return s(this) ? this[_] : C } }), M) a[o] && d(a[o], _, o); t.exports = { NATIVE_ARRAY_BUFFER_VIEWS: I, TYPED_ARRAY_CONSTRUCTOR: E, TYPED_ARRAY_TAG: c && _, aTypedArray: function (t) { if (e(t)) return t; throw P("Target is not a typed array") }, aTypedArrayConstructor: function (t) { if (p(t) && (!x || h(A, t))) return t; throw P(v(t) + " is not a typed array constructor") }, exportTypedArrayMethod: function (t, n, r) { if (f) { if (r) for (var e in M) { e = a[e]; if (e && l(e.prototype, t)) try { delete e.prototype[t] } catch (t) { } } T[t] && !r || b(T, t, !r && I && j[t] || n) } }, exportTypedArrayStaticMethod: function (t, n, r) { var e, o; if (f) { if (x) { if (r) for (e in M) if ((o = a[e]) && l(o, t)) try { delete o[t] } catch (t) { } if (A[t] && !r) return; try { return b(A, t, !r && I && A[t] || n) } catch (t) { } } for (e in M) !(o = a[e]) || o[t] && !r || b(o, t, n) } }, isView: function (t) { if (!s(t)) return !1; t = y(t); return "DataView" === t || l(M, t) || l(R, t) }, isTypedArray: e, TypedArray: A, TypedArrayPrototype: T } }, function (t, n) { t.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView }, function (t, n, r) { var e = r(3), o = r(35), i = r(18), u = r(36), c = r(47), r = r(76), f = c("IE_PROTO"), a = e.Object, p = a.prototype; t.exports = r ? a.getPrototypeOf : function (t) { var n = u(t); if (o(n, f)) return n[f]; t = n.constructor; return i(t) && n instanceof t ? t.prototype : n instanceof a ? p : null } }, function (t, n, r) { r = r(6); t.exports = !r(function () { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype }) }, function (t, n, r) { var o = r(12), i = r(42), u = r(78); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var r, e = !1, t = {}; try { (r = o(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(t, []), e = t instanceof Array } catch (t) { } return function (t, n) { return i(t), u(n), e ? r(t, n) : t.__proto__ = n, t } }() : C) }, function (t, n, r) { var e = r(3), o = r(18), i = e.String, u = e.TypeError; t.exports = function (t) { if ("object" == typeof t || o(t)) return t; throw u("Can't set " + i(t) + " as a prototype") } }, function (t, n, r) { var e = r(3), o = r(12), i = r(6), u = r(27), c = r(80), f = r(73), a = r(82), p = r(83), s = r(24), l = r(84), y = e.Array, v = f.aTypedArray, f = f.exportTypedArrayMethod, d = e.Uint16Array, b = d && o(d.prototype.sort), o = !(!b || i(function () { b(new d(2), null) }) && i(function () { b(new d(2), {}) })), g = !!b && !i(function () { if (s) return s < 74; if (a) return a < 67; if (p) return !0; if (l) return l < 602; for (var t, n = new d(516), r = y(516), e = 0; e < 516; e++)t = e % 4, n[e] = 515 - e, r[e] = e - 2 * t + 3; for (b(n, function (t, n) { return (t / 4 | 0) - (n / 4 | 0) }), e = 0; e < 516; e++)if (n[e] !== r[e]) return !0 }); f("sort", function (t) { return t !== C && u(t), g ? b(this, t) : c(v(this), (r = t, function (t, n) { return r !== C ? +r(t, n) || 0 : n != n ? -1 : t != t ? 1 : 0 === t && 0 === n ? 0 < 1 / t && 1 / n < 0 ? 1 : -1 : n < t })); var r }, !g || o) }, function (t, n, r) { var o = r(81), i = Math.floor, u = function (t, n) { var r = t.length, e = i(r / 2); return r < 8 ? c(t, n) : f(t, u(o(t, 0, e), n), u(o(t, e), n), n) }, c = function (t, n) { for (var r, e, o = t.length, i = 1; i < o;) { for (r = t[e = i]; e && 0 < n(t[e - 1], r);)t[e] = t[--e]; e !== i++ && (t[e] = r) } return t }, f = function (t, n, r, e) { for (var o = n.length, i = r.length, u = 0, c = 0; u < o || c < i;)t[u + c] = u < o && c < i ? e(n[u], r[c]) <= 0 ? n[u++] : r[c++] : u < o ? n[u++] : r[c++]; return t }; t.exports = u }, function (t, n, r) { r = r(12); t.exports = r([].slice) }, function (t, n, r) { r = r(25).match(/firefox\/(\d+)/i); t.exports = !!r && +r[1] }, function (t, n, r) { r = r(25); t.exports = /MSIE|Trident/.test(r) }, function (t, n, r) { r = r(25).match(/AppleWebKit\/(\d+)\./); t.exports = !!r && +r[1] }, function (t, n, r) { var e = r(2), o = r(3), r = r(86); e({ global: !0, bind: !0, enumerable: !0, forced: !o.setImmediate || !o.clearImmediate }, { setImmediate: r.set, clearImmediate: r.clear }) }, function (t, n, r) { var e, o, i = r(3), u = r(87), c = r(88), f = r(18), a = r(35), p = r(6), s = r(66), l = r(81), y = r(39), v = r(89), d = r(90), b = i.setImmediate, g = i.clearImmediate, h = i.process, m = i.Dispatch, x = i.Function, O = i.MessageChannel, S = i.String, w = 0, j = {}, A = "onreadystatechange"; try { e = i.location } catch (t) { } function T(t) { var n; a(j, t) && (n = j[t], delete j[t], n()) } function P(t) { return function () { T(t) } } function _(t) { T(t.data) } r = function (t) { i.postMessage(S(t), e.protocol + "//" + e.host) }; b && g || (b = function (t) { var n = l(arguments, 1); return j[++w] = function () { u(f(t) ? t : x(t), C, n) }, o(w), w }, g = function (t) { delete j[t] }, d ? o = function (t) { h.nextTick(P(t)) } : m && m.now ? o = function (t) { m.now(P(t)) } : O && !v ? (O = (v = new O).port2, v.port1.onmessage = _, o = c(O.postMessage, O)) : i.addEventListener && f(i.postMessage) && !i.importScripts && e && "file:" !== e.protocol && !p(r) ? (o = r, i.addEventListener("message", _, !1)) : o = A in y("script") ? function (t) { s.appendChild(y("script"))[A] = function () { s.removeChild(this), T(t) } } : function (t) { setTimeout(P(t), 0) }), t.exports = { set: b, clear: g } }, function (t, n) { var r = Function.prototype, e = r.apply, o = r.bind, i = r.call; t.exports = "object" == typeof Reflect && Reflect.apply || (o ? i.bind(e) : function () { return i.apply(e, arguments) }) }, function (t, n, r) { var e = r(12), o = r(27), i = e(e.bind); t.exports = function (t, n) { return o(t), n === C ? t : i ? i(t, n) : function () { return t.apply(n, arguments) } } }, function (t, n, r) { r = r(25); t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(r) }, function (t, n, r) { var e = r(13), r = r(3); t.exports = "process" == e(r.process) }], o.c = e, o.d = function (t, n, r) { o.o(t, n) || Object.defineProperty(t, n, { enumerable: !0, get: r }) }, o.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, o.t = function (n, t) { if (1 & t && (n = o(n)), 8 & t) return n; if (4 & t && "object" == typeof n && n && n.__esModule) return n; var r = Object.create(null); if (o.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: n }), 2 & t && "string" != typeof n) for (var e in n) o.d(r, e, function (t) { return n[t] }.bind(null, e)); return r }, o.n = function (t) { var n = t && t.__esModule ? function () { return t.default } : function () { return t }; return o.d(n, "a", n), n }, o.o = function (t, n) { return Object.prototype.hasOwnProperty.call(t, n) }, o.p = "", o(o.s = 0) }();; var wpcf7 = { "api": { "root": "https:\/\/ninetheme.com\/themes\/cryptoland\/wp-json\/", "namespace": "contact-form-7\/v1" }, "cached": "1" }; !function () { "use strict"; const e = e => Math.abs(parseInt(e, 10)), t = (e, t) => { const r = new Map([["init", "init"], ["validation_failed", "invalid"], ["acceptance_missing", "unaccepted"], ["spam", "spam"], ["aborted", "aborted"], ["mail_sent", "sent"], ["mail_failed", "failed"], ["submitting", "submitting"], ["resetting", "resetting"], ["payment_required", "payment-required"]]); r.has(t) && (t = r.get(t)), Array.from(r.values()).includes(t) || (t = `custom-${t = (t = t.replace(/[^0-9a-z]+/i, " ").trim()).replace(/\s+/, "-")}`); const n = e.getAttribute("data-status"); return e.wpcf7.status = t, e.setAttribute("data-status", t), e.classList.add(t), n && n !== t && e.classList.remove(n), t }, r = (e, t, r) => { const n = new CustomEvent(`wpcf7${t}`, { bubbles: !0, detail: r }); "string" == typeof e && (e = document.querySelector(e)), e.dispatchEvent(n) }, n = e => { const { root: t, namespace: r = "contact-form-7/v1" } = wpcf7.api; return a.reduceRight(((e, t) => r => t(r, e)), (e => { let n, a, { url: c, path: s, endpoint: o, headers: i, body: l, data: p, ...d } = e; "string" == typeof o && (n = r.replace(/^\/|\/$/g, ""), a = o.replace(/^\//, ""), s = a ? n + "/" + a : n), "string" == typeof s && (-1 !== t.indexOf("?") && (s = s.replace("?", "&")), s = s.replace(/^\//, ""), c = t + s), i = { Accept: "application/json, */*;q=0.1", ...i }, delete i["X-WP-Nonce"], p && (l = JSON.stringify(p), i["Content-Type"] = "application/json"); const u = { code: "fetch_error", message: "You are probably offline." }, f = { code: "invalid_json", message: "The response is not a valid JSON response." }; return window.fetch(c || s || window.location.href, { ...d, headers: i, body: l }).then((e => Promise.resolve(e).then((e => { if (e.status >= 200 && e.status < 300) return e; throw e })).then((e => { if (204 === e.status) return null; if (e && e.json) return e.json().catch((() => { throw f })); throw f }))), (() => { throw u })) }))(e) }, a = []; function c(e) { let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (wpcf7.blocked) return s(e), void t(e, "submitting"); const c = new FormData(e); a.submitter && a.submitter.name && c.append(a.submitter.name, a.submitter.value); const o = { contactFormId: e.wpcf7.id, pluginVersion: e.wpcf7.pluginVersion, contactFormLocale: e.wpcf7.locale, unitTag: e.wpcf7.unitTag, containerPostId: e.wpcf7.containerPost, status: e.wpcf7.status, inputs: Array.from(c, (e => { const t = e[0], r = e[1]; return !t.match(/^_/) && { name: t, value: r } })).filter((e => !1 !== e)), formData: c }, i = t => { const r = document.createElement("li"); r.setAttribute("id", t.error_id), t.idref ? r.insertAdjacentHTML("beforeend", `<a href="#${t.idref}">${t.message}</a>`) : r.insertAdjacentText("beforeend", t.message), e.wpcf7.parent.querySelector(".screen-reader-response ul").appendChild(r) }, l = t => { const r = e.querySelector(t.into), n = r.querySelector(".wpcf7-form-control"); n.classList.add("wpcf7-not-valid"), n.setAttribute("aria-describedby", t.error_id); const a = document.createElement("span"); a.setAttribute("class", "wpcf7-not-valid-tip"), a.setAttribute("aria-hidden", "true"), a.insertAdjacentText("beforeend", t.message), r.appendChild(a), r.querySelectorAll("[aria-invalid]").forEach((e => { e.setAttribute("aria-invalid", "true") })), n.closest(".use-floating-validation-tip") && (n.addEventListener("focus", (e => { a.setAttribute("style", "display: none") })), a.addEventListener("mouseover", (e => { a.setAttribute("style", "display: none") }))) }; n({ endpoint: `contact-forms/${e.wpcf7.id}/feedback`, method: "POST", body: c, wpcf7: { endpoint: "feedback", form: e, detail: o } }).then((n => { const a = t(e, n.status); return o.status = n.status, o.apiResponse = n, ["invalid", "unaccepted", "spam", "aborted"].includes(a) ? r(e, a, o) : ["sent", "failed"].includes(a) && r(e, `mail${a}`, o), r(e, "submit", o), n })).then((t => { t.posted_data_hash && (e.querySelector('input[name="_wpcf7_posted_data_hash"]').value = t.posted_data_hash), "mail_sent" === t.status && (e.reset(), e.wpcf7.resetOnMailSent = !0), t.invalid_fields && (t.invalid_fields.forEach(i), t.invalid_fields.forEach(l)), e.wpcf7.parent.querySelector('.screen-reader-response [role="status"]').insertAdjacentText("beforeend", t.message), e.querySelectorAll(".wpcf7-response-output").forEach((e => { e.innerText = t.message })) })).catch((e => console.error(e))) } n.use = e => { a.unshift(e) }, n.use(((e, n) => { if (e.wpcf7 && "feedback" === e.wpcf7.endpoint) { const { form: n, detail: a } = e.wpcf7; s(n), r(n, "beforesubmit", a), t(n, "submitting") } return n(e) })); const s = e => { e.wpcf7.parent.querySelector('.screen-reader-response [role="status"]').innerText = "", e.wpcf7.parent.querySelector(".screen-reader-response ul").innerText = "", e.querySelectorAll(".wpcf7-not-valid-tip").forEach((e => { e.remove() })), e.querySelectorAll("[aria-invalid]").forEach((e => { e.setAttribute("aria-invalid", "false") })), e.querySelectorAll(".wpcf7-form-control").forEach((e => { e.removeAttribute("aria-describedby"), e.classList.remove("wpcf7-not-valid") })), e.querySelectorAll(".wpcf7-response-output").forEach((e => { e.innerText = "" })) }; function o(e) { const a = new FormData(e), c = { contactFormId: e.wpcf7.id, pluginVersion: e.wpcf7.pluginVersion, contactFormLocale: e.wpcf7.locale, unitTag: e.wpcf7.unitTag, containerPostId: e.wpcf7.containerPost, status: e.wpcf7.status, inputs: Array.from(a, (e => { const t = e[0], r = e[1]; return !t.match(/^_/) && { name: t, value: r } })).filter((e => !1 !== e)), formData: a }; n({ endpoint: `contact-forms/${e.wpcf7.id}/refill`, method: "GET", wpcf7: { endpoint: "refill", form: e, detail: c } }).then((n => { e.wpcf7.resetOnMailSent ? (delete e.wpcf7.resetOnMailSent, t(e, "mail_sent")) : t(e, "init"), c.apiResponse = n, r(e, "reset", c) })).catch((e => console.error(e))) } n.use(((e, r) => { if (e.wpcf7 && "refill" === e.wpcf7.endpoint) { const { form: r, detail: n } = e.wpcf7; s(r), t(r, "resetting") } return r(e) })); const i = (e, t) => { for (const r in t) { const n = t[r]; e.querySelectorAll(`input[name="${r}"]`).forEach((e => { e.value = "" })), e.querySelectorAll(`img.wpcf7-captcha-${r}`).forEach((e => { e.setAttribute("src", n) })); const a = /([0-9]+)\.(png|gif|jpeg)$/.exec(n); a && e.querySelectorAll(`input[name="_wpcf7_captcha_challenge_${r}"]`).forEach((e => { e.value = a[1] })) } }, l = (e, t) => { for (const r in t) { const n = t[r][0], a = t[r][1]; e.querySelectorAll(`.wpcf7-form-control-wrap.${r}`).forEach((e => { e.querySelector(`input[name="${r}"]`).value = "", e.querySelector(".wpcf7-quiz-label").textContent = n, e.querySelector(`input[name="_wpcf7_quiz_answer_${r}"]`).value = a })) } }; function p(t) { const r = new FormData(t); t.wpcf7 = { id: e(r.get("_wpcf7")), status: t.getAttribute("data-status"), pluginVersion: r.get("_wpcf7_version"), locale: r.get("_wpcf7_locale"), unitTag: r.get("_wpcf7_unit_tag"), containerPost: e(r.get("_wpcf7_container_post")), parent: t.closest(".wpcf7") }, t.querySelectorAll(".has-spinner").forEach((e => { e.insertAdjacentHTML("afterend", '<span class="wpcf7-spinner"></span>') })), (e => { e.querySelectorAll(".wpcf7-exclusive-checkbox").forEach((t => { t.addEventListener("change", (t => { const r = t.target.getAttribute("name"); e.querySelectorAll(`input[type="checkbox"][name="${r}"]`).forEach((e => { e !== t.target && (e.checked = !1) })) })) })) })(t), (e => { e.querySelectorAll(".has-free-text").forEach((t => { const r = t.querySelector("input.wpcf7-free-text"), n = t.querySelector('input[type="checkbox"], input[type="radio"]'); r.disabled = !n.checked, e.addEventListener("change", (e => { r.disabled = !n.checked, e.target === n && n.checked && r.focus() })) })) })(t), (e => { e.querySelectorAll(".wpcf7-validates-as-url").forEach((e => { e.addEventListener("change", (t => { let r = e.value.trim(); r && !r.match(/^[a-z][a-z0-9.+-]*:/i) && -1 !== r.indexOf(".") && (r = r.replace(/^\/+/, ""), r = "http://" + r), e.value = r })) })) })(t), (e => { if (!e.querySelector(".wpcf7-acceptance") || e.classList.contains("wpcf7-acceptance-as-validation")) return; const t = () => { let t = !0; e.querySelectorAll(".wpcf7-acceptance").forEach((e => { if (!t || e.classList.contains("optional")) return; const r = e.querySelector('input[type="checkbox"]'); (e.classList.contains("invert") && r.checked || !e.classList.contains("invert") && !r.checked) && (t = !1) })), e.querySelectorAll(".wpcf7-submit").forEach((e => { e.disabled = !t })) }; t(), e.addEventListener("change", (e => { t() })), e.addEventListener("wpcf7reset", (e => { t() })) })(t), (t => { const r = (t, r) => { const n = e(t.getAttribute("data-starting-value")), a = e(t.getAttribute("data-maximum-value")), c = e(t.getAttribute("data-minimum-value")), s = t.classList.contains("down") ? n - r.value.length : r.value.length; t.setAttribute("data-current-value", s), t.innerText = s, a && a < r.value.length ? t.classList.add("too-long") : t.classList.remove("too-long"), c && r.value.length < c ? t.classList.add("too-short") : t.classList.remove("too-short") }, n = e => { e = { init: !1, ...e }, t.querySelectorAll(".wpcf7-character-count").forEach((n => { const a = n.getAttribute("data-target-name"), c = t.querySelector(`[name="${a}"]`); c && (c.value = c.defaultValue, r(n, c), e.init && c.addEventListener("keyup", (e => { r(n, c) }))) })) }; n({ init: !0 }), t.addEventListener("wpcf7reset", (e => { n() })) })(t), window.addEventListener("load", (e => { wpcf7.cached && t.reset() })), t.addEventListener("reset", (e => { wpcf7.reset(t) })), t.addEventListener("submit", (e => { const r = e.submitter; wpcf7.submit(t, { submitter: r }), e.preventDefault() })), t.addEventListener("wpcf7submit", (e => { e.detail.apiResponse.captcha && i(t, e.detail.apiResponse.captcha), e.detail.apiResponse.quiz && l(t, e.detail.apiResponse.quiz) })), t.addEventListener("wpcf7reset", (e => { e.detail.apiResponse.captcha && i(t, e.detail.apiResponse.captcha), e.detail.apiResponse.quiz && l(t, e.detail.apiResponse.quiz) })) } document.addEventListener("DOMContentLoaded", (e => { var t; if ("undefined" == typeof wpcf7) return void console.error("wpcf7 is not defined."); if (void 0 === wpcf7.api) return void console.error("wpcf7.api is not defined."); if ("function" != typeof window.fetch) return void console.error("Your browser doesn't support window.fetch()."); if ("function" != typeof window.FormData) return void console.error("Your browser doesn't support window.FormData()."); const r = document.querySelectorAll(".wpcf7 > form"); "function" == typeof r.forEach ? (wpcf7 = { init: p, submit: c, reset: o, ...null !== (t = wpcf7) && void 0 !== t ? t : {} }, r.forEach((e => wpcf7.init(e)))) : console.error("Your browser doesn't support NodeList.forEach().") })) }(); !function (a) { a.flexslider = function (b, c) { var d = a(b); d.vars = a.extend({}, a.flexslider.defaults, c); var j, e = d.vars.namespace, f = window.navigator && window.navigator.msPointerEnabled && window.MSGesture, g = ("ontouchstart" in window || f || window.DocumentTouch && document instanceof DocumentTouch) && d.vars.touch, h = "click touchend MSPointerUp", i = "", k = "vertical" === d.vars.direction, l = d.vars.reverse, m = d.vars.itemWidth > 0, n = "fade" === d.vars.animation, o = "" !== d.vars.asNavFor, p = {}, q = !0; a.data(b, "flexslider", d), p = { init: function () { d.animating = !1, d.currentSlide = parseInt(d.vars.startAt ? d.vars.startAt : 0, 10), isNaN(d.currentSlide) && (d.currentSlide = 0), d.animatingTo = d.currentSlide, d.atEnd = 0 === d.currentSlide || d.currentSlide === d.last, d.containerSelector = d.vars.selector.substr(0, d.vars.selector.search(" ")), d.slides = a(d.vars.selector, d), d.container = a(d.containerSelector, d), d.count = d.slides.length, d.syncExists = a(d.vars.sync).length > 0, "slide" === d.vars.animation && (d.vars.animation = "swing"), d.prop = k ? "top" : "marginLeft", d.args = {}, d.manualPause = !1, d.stopped = !1, d.started = !1, d.startTimeout = null, d.transitions = !d.vars.video && !n && d.vars.useCSS && function () { var a = document.createElement("div"), b = ["perspectiveProperty", "WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective"]; for (var c in b) if (void 0 !== a.style[b[c]]) return d.pfx = b[c].replace("Perspective", "").toLowerCase(), d.prop = "-" + d.pfx + "-transform", !0; return !1 }(), d.ensureAnimationEnd = "", "" !== d.vars.controlsContainer && (d.controlsContainer = a(d.vars.controlsContainer).length > 0 && a(d.vars.controlsContainer)), "" !== d.vars.manualControls && (d.manualControls = a(d.vars.manualControls).length > 0 && a(d.vars.manualControls)), d.vars.randomize && (d.slides.sort(function () { return Math.round(Math.random()) - .5 }), d.container.empty().append(d.slides)), d.doMath(), d.setup("init"), d.vars.controlNav && p.controlNav.setup(), d.vars.directionNav && p.directionNav.setup(), d.vars.keyboard && (1 === a(d.containerSelector).length || d.vars.multipleKeyboard) && a(document).bind("keyup", function (a) { var b = a.keyCode; if (!d.animating && (39 === b || 37 === b)) { var c = 39 === b ? d.getTarget("next") : 37 === b ? d.getTarget("prev") : !1; d.flexAnimate(c, d.vars.pauseOnAction) } }), d.vars.mousewheel && d.bind("mousewheel", function (a, b) { a.preventDefault(); var f = 0 > b ? d.getTarget("next") : d.getTarget("prev"); d.flexAnimate(f, d.vars.pauseOnAction) }), d.vars.pausePlay && p.pausePlay.setup(), d.vars.slideshow && d.vars.pauseInvisible && p.pauseInvisible.init(), d.vars.slideshow && (d.vars.pauseOnHover && d.hover(function () { d.manualPlay || d.manualPause || d.pause() }, function () { d.manualPause || d.manualPlay || d.stopped || d.play() }), d.vars.pauseInvisible && p.pauseInvisible.isHidden() || (d.vars.initDelay > 0 ? d.startTimeout = setTimeout(d.play, d.vars.initDelay) : d.play())), o && p.asNav.setup(), g && d.vars.touch && p.touch(), (!n || n && d.vars.smoothHeight) && a(window).bind("resize orientationchange focus", p.resize), d.find("img").attr("draggable", "false"), setTimeout(function () { d.vars.start(d) }, 200) }, asNav: { setup: function () { d.asNav = !0, d.animatingTo = Math.floor(d.currentSlide / d.move), d.currentItem = d.currentSlide, d.slides.removeClass(e + "active-slide").eq(d.currentItem).addClass(e + "active-slide"), f ? (b._slider = d, d.slides.each(function () { var b = this; b._gesture = new MSGesture, b._gesture.target = b, b.addEventListener("MSPointerDown", function (a) { a.preventDefault(), a.currentTarget._gesture && a.currentTarget._gesture.addPointer(a.pointerId) }, !1), b.addEventListener("MSGestureTap", function (b) { b.preventDefault(); var c = a(this), e = c.index(); a(d.vars.asNavFor).data("flexslider").animating || c.hasClass("active") || (d.direction = d.currentItem < e ? "next" : "prev", d.flexAnimate(e, d.vars.pauseOnAction, !1, !0, !0)) }) })) : d.slides.on(h, function (b) { b.preventDefault(); var c = a(this), f = c.index(), g = c.offset().left - a(d).scrollLeft(); 0 >= g && c.hasClass(e + "active-slide") ? d.flexAnimate(d.getTarget("prev"), !0) : a(d.vars.asNavFor).data("flexslider").animating || c.hasClass(e + "active-slide") || (d.direction = d.currentItem < f ? "next" : "prev", d.flexAnimate(f, d.vars.pauseOnAction, !1, !0, !0)) }) } }, controlNav: { setup: function () { d.manualControls ? p.controlNav.setupManual() : p.controlNav.setupPaging() }, setupPaging: function () { var f, g, b = "thumbnails" === d.vars.controlNav ? "control-thumbs" : "control-paging", c = 1; if (d.controlNavScaffold = a('<ol class="' + e + "control-nav " + e + b + '"></ol>'), d.pagingCount > 1) for (var j = 0; j < d.pagingCount; j++) { if (g = d.slides.eq(j), f = "thumbnails" === d.vars.controlNav ? '<img src="' + g.attr("data-thumb") + '"/>' : "<a>" + c + "</a>", "thumbnails" === d.vars.controlNav && !0 === d.vars.thumbCaptions) { var k = g.attr("data-thumbcaption"); "" != k && void 0 != k && (f += '<span class="' + e + 'caption">' + k + "</span>") } d.controlNavScaffold.append("<li>" + f + "</li>"), c++ } d.controlsContainer ? a(d.controlsContainer).append(d.controlNavScaffold) : d.append(d.controlNavScaffold), p.controlNav.set(), p.controlNav.active(), d.controlNavScaffold.delegate("a, img", h, function (b) { if (b.preventDefault(), "" === i || i === b.type) { var c = a(this), f = d.controlNav.index(c); c.hasClass(e + "active") || (d.direction = f > d.currentSlide ? "next" : "prev", d.flexAnimate(f, d.vars.pauseOnAction)) } "" === i && (i = b.type), p.setToClearWatchedEvent() }) }, setupManual: function () { d.controlNav = d.manualControls, p.controlNav.active(), d.controlNav.bind(h, function (b) { if (b.preventDefault(), "" === i || i === b.type) { var c = a(this), f = d.controlNav.index(c); c.hasClass(e + "active") || (d.direction = f > d.currentSlide ? "next" : "prev", d.flexAnimate(f, d.vars.pauseOnAction)) } "" === i && (i = b.type), p.setToClearWatchedEvent() }) }, set: function () { var b = "thumbnails" === d.vars.controlNav ? "img" : "a"; d.controlNav = a("." + e + "control-nav li " + b, d.controlsContainer ? d.controlsContainer : d) }, active: function () { d.controlNav.removeClass(e + "active").eq(d.animatingTo).addClass(e + "active") }, update: function (b, c) { d.pagingCount > 1 && "add" === b ? d.controlNavScaffold.append(a("<li><a>" + d.count + "</a></li>")) : 1 === d.pagingCount ? d.controlNavScaffold.find("li").remove() : d.controlNav.eq(c).closest("li").remove(), p.controlNav.set(), d.pagingCount > 1 && d.pagingCount !== d.controlNav.length ? d.update(c, b) : p.controlNav.active() } }, directionNav: { setup: function () { var b = a('<ul class="' + e + 'direction-nav"><li><a class="' + e + 'prev" href="#">' + d.vars.prevText + '</a></li><li><a class="' + e + 'next" href="#">' + d.vars.nextText + "</a></li></ul>"); d.controlsContainer ? (a(d.controlsContainer).append(b), d.directionNav = a("." + e + "direction-nav li a", d.controlsContainer)) : (d.append(b), d.directionNav = a("." + e + "direction-nav li a", d)), p.directionNav.update(), d.directionNav.bind(h, function (b) { b.preventDefault(); var c; ("" === i || i === b.type) && (c = a(this).hasClass(e + "next") ? d.getTarget("next") : d.getTarget("prev"), d.flexAnimate(c, d.vars.pauseOnAction)), "" === i && (i = b.type), p.setToClearWatchedEvent() }) }, update: function () { var a = e + "disabled"; 1 === d.pagingCount ? d.directionNav.addClass(a).attr("tabindex", "-1") : d.vars.animationLoop ? d.directionNav.removeClass(a).removeAttr("tabindex") : 0 === d.animatingTo ? d.directionNav.removeClass(a).filter("." + e + "prev").addClass(a).attr("tabindex", "-1") : d.animatingTo === d.last ? d.directionNav.removeClass(a).filter("." + e + "next").addClass(a).attr("tabindex", "-1") : d.directionNav.removeClass(a).removeAttr("tabindex") } }, pausePlay: { setup: function () { var b = a('<div class="' + e + 'pauseplay"><a></a></div>'); d.controlsContainer ? (d.controlsContainer.append(b), d.pausePlay = a("." + e + "pauseplay a", d.controlsContainer)) : (d.append(b), d.pausePlay = a("." + e + "pauseplay a", d)), p.pausePlay.update(d.vars.slideshow ? e + "pause" : e + "play"), d.pausePlay.bind(h, function (b) { b.preventDefault(), ("" === i || i === b.type) && (a(this).hasClass(e + "pause") ? (d.manualPause = !0, d.manualPlay = !1, d.pause()) : (d.manualPause = !1, d.manualPlay = !0, d.play())), "" === i && (i = b.type), p.setToClearWatchedEvent() }) }, update: function (a) { "play" === a ? d.pausePlay.removeClass(e + "pause").addClass(e + "play").html(d.vars.playText) : d.pausePlay.removeClass(e + "play").addClass(e + "pause").html(d.vars.pauseText) } }, touch: function () { function r(f) { d.animating ? f.preventDefault() : (window.navigator.msPointerEnabled || 1 === f.touches.length) && (d.pause(), g = k ? d.h : d.w, i = Number(new Date), o = f.touches[0].pageX, p = f.touches[0].pageY, e = m && l && d.animatingTo === d.last ? 0 : m && l ? d.limit - (d.itemW + d.vars.itemMargin) * d.move * d.animatingTo : m && d.currentSlide === d.last ? d.limit : m ? (d.itemW + d.vars.itemMargin) * d.move * d.currentSlide : l ? (d.last - d.currentSlide + d.cloneOffset) * g : (d.currentSlide + d.cloneOffset) * g, a = k ? p : o, c = k ? o : p, b.addEventListener("touchmove", s, !1), b.addEventListener("touchend", t, !1)) } function s(b) { o = b.touches[0].pageX, p = b.touches[0].pageY, h = k ? a - p : a - o, j = k ? Math.abs(h) < Math.abs(o - c) : Math.abs(h) < Math.abs(p - c); var f = 500; (!j || Number(new Date) - i > f) && (b.preventDefault(), !n && d.transitions && (d.vars.animationLoop || (h /= 0 === d.currentSlide && 0 > h || d.currentSlide === d.last && h > 0 ? Math.abs(h) / g + 2 : 1), d.setProps(e + h, "setTouch"))) } function t() { if (b.removeEventListener("touchmove", s, !1), d.animatingTo === d.currentSlide && !j && null !== h) { var k = l ? -h : h, m = k > 0 ? d.getTarget("next") : d.getTarget("prev"); d.canAdvance(m) && (Number(new Date) - i < 550 && Math.abs(k) > 50 || Math.abs(k) > g / 2) ? d.flexAnimate(m, d.vars.pauseOnAction) : n || d.flexAnimate(d.currentSlide, d.vars.pauseOnAction, !0) } b.removeEventListener("touchend", t, !1), a = null, c = null, h = null, e = null } function u(a) { a.stopPropagation(), d.animating ? a.preventDefault() : (d.pause(), b._gesture.addPointer(a.pointerId), q = 0, g = k ? d.h : d.w, i = Number(new Date), e = m && l && d.animatingTo === d.last ? 0 : m && l ? d.limit - (d.itemW + d.vars.itemMargin) * d.move * d.animatingTo : m && d.currentSlide === d.last ? d.limit : m ? (d.itemW + d.vars.itemMargin) * d.move * d.currentSlide : l ? (d.last - d.currentSlide + d.cloneOffset) * g : (d.currentSlide + d.cloneOffset) * g) } function v(a) { a.stopPropagation(); var c = a.target._slider; if (c) { var d = -a.translationX, f = -a.translationY; return q += k ? f : d, h = q, j = k ? Math.abs(q) < Math.abs(-d) : Math.abs(q) < Math.abs(-f), a.detail === a.MSGESTURE_FLAG_INERTIA ? (setImmediate(function () { b._gesture.stop() }), void 0) : ((!j || Number(new Date) - i > 500) && (a.preventDefault(), !n && c.transitions && (c.vars.animationLoop || (h = q / (0 === c.currentSlide && 0 > q || c.currentSlide === c.last && q > 0 ? Math.abs(q) / g + 2 : 1)), c.setProps(e + h, "setTouch"))), void 0) } } function w(b) { b.stopPropagation(); var d = b.target._slider; if (d) { if (d.animatingTo === d.currentSlide && !j && null !== h) { var f = l ? -h : h, k = f > 0 ? d.getTarget("next") : d.getTarget("prev"); d.canAdvance(k) && (Number(new Date) - i < 550 && Math.abs(f) > 50 || Math.abs(f) > g / 2) ? d.flexAnimate(k, d.vars.pauseOnAction) : n || d.flexAnimate(d.currentSlide, d.vars.pauseOnAction, !0) } a = null, c = null, h = null, e = null, q = 0 } } var a, c, e, g, h, i, j = !1, o = 0, p = 0, q = 0; f ? (b.style.msTouchAction = "none", b._gesture = new MSGesture, b._gesture.target = b, b.addEventListener("MSPointerDown", u, !1), b._slider = d, b.addEventListener("MSGestureChange", v, !1), b.addEventListener("MSGestureEnd", w, !1)) : b.addEventListener("touchstart", r, !1) }, resize: function () { !d.animating && d.is(":visible") && (m || d.doMath(), n ? p.smoothHeight() : m ? (d.slides.width(d.computedW), d.update(d.pagingCount), d.setProps()) : k ? (d.viewport.height(d.h), d.setProps(d.h, "setTotal")) : (d.vars.smoothHeight && p.smoothHeight(), d.newSlides.width(d.computedW), d.setProps(d.computedW, "setTotal"))) }, smoothHeight: function (a) { if (!k || n) { var b = n ? d : d.viewport; a ? b.animate({ height: d.slides.eq(d.animatingTo).height() }, a) : b.height(d.slides.eq(d.animatingTo).height()) } }, sync: function (b) { var c = a(d.vars.sync).data("flexslider"), e = d.animatingTo; switch (b) { case "animate": c.flexAnimate(e, d.vars.pauseOnAction, !1, !0); break; case "play": c.playing || c.asNav || c.play(); break; case "pause": c.pause() } }, uniqueID: function (b) { return b.find("[id]").each(function () { var b = a(this); b.attr("id", b.attr("id") + "_clone") }), b }, pauseInvisible: { visProp: null, init: function () { var a = ["webkit", "moz", "ms", "o"]; if ("hidden" in document) return "hidden"; for (var b = 0; b < a.length; b++)a[b] + "Hidden" in document && (p.pauseInvisible.visProp = a[b] + "Hidden"); if (p.pauseInvisible.visProp) { var c = p.pauseInvisible.visProp.replace(/[H|h]idden/, "") + "visibilitychange"; document.addEventListener(c, function () { p.pauseInvisible.isHidden() ? d.startTimeout ? clearTimeout(d.startTimeout) : d.pause() : d.started ? d.play() : d.vars.initDelay > 0 ? setTimeout(d.play, d.vars.initDelay) : d.play() }) } }, isHidden: function () { return document[p.pauseInvisible.visProp] || !1 } }, setToClearWatchedEvent: function () { clearTimeout(j), j = setTimeout(function () { i = "" }, 3e3) } }, d.flexAnimate = function (b, c, f, h, i) { if (d.vars.animationLoop || b === d.currentSlide || (d.direction = b > d.currentSlide ? "next" : "prev"), o && 1 === d.pagingCount && (d.direction = d.currentItem < b ? "next" : "prev"), !d.animating && (d.canAdvance(b, i) || f) && d.is(":visible")) { if (o && h) { var j = a(d.vars.asNavFor).data("flexslider"); if (d.atEnd = 0 === b || b === d.count - 1, j.flexAnimate(b, !0, !1, !0, i), d.direction = d.currentItem < b ? "next" : "prev", j.direction = d.direction, Math.ceil((b + 1) / d.visible) - 1 === d.currentSlide || 0 === b) return d.currentItem = b, d.slides.removeClass(e + "active-slide").eq(b).addClass(e + "active-slide"), !1; d.currentItem = b, d.slides.removeClass(e + "active-slide").eq(b).addClass(e + "active-slide"), b = Math.floor(b / d.visible) } if (d.animating = !0, d.animatingTo = b, c && d.pause(), d.vars.before(d), d.syncExists && !i && p.sync("animate"), d.vars.controlNav && p.controlNav.active(), m || d.slides.removeClass(e + "active-slide").eq(b).addClass(e + "active-slide"), d.atEnd = 0 === b || b === d.last, d.vars.directionNav && p.directionNav.update(), b === d.last && (d.vars.end(d), d.vars.animationLoop || d.pause()), n) g ? (d.slides.eq(d.currentSlide).css({ opacity: 0, zIndex: 1 }), d.slides.eq(b).css({ opacity: 1, zIndex: 2 }), d.wrapup(q)) : (d.slides.eq(d.currentSlide).css({ zIndex: 1 }).animate({ opacity: 0 }, d.vars.animationSpeed, d.vars.easing), d.slides.eq(b).css({ zIndex: 2 }).animate({ opacity: 1 }, d.vars.animationSpeed, d.vars.easing, d.wrapup)); else { var r, s, t, q = k ? d.slides.filter(":first").height() : d.computedW; m ? (r = d.vars.itemMargin, t = (d.itemW + r) * d.move * d.animatingTo, s = t > d.limit && 1 !== d.visible ? d.limit : t) : s = 0 === d.currentSlide && b === d.count - 1 && d.vars.animationLoop && "next" !== d.direction ? l ? (d.count + d.cloneOffset) * q : 0 : d.currentSlide === d.last && 0 === b && d.vars.animationLoop && "prev" !== d.direction ? l ? 0 : (d.count + 1) * q : l ? (d.count - 1 - b + d.cloneOffset) * q : (b + d.cloneOffset) * q, d.setProps(s, "", d.vars.animationSpeed), d.transitions ? (d.vars.animationLoop && d.atEnd || (d.animating = !1, d.currentSlide = d.animatingTo), d.container.unbind("webkitTransitionEnd transitionend"), d.container.bind("webkitTransitionEnd transitionend", function () { clearTimeout(d.ensureAnimationEnd), d.wrapup(q) }), clearTimeout(d.ensureAnimationEnd), d.ensureAnimationEnd = setTimeout(function () { d.wrapup(q) }, d.vars.animationSpeed + 100)) : d.container.animate(d.args, d.vars.animationSpeed, d.vars.easing, function () { d.wrapup(q) }) } d.vars.smoothHeight && p.smoothHeight(d.vars.animationSpeed) } }, d.wrapup = function (a) { n || m || (0 === d.currentSlide && d.animatingTo === d.last && d.vars.animationLoop ? d.setProps(a, "jumpEnd") : d.currentSlide === d.last && 0 === d.animatingTo && d.vars.animationLoop && d.setProps(a, "jumpStart")), d.animating = !1, d.currentSlide = d.animatingTo, d.vars.after(d) }, d.animateSlides = function () { !d.animating && q && d.flexAnimate(d.getTarget("next")) }, d.pause = function () { clearInterval(d.animatedSlides), d.animatedSlides = null, d.playing = !1, d.vars.pausePlay && p.pausePlay.update("play"), d.syncExists && p.sync("pause") }, d.play = function () { d.playing && clearInterval(d.animatedSlides), d.animatedSlides = d.animatedSlides || setInterval(d.animateSlides, d.vars.slideshowSpeed), d.started = d.playing = !0, d.vars.pausePlay && p.pausePlay.update("pause"), d.syncExists && p.sync("play") }, d.stop = function () { d.pause(), d.stopped = !0 }, d.canAdvance = function (a, b) { var c = o ? d.pagingCount - 1 : d.last; return b ? !0 : o && d.currentItem === d.count - 1 && 0 === a && "prev" === d.direction ? !0 : o && 0 === d.currentItem && a === d.pagingCount - 1 && "next" !== d.direction ? !1 : a !== d.currentSlide || o ? d.vars.animationLoop ? !0 : d.atEnd && 0 === d.currentSlide && a === c && "next" !== d.direction ? !1 : d.atEnd && d.currentSlide === c && 0 === a && "next" === d.direction ? !1 : !0 : !1 }, d.getTarget = function (a) { return d.direction = a, "next" === a ? d.currentSlide === d.last ? 0 : d.currentSlide + 1 : 0 === d.currentSlide ? d.last : d.currentSlide - 1 }, d.setProps = function (a, b, c) { var e = function () { var c = a ? a : (d.itemW + d.vars.itemMargin) * d.move * d.animatingTo, e = function () { if (m) return "setTouch" === b ? a : l && d.animatingTo === d.last ? 0 : l ? d.limit - (d.itemW + d.vars.itemMargin) * d.move * d.animatingTo : d.animatingTo === d.last ? d.limit : c; switch (b) { case "setTotal": return l ? (d.count - 1 - d.currentSlide + d.cloneOffset) * a : (d.currentSlide + d.cloneOffset) * a; case "setTouch": return l ? a : a; case "jumpEnd": return l ? a : d.count * a; case "jumpStart": return l ? d.count * a : a; default: return a } }(); return -1 * e + "px" }(); d.transitions && (e = k ? "translate3d(0," + e + ",0)" : "translate3d(" + e + ",0,0)", c = void 0 !== c ? c / 1e3 + "s" : "0s", d.container.css("-" + d.pfx + "-transition-duration", c), d.container.css("transition-duration", c)), d.args[d.prop] = e, (d.transitions || void 0 === c) && d.container.css(d.args), d.container.css("transform", e) }, d.setup = function (b) { if (n) d.slides.css({ width: "100%", "float": "left", marginRight: "-100%", position: "relative" }), "init" === b && (g ? d.slides.css({ opacity: 0, display: "block", webkitTransition: "opacity " + d.vars.animationSpeed / 1e3 + "s ease", zIndex: 1 }).eq(d.currentSlide).css({ opacity: 1, zIndex: 2 }) : d.slides.css({ opacity: 0, display: "block", zIndex: 1 }).eq(d.currentSlide).css({ zIndex: 2 }).animate({ opacity: 1 }, d.vars.animationSpeed, d.vars.easing)), d.vars.smoothHeight && p.smoothHeight(); else { var c, f; "init" === b && (d.viewport = a('<div class="' + e + 'viewport"></div>').css({ overflow: "hidden", position: "relative" }).appendTo(d).append(d.container), d.cloneCount = 0, d.cloneOffset = 0, l && (f = a.makeArray(d.slides).reverse(), d.slides = a(f), d.container.empty().append(d.slides))), d.vars.animationLoop && !m && (d.cloneCount = 2, d.cloneOffset = 1, "init" !== b && d.container.find(".clone").remove(), p.uniqueID(d.slides.first().clone().addClass("clone").attr("aria-hidden", "true")).appendTo(d.container), p.uniqueID(d.slides.last().clone().addClass("clone").attr("aria-hidden", "true")).prependTo(d.container)), d.newSlides = a(d.vars.selector, d), c = l ? d.count - 1 - d.currentSlide + d.cloneOffset : d.currentSlide + d.cloneOffset, k && !m ? (d.container.height(200 * (d.count + d.cloneCount) + "%").css("position", "absolute").width("100%"), setTimeout(function () { d.newSlides.css({ display: "block" }), d.doMath(), d.viewport.height(d.h), d.setProps(c * d.h, "init") }, "init" === b ? 100 : 0)) : (d.container.width(200 * (d.count + d.cloneCount) + "%"), d.setProps(c * d.computedW, "init"), setTimeout(function () { d.doMath(), d.newSlides.css({ width: d.computedW, "float": "left", display: "block" }), d.vars.smoothHeight && p.smoothHeight() }, "init" === b ? 100 : 0)) } m || d.slides.removeClass(e + "active-slide").eq(d.currentSlide).addClass(e + "active-slide"), d.vars.init(d) }, d.doMath = function () { var a = d.slides.first(), b = d.vars.itemMargin, c = d.vars.minItems, e = d.vars.maxItems; d.w = void 0 === d.viewport ? d.width() : d.viewport.width(), d.h = a.height(), d.boxPadding = a.outerWidth() - a.width(), m ? (d.itemT = d.vars.itemWidth + b, d.minW = c ? c * d.itemT : d.w, d.maxW = e ? e * d.itemT - b : d.w, d.itemW = d.minW > d.w ? (d.w - b * (c - 1)) / c : d.maxW < d.w ? (d.w - b * (e - 1)) / e : d.vars.itemWidth > d.w ? d.w : d.vars.itemWidth, d.visible = Math.floor(d.w / d.itemW), d.move = d.vars.move > 0 && d.vars.move < d.visible ? d.vars.move : d.visible, d.pagingCount = Math.ceil((d.count - d.visible) / d.move + 1), d.last = d.pagingCount - 1, d.limit = 1 === d.pagingCount ? 0 : d.vars.itemWidth > d.w ? d.itemW * (d.count - 1) + b * (d.count - 1) : (d.itemW + b) * d.count - d.w - b) : (d.itemW = d.w, d.pagingCount = d.count, d.last = d.count - 1), d.computedW = d.itemW - d.boxPadding }, d.update = function (a, b) { d.doMath(), m || (a < d.currentSlide ? d.currentSlide += 1 : a <= d.currentSlide && 0 !== a && (d.currentSlide -= 1), d.animatingTo = d.currentSlide), d.vars.controlNav && !d.manualControls && ("add" === b && !m || d.pagingCount > d.controlNav.length ? p.controlNav.update("add") : ("remove" === b && !m || d.pagingCount < d.controlNav.length) && (m && d.currentSlide > d.last && (d.currentSlide -= 1, d.animatingTo -= 1), p.controlNav.update("remove", d.last))), d.vars.directionNav && p.directionNav.update() }, d.addSlide = function (b, c) { var e = a(b); d.count += 1, d.last = d.count - 1, k && l ? void 0 !== c ? d.slides.eq(d.count - c).after(e) : d.container.prepend(e) : void 0 !== c ? d.slides.eq(c).before(e) : d.container.append(e), d.update(c, "add"), d.slides = a(d.vars.selector + ":not(.clone)", d), d.setup(), d.vars.added(d) }, d.removeSlide = function (b) { var c = isNaN(b) ? d.slides.index(a(b)) : b; d.count -= 1, d.last = d.count - 1, isNaN(b) ? a(b, d.slides).remove() : k && l ? d.slides.eq(d.last).remove() : d.slides.eq(b).remove(), d.doMath(), d.update(c, "remove"), d.slides = a(d.vars.selector + ":not(.clone)", d), d.setup(), d.vars.removed(d) }, p.init() }, a(window).blur(function () { focused = !1 }).focus(function () { focused = !0 }), a.flexslider.defaults = { namespace: "flex-", selector: ".slides > li", animation: "fade", easing: "swing", direction: "horizontal", reverse: !1, animationLoop: !0, smoothHeight: !1, startAt: 0, slideshow: !0, slideshowSpeed: 7e3, animationSpeed: 600, initDelay: 0, randomize: !1, thumbCaptions: !1, pauseOnAction: !0, pauseOnHover: !1, pauseInvisible: !0, useCSS: !0, touch: !0, video: !1, controlNav: !0, directionNav: !0, prevText: "Previous", nextText: "Next", keyboard: !0, multipleKeyboard: !1, mousewheel: !1, pausePlay: !1, pauseText: "Pause", playText: "Play", controlsContainer: "", manualControls: "", sync: "", asNavFor: "", itemWidth: 0, itemMargin: 0, minItems: 1, maxItems: 0, move: 0, allowOneSlide: !0, start: function () { }, before: function () { }, after: function () { }, end: function () { }, added: function () { }, removed: function () { }, init: function () { } }, a.fn.flexslider = function (b) { if (void 0 === b && (b = {}), "object" == typeof b) return this.each(function () { var c = a(this), d = b.selector ? b.selector : ".slides > li", e = c.find(d); 1 === e.length && b.allowOneSlide === !0 || 0 === e.length ? (e.fadeIn(400), b.start && b.start(c)) : void 0 === c.data("flexslider") && new a.flexslider(this, b) }); var c = a(this).data("flexslider"); switch (b) { case "play": c.play(); break; case "pause": c.pause(); break; case "stop": c.stop(); break; case "next": c.flexAnimate(c.getTarget("next"), !0); break; case "prev": case "previous": c.flexAnimate(c.getTarget("prev"), !0); break; default: "number" == typeof b && c.flexAnimate(b, !0) } } }(jQuery);;/*!
* Name : Just Another Parallax [Jarallax]
* Version : 1.10.5
* Author : nK <https://nkdev.info>
* GitHub : https://github.com/nk-o/jarallax
*/!function (o) { var n = {}; function i(e) { if (n[e]) return n[e].exports; var t = n[e] = { i: e, l: !1, exports: {} }; return o[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports } i.m = o, i.c = n, i.d = function (e, t, o) { i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: o }) }, i.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, i.t = function (t, e) { if (1 & e && (t = i(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var o = Object.create(null); if (i.r(o), Object.defineProperty(o, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var n in t) i.d(o, n, function (e) { return t[e] }.bind(null, n)); return o }, i.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return i.d(t, "a", t), t }, i.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, i.p = "", i(i.s = 11) }([, , function (e, t, o) { "use strict"; e.exports = function (e) { "complete" === document.readyState || "interactive" === document.readyState ? e.call() : document.attachEvent ? document.attachEvent("onreadystatechange", function () { "interactive" === document.readyState && e.call() }) : document.addEventListener && document.addEventListener("DOMContentLoaded", e) } }, , function (o, e, t) { "use strict"; (function (e) { var t; t = "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}, o.exports = t }).call(this, t(5)) }, function (e, t, o) { "use strict"; var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; n = function () { return this }(); try { n = n || Function("return this")() || (0, eval)("this") } catch (e) { "object" === ("undefined" == typeof window ? "undefined" : i(window)) && (n = window) } e.exports = n }, , , , , , function (e, t, o) { e.exports = o(12) }, function (e, t, o) { "use strict"; var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, i = l(o(2)), a = o(4), r = l(o(13)); function l(e) { return e && e.__esModule ? e : { default: e } } var s = a.window.jarallax; if (a.window.jarallax = r.default, a.window.jarallax.noConflict = function () { return a.window.jarallax = s, this }, void 0 !== a.jQuery) { var c = function () { var e = arguments || []; Array.prototype.unshift.call(e, this); var t = r.default.apply(a.window, e); return "object" !== (void 0 === t ? "undefined" : n(t)) ? t : this }; c.constructor = r.default.constructor; var u = a.jQuery.fn.jarallax; a.jQuery.fn.jarallax = c, a.jQuery.fn.jarallax.noConflict = function () { return a.jQuery.fn.jarallax = u, this } } (0, i.default)(function () { (0, r.default)(document.querySelectorAll("[data-jarallax]")) }) }, function (e, j, S) { "use strict"; (function (e) { Object.defineProperty(j, "__esModule", { value: !0 }); var d = function (e, t) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return function (e, t) { var o = [], n = !0, i = !1, a = void 0; try { for (var r, l = e[Symbol.iterator](); !(n = (r = l.next()).done) && (o.push(r.value), !t || o.length !== t); n = !0); } catch (e) { i = !0, a = e } finally { try { !n && l.return && l.return() } finally { if (i) throw a } } return o }(e, t); throw new TypeError("Invalid attempt to destructure non-iterable instance") }, t = function () { function n(e, t) { for (var o = 0; o < t.length; o++) { var n = t[o]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, o) { return t && n(e.prototype, t), o && n(e, o), e } }(), p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, o = a(S(2)), n = a(S(14)), i = S(4); function a(e) { return e && e.__esModule ? e : { default: e } } var s = -1 < navigator.userAgent.indexOf("MSIE ") || -1 < navigator.userAgent.indexOf("Trident/") || -1 < navigator.userAgent.indexOf("Edge/"), r = function () { for (var e = "transform WebkitTransform MozTransform".split(" "), t = document.createElement("div"), o = 0; o < e.length; o++)if (t && void 0 !== t.style[e[o]]) return e[o]; return !1 }(), b = void 0, v = void 0, l = void 0, c = !1, u = !1; function m(e) { b = i.window.innerWidth || document.documentElement.clientWidth, v = i.window.innerHeight || document.documentElement.clientHeight, "object" !== (void 0 === e ? "undefined" : p(e)) || "load" !== e.type && "dom-loaded" !== e.type || (c = !0) } m(), i.window.addEventListener("resize", m), i.window.addEventListener("orientationchange", m), i.window.addEventListener("load", m), (0, o.default)(function () { m({ type: "dom-loaded" }) }); var f = [], y = !1; function g() { if (f.length) { l = void 0 !== i.window.pageYOffset ? i.window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop; var t = c || !y || y.width !== b || y.height !== v, o = u || t || !y || y.y !== l; u = c = !1, (t || o) && (f.forEach(function (e) { t && e.onResize(), o && e.onScroll() }), y = { width: b, height: v, y: l }), (0, n.default)(g) } } var h = !!e.ResizeObserver && new e.ResizeObserver(function (e) { e && e.length && (0, n.default)(function () { e.forEach(function (e) { e.target && e.target.jarallax && (c || e.target.jarallax.onResize(), u = !0) }) }) }), x = 0, w = function () { function u(e, t) { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, u); var o = this; o.instanceID = x++, o.$item = e, o.defaults = { type: "scroll", speed: .5, imgSrc: null, imgElement: ".jarallax-img", imgSize: "cover", imgPosition: "50% 50%", imgRepeat: "no-repeat", keepImg: !1, elementInViewport: null, zIndex: -100, disableParallax: !1, disableVideo: !1, automaticResize: !0, videoSrc: null, videoStartTime: 0, videoEndTime: 0, videoVolume: 0, videoPlayOnlyVisible: !0, onScroll: null, onInit: null, onDestroy: null, onCoverImage: null }; var n = o.$item.getAttribute("data-jarallax"), i = JSON.parse(n || "{}"); n && console.warn("Detected usage of deprecated data-jarallax JSON options, you should use pure data-attribute options. See info here - https://github.com/nk-o/jarallax/issues/53"); var a = o.$item.dataset || {}, r = {}; if (Object.keys(a).forEach(function (e) { var t = e.substr(0, 1).toLowerCase() + e.substr(1); t && void 0 !== o.defaults[t] && (r[t] = a[e]) }), o.options = o.extend({}, o.defaults, i, r, t), o.pureOptions = o.extend({}, o.options), Object.keys(o.options).forEach(function (e) { "true" === o.options[e] ? o.options[e] = !0 : "false" === o.options[e] && (o.options[e] = !1) }), o.options.speed = Math.min(2, Math.max(-1, parseFloat(o.options.speed))), (o.options.noAndroid || o.options.noIos) && (console.warn("Detected usage of deprecated noAndroid or noIos options, you should use disableParallax option. See info here - https://github.com/nk-o/jarallax/#disable-on-mobile-devices"), o.options.disableParallax || (o.options.noIos && o.options.noAndroid ? o.options.disableParallax = /iPad|iPhone|iPod|Android/ : o.options.noIos ? o.options.disableParallax = /iPad|iPhone|iPod/ : o.options.noAndroid && (o.options.disableParallax = /Android/))), "string" == typeof o.options.disableParallax && (o.options.disableParallax = new RegExp(o.options.disableParallax)), o.options.disableParallax instanceof RegExp) { var l = o.options.disableParallax; o.options.disableParallax = function () { return l.test(navigator.userAgent) } } if ("function" != typeof o.options.disableParallax && (o.options.disableParallax = function () { return !1 }), "string" == typeof o.options.disableVideo && (o.options.disableVideo = new RegExp(o.options.disableVideo)), o.options.disableVideo instanceof RegExp) { var s = o.options.disableVideo; o.options.disableVideo = function () { return s.test(navigator.userAgent) } } "function" != typeof o.options.disableVideo && (o.options.disableVideo = function () { return !1 }); var c = o.options.elementInViewport; c && "object" === (void 0 === c ? "undefined" : p(c)) && void 0 !== c.length && (c = d(c, 1)[0]); c instanceof Element || (c = null), o.options.elementInViewport = c, o.image = { src: o.options.imgSrc || null, $container: null, useImgTag: !1, position: /iPad|iPhone|iPod|Android/.test(navigator.userAgent) ? "absolute" : "fixed" }, o.initImg() && o.canInitParallax() && o.init() } return t(u, [{ key: "css", value: function (t, o) { return "string" == typeof o ? i.window.getComputedStyle(t).getPropertyValue(o) : (o.transform && r && (o[r] = o.transform), Object.keys(o).forEach(function (e) { t.style[e] = o[e] }), t) } }, { key: "extend", value: function (o) { var n = arguments; return o = o || {}, Object.keys(arguments).forEach(function (t) { n[t] && Object.keys(n[t]).forEach(function (e) { o[e] = n[t][e] }) }), o } }, { key: "getWindowData", value: function () { return { width: b, height: v, y: l } } }, { key: "initImg", value: function () { var e = this, t = e.options.imgElement; return t && "string" == typeof t && (t = e.$item.querySelector(t)), t instanceof Element || (t = null), t && (e.options.keepImg ? e.image.$item = t.cloneNode(!0) : (e.image.$item = t, e.image.$itemParent = t.parentNode), e.image.useImgTag = !0), !!e.image.$item || (null === e.image.src && (e.image.src = e.css(e.$item, "background-image").replace(/^url\(['"]?/g, "").replace(/['"]?\)$/g, "")), !(!e.image.src || "none" === e.image.src)) } }, { key: "canInitParallax", value: function () { return r && !this.options.disableParallax() } }, { key: "init", value: function () { var e = this, t = { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", overflow: "hidden", pointerEvents: "none" }, o = {}; if (!e.options.keepImg) { var n = e.$item.getAttribute("style"); if (n && e.$item.setAttribute("data-jarallax-original-styles", n), e.image.useImgTag) { var i = e.image.$item.getAttribute("style"); i && e.image.$item.setAttribute("data-jarallax-original-styles", i) } } if ("static" === e.css(e.$item, "position") && e.css(e.$item, { position: "relative" }), "auto" === e.css(e.$item, "z-index") && e.css(e.$item, { zIndex: 0 }), e.image.$container = document.createElement("div"), e.css(e.image.$container, t), e.css(e.image.$container, { "z-index": e.options.zIndex }), s && e.css(e.image.$container, { opacity: .9999 }), e.image.$container.setAttribute("id", "jarallax-container-" + e.instanceID), e.$item.appendChild(e.image.$container), e.image.useImgTag ? o = e.extend({ "object-fit": e.options.imgSize, "object-position": e.options.imgPosition, "font-family": "object-fit: " + e.options.imgSize + "; object-position: " + e.options.imgPosition + ";", "max-width": "none" }, t, o) : (e.image.$item = document.createElement("div"), e.image.src && (o = e.extend({ "background-position": e.options.imgPosition, "background-size": e.options.imgSize, "background-repeat": e.options.imgRepeat, "background-image": 'url("' + e.image.src + '")' }, t, o))), "opacity" !== e.options.type && "scale" !== e.options.type && "scale-opacity" !== e.options.type && 1 !== e.options.speed || (e.image.position = "absolute"), "fixed" === e.image.position) for (var a = 0, r = e.$item; null !== r && r !== document && 0 === a;) { var l = e.css(r, "-webkit-transform") || e.css(r, "-moz-transform") || e.css(r, "transform"); l && "none" !== l && (a = 1, e.image.position = "absolute"), r = r.parentNode } o.position = e.image.position, e.css(e.image.$item, o), e.image.$container.appendChild(e.image.$item), e.onResize(), e.onScroll(!0), e.options.automaticResize && h && h.observe(e.$item), e.options.onInit && e.options.onInit.call(e), "none" !== e.css(e.$item, "background-image") && e.css(e.$item, { "background-image": "none" }), e.addToParallaxList() } }, { key: "addToParallaxList", value: function () { f.push(this), 1 === f.length && g() } }, { key: "removeFromParallaxList", value: function () { var o = this; f.forEach(function (e, t) { e.instanceID === o.instanceID && f.splice(t, 1) }) } }, { key: "destroy", value: function () { var e = this; e.removeFromParallaxList(); var t = e.$item.getAttribute("data-jarallax-original-styles"); if (e.$item.removeAttribute("data-jarallax-original-styles"), t ? e.$item.setAttribute("style", t) : e.$item.removeAttribute("style"), e.image.useImgTag) { var o = e.image.$item.getAttribute("data-jarallax-original-styles"); e.image.$item.removeAttribute("data-jarallax-original-styles"), o ? e.image.$item.setAttribute("style", t) : e.image.$item.removeAttribute("style"), e.image.$itemParent && e.image.$itemParent.appendChild(e.image.$item) } e.$clipStyles && e.$clipStyles.parentNode.removeChild(e.$clipStyles), e.image.$container && e.image.$container.parentNode.removeChild(e.image.$container), e.options.onDestroy && e.options.onDestroy.call(e), delete e.$item.jarallax } }, { key: "clipContainer", value: function () { if ("fixed" === this.image.position) { var e = this, t = e.image.$container.getBoundingClientRect(), o = t.width, n = t.height; if (!e.$clipStyles) e.$clipStyles = document.createElement("style"), e.$clipStyles.setAttribute("type", "text/css"), e.$clipStyles.setAttribute("id", "jarallax-clip-" + e.instanceID), (document.head || document.getElementsByTagName("head")[0]).appendChild(e.$clipStyles); var i = "#jarallax-container-" + e.instanceID + " {\n           clip: rect(0 " + o + "px " + n + "px 0);\n           clip: rect(0, " + o + "px, " + n + "px, 0);\n        }"; e.$clipStyles.styleSheet ? e.$clipStyles.styleSheet.cssText = i : e.$clipStyles.innerHTML = i } } }, { key: "coverImage", value: function () { var e = this, t = e.image.$container.getBoundingClientRect(), o = t.height, n = e.options.speed, i = "scroll" === e.options.type || "scroll-opacity" === e.options.type, a = 0, r = o, l = 0; return i && (a = n < 0 ? n * Math.max(o, v) : n * (o + v), 1 < n ? r = Math.abs(a - v) : n < 0 ? r = a / n + Math.abs(a) : r += Math.abs(v - o) * (1 - n), a /= 2), e.parallaxScrollDistance = a, l = i ? (v - r) / 2 : (o - r) / 2, e.css(e.image.$item, { height: r + "px", marginTop: l + "px", left: "fixed" === e.image.position ? t.left + "px" : "0", width: t.width + "px" }), e.options.onCoverImage && e.options.onCoverImage.call(e), { image: { height: r, marginTop: l }, container: t } } }, { key: "isVisible", value: function () { return this.isElementInViewport || !1 } }, { key: "onScroll", value: function (e) { var t = this, o = t.$item.getBoundingClientRect(), n = o.top, i = o.height, a = {}, r = o; if (t.options.elementInViewport && (r = t.options.elementInViewport.getBoundingClientRect()), t.isElementInViewport = 0 <= r.bottom && 0 <= r.right && r.top <= v && r.left <= b, e || t.isElementInViewport) { var l = Math.max(0, n), s = Math.max(0, i + n), c = Math.max(0, -n), u = Math.max(0, n + i - v), d = Math.max(0, i - (n + i - v)), p = Math.max(0, -n + v - i), m = 1 - 2 * (v - n) / (v + i), f = 1; if (i < v ? f = 1 - (c || u) / i : s <= v ? f = s / v : d <= v && (f = d / v), "opacity" !== t.options.type && "scale-opacity" !== t.options.type && "scroll-opacity" !== t.options.type || (a.transform = "translate3d(0,0,0)", a.opacity = f), "scale" === t.options.type || "scale-opacity" === t.options.type) { var y = 1; t.options.speed < 0 ? y -= t.options.speed * f : y += t.options.speed * (1 - f), a.transform = "scale(" + y + ") translate3d(0,0,0)" } if ("scroll" === t.options.type || "scroll-opacity" === t.options.type) { var g = t.parallaxScrollDistance * m; "absolute" === t.image.position && (g -= n), a.transform = "translate3d(0," + g + "px,0)" } t.css(t.image.$item, a), t.options.onScroll && t.options.onScroll.call(t, { section: o, beforeTop: l, beforeTopEnd: s, afterTop: c, beforeBottom: u, beforeBottomEnd: d, afterBottom: p, visiblePercent: f, fromViewportCenter: m }) } } }, { key: "onResize", value: function () { this.coverImage(), this.clipContainer() } }]), u }(), $ = function (e) { ("object" === ("undefined" == typeof HTMLElement ? "undefined" : p(HTMLElement)) ? e instanceof HTMLElement : e && "object" === (void 0 === e ? "undefined" : p(e)) && null !== e && 1 === e.nodeType && "string" == typeof e.nodeName) && (e = [e]); for (var t = arguments[1], o = Array.prototype.slice.call(arguments, 2), n = e.length, i = 0, a = void 0; i < n; i++)if ("object" === (void 0 === t ? "undefined" : p(t)) || void 0 === t ? e[i].jarallax || (e[i].jarallax = new w(e[i], t)) : e[i].jarallax && (a = e[i].jarallax[t].apply(e[i].jarallax, o)), void 0 !== a) return a; return e }; $.constructor = w, j.default = $ }).call(this, S(5)) }, function (e, t, o) { "use strict"; var n = o(4), i = n.requestAnimationFrame || n.webkitRequestAnimationFrame || n.mozRequestAnimationFrame || function (e) { var t = +new Date, o = Math.max(0, 16 - (t - a)), n = setTimeout(e, o); return a = t, n }, a = +new Date; var r = n.cancelAnimationFrame || n.webkitCancelAnimationFrame || n.mozCancelAnimationFrame || clearTimeout; Function.prototype.bind && (i = i.bind(n), r = r.bind(n)), (e.exports = i).cancel = r }]);/*!
* Name : Video Background Extension for Jarallax
* Version : 1.0.1
* Author : nK <https://nkdev.info>
* GitHub : https://github.com/nk-o/jarallax
*/!function (o) { var i = {}; function n(e) { if (i[e]) return i[e].exports; var t = i[e] = { i: e, l: !1, exports: {} }; return o[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports } n.m = o, n.c = i, n.d = function (e, t, o) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: o }) }, n.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var o = Object.create(null); if (n.r(o), Object.defineProperty(o, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) n.d(o, i, function (e) { return t[e] }.bind(null, i)); return o }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 6) }([, , function (e, t, o) { "use strict"; e.exports = function (e) { "complete" === document.readyState || "interactive" === document.readyState ? e.call() : document.attachEvent ? document.attachEvent("onreadystatechange", function () { "interactive" === document.readyState && e.call() }) : document.addEventListener && document.addEventListener("DOMContentLoaded", e) } }, , function (o, e, t) { "use strict"; (function (e) { var t; t = "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}, o.exports = t }).call(this, t(5)) }, function (e, t, o) { "use strict"; var i, n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; i = function () { return this }(); try { i = i || Function("return this")() || (0, eval)("this") } catch (e) { "object" === ("undefined" == typeof window ? "undefined" : n(window)) && (i = window) } e.exports = i }, function (e, t, o) { e.exports = o(7) }, function (e, t, o) { "use strict"; var i = l(o(8)), n = l(o(4)), a = l(o(2)), r = l(o(10)); function l(e) { return e && e.__esModule ? e : { default: e } } n.default.VideoWorker = n.default.VideoWorker || i.default, (0, r.default)(), (0, a.default)(function () { "undefined" != typeof jarallax && jarallax(document.querySelectorAll("[data-jarallax-video]")) }) }, function (e, t, o) { "use strict"; e.exports = o(9) }, function (e, t, o) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, a = function () { function i(e, t) { for (var o = 0; o < t.length; o++) { var i = t[o]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } return function (e, t, o) { return t && i(e.prototype, t), o && i(e, o), e } }(); function i() { this._done = [], this._fail = [] } i.prototype = { execute: function (e, t) { var o = e.length; for (t = Array.prototype.slice.call(t); o--;)e[o].apply(null, t) }, resolve: function () { this.execute(this._done, arguments) }, reject: function () { this.execute(this._fail, arguments) }, done: function (e) { this._done.push(e) }, fail: function (e) { this._fail.push(e) } }; var r = 0, l = 0, u = 0, p = 0, s = 0, d = new i, y = new i, c = function () { function i(e, t) { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, i); var o = this; o.url = e, o.options_default = { autoplay: !1, loop: !1, mute: !1, volume: 100, showContols: !0, startTime: 0, endTime: 0 }, o.options = o.extend({}, o.options_default, t), o.videoID = o.parseURL(e), o.videoID && (o.ID = r++, o.loadAPI(), o.init()) } return a(i, [{ key: "extend", value: function (o) { var i = arguments; return o = o || {}, Object.keys(arguments).forEach(function (t) { i[t] && Object.keys(i[t]).forEach(function (e) { o[e] = i[t][e] }) }), o } }, { key: "parseURL", value: function (e) { var t, o, i, n, a, r = !(!(t = e.match(/.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*/)) || 11 !== t[1].length) && t[1], l = !(!(o = e.match(/https?:\/\/(?:www\.|player\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|album\/(\d+)\/video\/|video\/|)(\d+)(?:$|\/|\?)/)) || !o[3]) && o[3], u = (i = e.split(/,(?=mp4\:|webm\:|ogv\:|ogg\:)/), n = {}, a = 0, i.forEach(function (e) { var t = e.match(/^(mp4|webm|ogv|ogg)\:(.*)/); t && t[1] && t[2] && (n["ogv" === t[1] ? "ogg" : t[1]] = t[2], a = 1) }), !!a && n); return r ? (this.type = "youtube", r) : l ? (this.type = "vimeo", l) : !!u && (this.type = "local", u) } }, { key: "isValid", value: function () { return !!this.videoID } }, { key: "on", value: function (e, t) { this.userEventsList = this.userEventsList || [], (this.userEventsList[e] || (this.userEventsList[e] = [])).push(t) } }, { key: "off", value: function (o, i) { var n = this; this.userEventsList && this.userEventsList[o] && (i ? this.userEventsList[o].forEach(function (e, t) { e === i && (n.userEventsList[o][t] = !1) }) : delete this.userEventsList[o]) } }, { key: "fire", value: function (e) { var t = this, o = [].slice.call(arguments, 1); this.userEventsList && void 0 !== this.userEventsList[e] && this.userEventsList[e].forEach(function (e) { e && e.apply(t, o) }) } }, { key: "play", value: function (e) { var t = this; t.player && ("youtube" === t.type && t.player.playVideo && (void 0 !== e && t.player.seekTo(e || 0), YT.PlayerState.PLAYING !== t.player.getPlayerState() && t.player.playVideo()), "vimeo" === t.type && (void 0 !== e && t.player.setCurrentTime(e), t.player.getPaused().then(function (e) { e && t.player.play() })), "local" === t.type && (void 0 !== e && (t.player.currentTime = e), t.player.paused && t.player.play())) } }, { key: "pause", value: function () { var t = this; t.player && ("youtube" === t.type && t.player.pauseVideo && YT.PlayerState.PLAYING === t.player.getPlayerState() && t.player.pauseVideo(), "vimeo" === t.type && t.player.getPaused().then(function (e) { e || t.player.pause() }), "local" === t.type && (t.player.paused || t.player.pause())) } }, { key: "mute", value: function () { var e = this; e.player && ("youtube" === e.type && e.player.mute && e.player.mute(), "vimeo" === e.type && e.player.setVolume && e.player.setVolume(0), "local" === e.type && (e.$video.muted = !0)) } }, { key: "unmute", value: function () { var e = this; e.player && ("youtube" === e.type && e.player.mute && e.player.unMute(), "vimeo" === e.type && e.player.setVolume && e.player.setVolume(e.options.volume), "local" === e.type && (e.$video.muted = !1)) } }, { key: "setVolume", value: function () { var e = 0 < arguments.length && void 0 !== arguments[0] && arguments[0], t = this; t.player && e && ("youtube" === t.type && t.player.setVolume && t.player.setVolume(e), "vimeo" === t.type && t.player.setVolume && t.player.setVolume(e), "local" === t.type && (t.$video.volume = e / 100)) } }, { key: "getVolume", value: function (t) { var e = this; e.player ? ("youtube" === e.type && e.player.getVolume && t(e.player.getVolume()), "vimeo" === e.type && e.player.getVolume && e.player.getVolume().then(function (e) { t(e) }), "local" === e.type && t(100 * e.$video.volume)) : t(!1) } }, { key: "getMuted", value: function (t) { var e = this; e.player ? ("youtube" === e.type && e.player.isMuted && t(e.player.isMuted()), "vimeo" === e.type && e.player.getVolume && e.player.getVolume().then(function (e) { t(!!e) }), "local" === e.type && t(e.$video.muted)) : t(null) } }, { key: "getImageURL", value: function (t) { var o = this; if (o.videoImage) t(o.videoImage); else { if ("youtube" === o.type) { var e = ["maxresdefault", "sddefault", "hqdefault", "0"], i = 0, n = new Image; n.onload = function () { 120 !== (this.naturalWidth || this.width) || i === e.length - 1 ? (o.videoImage = "https://img.youtube.com/vi/" + o.videoID + "/" + e[i] + ".jpg", t(o.videoImage)) : (i++, this.src = "https://img.youtube.com/vi/" + o.videoID + "/" + e[i] + ".jpg") }, n.src = "https://img.youtube.com/vi/" + o.videoID + "/" + e[i] + ".jpg" } if ("vimeo" === o.type) { var a = new XMLHttpRequest; a.open("GET", "https://vimeo.com/api/v2/video/" + o.videoID + ".json", !0), a.onreadystatechange = function () { if (4 === this.readyState && 200 <= this.status && this.status < 400) { var e = JSON.parse(this.responseText); o.videoImage = e[0].thumbnail_large, t(o.videoImage) } }, a.send(), a = null } } } }, { key: "getIframe", value: function (e) { this.getVideo(e) } }, { key: "getVideo", value: function (u) { var p = this; p.$video ? u(p.$video) : p.onAPIready(function () { var e = void 0; if (p.$video || ((e = document.createElement("div")).style.display = "none"), "youtube" === p.type) { p.playerOptions = {}, p.playerOptions.videoId = p.videoID, p.playerOptions.playerVars = { autohide: 1, rel: 0, autoplay: 0, playsinline: 1 }, p.options.showContols || (p.playerOptions.playerVars.iv_load_policy = 3, p.playerOptions.playerVars.modestbranding = 1, p.playerOptions.playerVars.controls = 0, p.playerOptions.playerVars.showinfo = 0, p.playerOptions.playerVars.disablekb = 1); var t = void 0, o = void 0; p.playerOptions.events = { onReady: function (t) { p.options.mute ? t.target.mute() : p.options.volume && t.target.setVolume(p.options.volume), p.options.autoplay && p.play(p.options.startTime), p.fire("ready", t), setInterval(function () { p.getVolume(function (e) { p.options.volume !== e && (p.options.volume = e, p.fire("volumechange", t)) }) }, 150) }, onStateChange: function (e) { p.options.loop && e.data === YT.PlayerState.ENDED && p.play(p.options.startTime), t || e.data !== YT.PlayerState.PLAYING || (t = 1, p.fire("started", e)), e.data === YT.PlayerState.PLAYING && p.fire("play", e), e.data === YT.PlayerState.PAUSED && p.fire("pause", e), e.data === YT.PlayerState.ENDED && p.fire("ended", e), e.data === YT.PlayerState.PLAYING ? o = setInterval(function () { p.fire("timeupdate", e), p.options.endTime && p.player.getCurrentTime() >= p.options.endTime && (p.options.loop ? p.play(p.options.startTime) : p.pause()) }, 150) : clearInterval(o) } }; var i = !p.$video; if (i) { var n = document.createElement("div"); n.setAttribute("id", p.playerID), e.appendChild(n), document.body.appendChild(e) } p.player = p.player || new window.YT.Player(p.playerID, p.playerOptions), i && (p.$video = document.getElementById(p.playerID), p.videoWidth = parseInt(p.$video.getAttribute("width"), 10) || 1280, p.videoHeight = parseInt(p.$video.getAttribute("height"), 10) || 720) } if ("vimeo" === p.type) { if (p.playerOptions = { id: p.videoID, autopause: 0, transparent: 0, autoplay: p.options.autoplay ? 1 : 0, loop: p.options.loop ? 1 : 0, muted: p.options.mute ? 1 : 0 }, p.options.volume && (p.playerOptions.volume = p.options.volume), p.options.showContols || (p.playerOptions.badge = 0, p.playerOptions.byline = 0, p.playerOptions.portrait = 0, p.playerOptions.title = 0), !p.$video) { var a = ""; Object.keys(p.playerOptions).forEach(function (e) { "" !== a && (a += "&"), a += e + "=" + encodeURIComponent(p.playerOptions[e]) }), p.$video = document.createElement("iframe"), p.$video.setAttribute("id", p.playerID), p.$video.setAttribute("src", "https://player.vimeo.com/video/" + p.videoID + "?" + a), p.$video.setAttribute("frameborder", "0"), p.$video.setAttribute("mozallowfullscreen", ""), p.$video.setAttribute("allowfullscreen", ""), e.appendChild(p.$video), document.body.appendChild(e) } p.player = p.player || new Vimeo.Player(p.$video, p.playerOptions), p.options.startTime && p.options.autoplay && p.player.setCurrentTime(p.options.startTime), p.player.getVideoWidth().then(function (e) { p.videoWidth = e || 1280 }), p.player.getVideoHeight().then(function (e) { p.videoHeight = e || 720 }); var r = void 0; p.player.on("timeupdate", function (e) { r || (p.fire("started", e), r = 1), p.fire("timeupdate", e), p.options.endTime && p.options.endTime && e.seconds >= p.options.endTime && (p.options.loop ? p.play(p.options.startTime) : p.pause()) }), p.player.on("play", function (e) { p.fire("play", e), p.options.startTime && 0 === e.seconds && p.play(p.options.startTime) }), p.player.on("pause", function (e) { p.fire("pause", e) }), p.player.on("ended", function (e) { p.fire("ended", e) }), p.player.on("loaded", function (e) { p.fire("ready", e) }), p.player.on("volumechange", function (e) { p.fire("volumechange", e) }) } if ("local" === p.type) { p.$video || (p.$video = document.createElement("video"), p.options.showContols && (p.$video.controls = !0), p.options.mute ? p.$video.muted = !0 : p.$video.volume && (p.$video.volume = p.options.volume / 100), p.options.loop && (p.$video.loop = !0), p.$video.setAttribute("playsinline", ""), p.$video.setAttribute("webkit-playsinline", ""), p.$video.setAttribute("id", p.playerID), e.appendChild(p.$video), document.body.appendChild(e), Object.keys(p.videoID).forEach(function (e) { var t, o, i, n; t = p.$video, o = p.videoID[e], i = "video/" + e, (n = document.createElement("source")).src = o, n.type = i, t.appendChild(n) })), p.player = p.player || p.$video; var l = void 0; p.player.addEventListener("playing", function (e) { l || p.fire("started", e), l = 1 }), p.player.addEventListener("timeupdate", function (e) { p.fire("timeupdate", e), p.options.endTime && p.options.endTime && this.currentTime >= p.options.endTime && (p.options.loop ? p.play(p.options.startTime) : p.pause()) }), p.player.addEventListener("play", function (e) { p.fire("play", e) }), p.player.addEventListener("pause", function (e) { p.fire("pause", e) }), p.player.addEventListener("ended", function (e) { p.fire("ended", e) }), p.player.addEventListener("loadedmetadata", function () { p.videoWidth = this.videoWidth || 1280, p.videoHeight = this.videoHeight || 720, p.fire("ready"), p.options.autoplay && p.play(p.options.startTime) }), p.player.addEventListener("volumechange", function (e) { p.getVolume(function (e) { p.options.volume = e }), p.fire("volumechange", e) }) } u(p.$video) }) } }, { key: "init", value: function () { this.playerID = "VideoWorker-" + this.ID } }, { key: "loadAPI", value: function () { if (!l || !u) { var e = ""; if ("youtube" !== this.type || l || (l = 1, e = "https://www.youtube.com/iframe_api"), "vimeo" !== this.type || u || (u = 1, e = "https://player.vimeo.com/api/player.js"), e) { var t = document.createElement("script"), o = document.getElementsByTagName("head")[0]; t.src = e, o.appendChild(t), t = o = null } } } }, { key: "onAPIready", value: function (e) { if ("youtube" === this.type && ("undefined" != typeof YT && 0 !== YT.loaded || p ? "object" === ("undefined" == typeof YT ? "undefined" : n(YT)) && 1 === YT.loaded ? e() : d.done(function () { e() }) : (p = 1, window.onYouTubeIframeAPIReady = function () { window.onYouTubeIframeAPIReady = null, d.resolve("done"), e() })), "vimeo" === this.type) if ("undefined" != typeof Vimeo || s) "undefined" != typeof Vimeo ? e() : y.done(function () { e() }); else { s = 1; var t = setInterval(function () { "undefined" != typeof Vimeo && (clearInterval(t), y.resolve("done"), e()) }, 20) } "local" === this.type && e() } }]), i }(); t.default = c }, function (e, t, o) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function () { var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : u.default.jarallax; if (void 0 === e) return; var t = e.constructor, i = t.prototype.init; t.prototype.init = function () { var o = this; i.apply(o), o.video && !o.options.disableVideo() && o.video.getVideo(function (e) { var t = e.parentNode; o.css(e, { position: o.image.position, top: "0px", left: "0px", right: "0px", bottom: "0px", width: "100%", height: "100%", maxWidth: "none", maxHeight: "none", margin: 0, zIndex: -1 }), o.$video = e, o.image.$container.appendChild(e), t.parentNode.removeChild(t) }) }; var l = t.prototype.coverImage; t.prototype.coverImage = function () { var e = this, t = l.apply(e), o = !!e.image.$item && e.image.$item.nodeName; if (t && e.video && o && ("IFRAME" === o || "VIDEO" === o)) { var i = t.image.height, n = i * e.image.width / e.image.height, a = (t.container.width - n) / 2, r = t.image.marginTop; t.container.width > n && (n = t.container.width, i = n * e.image.height / e.image.width, a = 0, r += (t.image.height - i) / 2), "IFRAME" === o && (i += 400, r -= 200), e.css(e.$video, { width: n + "px", marginLeft: a + "px", height: i + "px", marginTop: r + "px" }) } return t }; var o = t.prototype.initImg; t.prototype.initImg = function () { var e = this, t = o.apply(e); return e.options.videoSrc || (e.options.videoSrc = e.$item.getAttribute("data-jarallax-video") || null), e.options.videoSrc ? (e.defaultInitImgResult = t, !0) : t }; var n = t.prototype.canInitParallax; t.prototype.canInitParallax = function () { var o = this, e = n.apply(o); if (!o.options.videoSrc) return e; var t = new r.default(o.options.videoSrc, { autoplay: !0, loop: !0, showContols: !1, startTime: o.options.videoStartTime || 0, endTime: o.options.videoEndTime || 0, mute: o.options.videoVolume ? 0 : 1, volume: o.options.videoVolume || 0 }); if (t.isValid()) if (e) { if (t.on("ready", function () { if (o.options.videoPlayOnlyVisible) { var e = o.onScroll; o.onScroll = function () { e.apply(o), o.isVisible() ? t.play() : t.pause() } } else t.play() }), t.on("started", function () { o.image.$default_item = o.image.$item, o.image.$item = o.$video, o.image.width = o.video.videoWidth || 1280, o.image.height = o.video.videoHeight || 720, o.options.imgWidth = o.image.width, o.options.imgHeight = o.image.height, o.coverImage(), o.clipContainer(), o.onScroll(), o.image.$default_item && (o.image.$default_item.style.display = "none") }), o.video = t, !o.defaultInitImgResult) return "local" !== t.type ? (t.getImageURL(function (e) { o.image.src = e, o.init() }), !1) : (o.image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", !0) } else o.defaultInitImgResult || t.getImageURL(function (e) { var t = o.$item.getAttribute("style"); t && o.$item.setAttribute("data-jarallax-original-styles", t), o.css(o.$item, { "background-image": 'url("' + e + '")', "background-position": "center", "background-size": "cover" }) }); return e }; var a = t.prototype.destroy; t.prototype.destroy = function () { var e = this; e.image.$default_item && (e.image.$item = e.image.$default_item, delete e.image.$default_item), a.apply(e) } }; var r = i(o(8)), u = i(o(4)); function i(e) { return e && e.__esModule ? e : { default: e } } }]);/*!
* Name : Elements Extension for Jarallax
* Version : 1.0.0
* Author : nK <https://nkdev.info>
* GitHub : https://github.com/nk-o/jarallax
*/!function (n) { var o = {}; function r(t) { if (o[t]) return o[t].exports; var e = o[t] = { i: t, l: !1, exports: {} }; return n[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports } r.m = n, r.c = o, r.d = function (t, e, n) { r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }) }, r.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, r.t = function (e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) r.d(n, o, function (t) { return e[t] }.bind(null, o)); return n }, r.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, "a", e), e }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r.p = "", r(r.s = 0) }([function (t, e, n) { t.exports = n(1) }, function (t, e, n) { "use strict"; var o = r(n(2)); function r(t) { return t && t.__esModule ? t : { default: t } } (0, r(n(3)).default)(), (0, o.default)(function () { "undefined" != typeof jarallax && jarallax(document.querySelectorAll("[data-jarallax-element]")) }) }, function (t, e, n) { "use strict"; t.exports = function (t) { "complete" === document.readyState || "interactive" === document.readyState ? t.call() : document.attachEvent ? document.attachEvent("onreadystatechange", function () { "interactive" === document.readyState && t.call() }) : document.addEventListener && document.addEventListener("DOMContentLoaded", t) } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : i.default.jarallax; if (void 0 === t) return; var e = t.constructor;["initImg", "canInitParallax", "init", "destroy", "clipContainer", "coverImage", "isVisible", "onScroll", "onResize"].forEach(function (p) { var f = e.prototype[p]; e.prototype[p] = function () { var t = this, e = arguments || []; if ("initImg" === p && null !== t.$item.getAttribute("data-jarallax-element") && (t.options.type = "element", t.pureOptions.speed = t.$item.getAttribute("data-jarallax-element") || t.pureOptions.speed), "element" !== t.options.type) return f.apply(t, e); switch (t.pureOptions.threshold = t.$item.getAttribute("data-threshold") || "", p) { case "init": var n = t.pureOptions.speed.split(" "); t.options.speed = t.pureOptions.speed || 0, t.options.speedY = n[0] ? parseFloat(n[0]) : 0, t.options.speedX = n[1] ? parseFloat(n[1]) : 0; var o = t.pureOptions.threshold.split(" "); t.options.thresholdY = o[0] ? parseFloat(o[0]) : null, t.options.thresholdX = o[1] ? parseFloat(o[1]) : null; break; case "onResize": var r = t.css(t.$item, "transform"); t.css(t.$item, { transform: "" }); var i = t.$item.getBoundingClientRect(); t.itemData = { width: i.width, height: i.height, y: i.top + t.getWindowData().y, x: i.left }, t.css(t.$item, { transform: r }); break; case "onScroll": var a = t.getWindowData(), s = (a.y + a.height / 2 - t.itemData.y - t.itemData.height / 2) / (a.height / 2), l = s * t.options.speedY, u = s * t.options.speedX, c = l, d = u; null !== t.options.thresholdY && l > t.options.thresholdY && (c = 0), null !== t.options.thresholdX && u > t.options.thresholdX && (d = 0), t.css(t.$item, { transform: "translate3d(" + d + "px," + c + "px,0)" }); break; case "initImg": case "isVisible": case "clipContainer": case "coverImage": return !0 }return f.apply(t, e) } }) }; var o, r = n(4), i = (o = r) && o.__esModule ? o : { default: o } }, function (n, t, e) { "use strict"; (function (t) { var e; e = "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {}, n.exports = e }).call(this, e(5)) }, function (t, e, n) { "use strict"; var o, r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }; o = function () { return this }(); try { o = o || Function("return this")() || (0, eval)("this") } catch (t) { "object" === ("undefined" == typeof window ? "undefined" : r(window)) && (o = window) } t.exports = o }]);;/*!
* FitVids 1.1
*
* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com
* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/
* Released under the WTFPL license - http://sam.zoy.org/wtfpl/
*
*/; (function ($) {
    'use strict'; $.fn.fitVids = function (options) {
        var settings = { customSelector: null, ignore: null }; if (!document.getElementById('fit-vids-style')) { var head = document.head || document.getElementsByTagName('head')[0]; var css = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}'; var div = document.createElement("div"); div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + '</style>'; head.appendChild(div.childNodes[1]) }
        if (options) { $.extend(settings, options) }
        return this.each(function () {
            var selectors = ['iframe[src*="player.vimeo.com"]', 'iframe[src*="youtube.com"]', 'iframe[src*="youtube-nocookie.com"]', 'iframe[src*="kickstarter.com"][src*="video.html"]', 'object', 'embed']; if (settings.customSelector) { selectors.push(settings.customSelector) }
            var ignoreList = '.fitvidsignore'; if (settings.ignore) { ignoreList = ignoreList + ', ' + settings.ignore }
            var $allVideos = $(this).find(selectors.join(',')); $allVideos = $allVideos.not('object object'); $allVideos = $allVideos.not(ignoreList); $allVideos.each(function () {
                var $this = $(this); if ($this.parents(ignoreList).length > 0) { return }
                if (this.tagName.toLowerCase() === 'embed' && $this.parent('object').length || $this.parent('.fluid-width-video-wrapper').length) { return }
                if ((!$this.css('height') && !$this.css('width')) && (isNaN($this.attr('height')) || isNaN($this.attr('width')))) { $this.attr('height', 9); $this.attr('width', 16) }
                var height = (this.tagName.toLowerCase() === 'object' || ($this.attr('height') && !isNaN(parseInt($this.attr('height'), 10)))) ? parseInt($this.attr('height'), 10) : $this.height(), width = !isNaN(parseInt($this.attr('width'), 10)) ? parseInt($this.attr('width'), 10) : $this.width(), aspectRatio = height / width; if (!$this.attr('name')) { var videoName = 'fitvid' + $.fn.fitVids._count; $this.attr('name', videoName); $.fn.fitVids._count++ }
                $this.wrap('<div class="fluid-width-video-wrapper"></div>').parent('.fluid-width-video-wrapper').css('padding-top', (aspectRatio * 100) + '%'); $this.removeAttr('height').removeAttr('width')
            })
        })
    }; $.fn.fitVids._count = 0
})(window.jQuery || window.Zepto); (function ($, win) { "use strict"; const requestFrame = function () { const raf = win.requestAnimationFrame || win.mozRequestAnimationFrame || win.webkitRequestAnimationFrame || function (fn) { return win.setTimeout(fn, 20) }; return function (fn) { return raf(fn) } }(); const style = (win.document.body || win.document.documentElement).style; const prop = "transition"; const supportsTransition = typeof style[prop] == "string"; const events = { created: "sticky-created", update: "sticky-update", top: "sticky-hit-top", bottom: "sticky-hit-bottom", frozen: "sticky-frozen", unfrozen: "sticky-unfrozen" }; function Sticky(elm, par, options) { this.element = elm; this.parent = par; this._frozen = false; this._stopped = true; this.options = $.extend({ useTransition: true, animate: true, animTime: 200, animDelay: 300 }, options); const offset = parseInt(options.offset, 10); this.options.offset = isNaN(offset) ? 0 : offset; this.init() } Sticky.prototype.init = function () { let transition = ""; if (this.options.useTransition && supportsTransition) { transition = `top ${this.options.animTime}ms ease-in-out`; this.options.animate = false } this.parent.css({ position: "relative" }); this.element.addClass("sticky-scroll").css({ transition: transition, position: "relative" }); this.element.trigger(events.created); this.update() }; Sticky.prototype.update = function () { this.setBoundaries(0); this.moveIt(); this.element.trigger(events.update) }; Sticky.prototype.moveIt = function () { const scrollTop = (win.document.documentElement.scrollTop || win.document.body.scrollTop) + this.options.offset; const height = this.element.outerHeight(true); const realStop = this._stop - height; if (this._parentHeight - this._offset > height && !this._frozen) { if (scrollTop >= this._start && scrollTop <= realStop) { this.updateOffset(scrollTop - this._start); this._stopped = false } else { if (scrollTop < this._start) { this.updateOffset(0); if (!this._stopped) { this.element.trigger(events.top) } this._stopped = true } else if (scrollTop > realStop) { this.updateOffset(this._parentHeight - height - this._offset); if (!this._stopped) { this.element.trigger(events.bottom) } this._stopped = true } } } }; Sticky.prototype.setBoundaries = function (offset) { this._offset = typeof offset === "undefined" ? this.element.position().top : offset; this._start = this.parent.offset().top + this._offset; this._parentHeight = this.parent[0].offsetHeight; this._stop = this._start + this._parentHeight - this._offset }; Sticky.prototype.setOffset = function (newOffset) { newOffset = parseInt(newOffset, 10); if (!isNaN(newOffset)) { this.options.offset = newOffset; this.moveIt() } }; Sticky.prototype.updateOffset = function (yOffset) { if (this._lastPosition !== yOffset) { if (this.options.animate) { this.element.stop(true, false).delay(this.options.animDelay).animate({ top: yOffset }, this.animTime) } else { this.element.css("top", yOffset) } this._lastPosition = yOffset } }; Sticky.prototype.toggleFreeze = function () { this._frozen = !this._frozen; this.element.stop(true, false); if (!this._frozen) { this.element.trigger(events.unfrozen); this.moveIt() } else { this.element.trigger(events.frozen) } }; $.fn.sticky = function (parentName, options) { const method = parentName; let ret = false; this.each(function () { const self = $(this); let instance = self.data("stickyInstance"); if (instance && (options || method)) { if (typeof options === "object") { ret = $.extend(instance.options, options) } else if (options === "options") { ret = instance.options } else if (typeof instance[method] === "function") { ret = instance[method](options) } else { console.error(`Sticky Element has no option/method named ${method}`) } } else { let parent = null; if (parent) { parent = self.parent().closest(parent) } else { parent = self.parent() } instance = new Sticky(self, parent, options || {}); self.data("stickyInstance", instance); $.fn.sticky._instances.push(instance) } }); return ret || this }; function updateAll() { const len = $.fn.sticky._instances.length; for (let i = 0; i < len; i++) { $.fn.sticky._instances[i].update() } } $.fn.sticky._instances = []; $.fn.sticky.updateAll = updateAll; $(win).on({ resize() { updateAll() }, scroll() { const len = $.fn.sticky._instances.length; for (let i = 0; i < len; i++) { const element = $.fn.sticky._instances[i]; if (!element._frozen) { element.moveIt() } } } }); $(win.document).on({ ready() { win.setInterval(function () { requestFrame(function () { const len = $.fn.sticky._instances.length; for (let i = 0; i < len; i++) { const element = $.fn.sticky._instances[i]; if (element._parentHeight !== element.parent[0].offsetHeight) { element.update() } } }) }, 1e3) } }) })(jQuery, window);; (function ($) {
    "use strict"; jQuery(document).ready(function ($) {
        var sidebar_s = $(".c-sidebar-1.sidebar-sticky"); var stckyoffset = $(".c-sidebar-1.sidebar-sticky").attr('data-stcky-offset'); var stckyanimate = $(".c-sidebar-1.sidebar-sticky").attr('data-stcky-animate'); var stckyanimate = (stckyanimate == 'false') ? !1 : !0; var stckyanimatetime = $(".c-sidebar-1.sidebar-sticky").attr('data-stcky-animate-time'); if (sidebar_s.size() > 0) { sidebar_s.sticky('#widget-area', { useTransition: !1, animate: stckyanimate, animTime: parseInt(stckyanimatetime), offset: parseInt(stckyoffset), }) }
        jQuery(window).load(function () { $('.preloader').fadeOut('slow', function () { }) }); jQuery('.flexslider').flexslider({ controlNav: !0 }); jQuery(".video-responsive").fitVids(); jQuery(".single-inner-content table, .cryptoland-post-class table").addClass("table table-striped")
    })
})(jQuery); responsiveEl(); function responsiveEl() {
    var matches = document.querySelectorAll("[data-res-css]"); var resdata = []; matches.forEach(function (element) { var get_style = element.getAttribute("data-res-css"); resdata.push(get_style); element.removeAttribute("data-res-css") }); var css = resdata.join(""), head = document.head || document.getElementsByTagName('head')[0], style = document.createElement('style'); style.type = 'text/css'; style.setAttribute("data-type", "cryptoland-shortcodes-custom-css"); if (style.styleSheet) { style.styleSheet.cssText = css } else { style.appendChild(document.createTextNode(css)) }
    head.appendChild(style)
} (function ($) {
    function setBacktop_1() { var backtop_1 = $(".c-backtop-1"); if (backtop_1.length) { if (backtop_1.hasClass("-js-backtop")) { backtop_1.on("click", function () { $("body, html").animate({ scrollTop: 0 }, 800) }); $(window).on("scroll", function () { if ($(window).scrollTop() > 40) { backtop_1.fadeIn() } else { backtop_1.fadeOut() } }) } } }
    function hasOverlay() { $(".has_overlay").hover(function () { var customhvroverlay = $(this).attr('data-hvr-overlay'); if (customhvroverlay) { $(this).css("background-color", customhvroverlay) } else { $(this).css("background-color", 'transparent') } }, function () { var customhvroverlay = $(this).attr('data-hvr-overlay'); if (customhvroverlay) { $(this).css("background-color", 'transparent') } else { $(this).css("background-color", 'transparent') } }) }
    function hasTrasform() { $(".has_transform").hover(function () { var customhvrtrasform = $(this).attr('data-hvr-scale'); if (customhvrtrasform) { $(this).find('img').css({ '-webkit-transform': 'scale(' + customhvrtrasform + ')', '-ms-transform': 'scale(' + customhvrtrasform + ')', 'transform': 'scale(' + customhvrtrasform + ')' }) } }, function () { var customhvrtrasform = $(this).attr('data-hvr-scale'); if (customhvrtrasform) { $(this).find('img').css({ '-webkit-transform': 'scale(1)', '-ms-transform': 'scale(1)', 'transform': 'scale(1)' }) } }) }
    function hasOpacity() { var customopac = $(".has_opacity").attr('data-opacity'); $(".has_opacity").css("opacity", customopac); $(".has_opacity").hover(function () { var customopacity = $(this).attr('data-opacity'), customhvropacity = $(this).attr('data-hvr-opacity'); if (customopacity && customhvropacity) { $(this).css("opacity", customhvropacity) } }, function () { var customopacity = $(this).attr('data-opacity'), customhvropacity = $(this).attr('data-hvr-opacity'); if (customopacity && customhvropacity) { $(this).css("opacity", customopacity) } }) }
    function btnHover() { $('[data-btnstyle="custom"]').hover(function () { var clr = $(this).css('color'), bg = $(this).css('background-color'), hvrclr = $(this).attr('data-hvrclr'), hvrbg = $(this).attr('data-hvrbg'); $(this).css("color", hvrclr); $(this).css("background", hvrbg); $(this).attr('data-hvrclr', clr); $(this).attr('data-hvrbg', bg) }, function () { var hvrclr = $(this).css('color'), hvrbg = $(this).css('background-color'), clr = $(this).attr('data-hvrclr'), bg = $(this).attr('data-hvrbg'); $(this).css("color", clr); $(this).css("background", bg); $(this).attr('data-hvrclr', hvrclr); $(this).attr('data-hvrbg', hvrbg) }) }
    $(document).ready(function () {
        setBacktop_1(); hasOverlay(); hasTrasform(); hasOpacity(); btnHover(); $('.vc_row').each(function (e) { var count = $(this).find('.wpb_column').size(); $(this).find('.wpb_column').each(function (i) { var index = i - count; $(this).css('z-index', -index) }) }); var parallaxbg = $('[data-jarallax]'); if (parallaxbg > 0) { $('.jarallax-cryptoland').jarallax(); jarallax(document.querySelectorAll('.mobile-parallax-off'), { disableParallax: function () { return /iPad|iPhone|iPod|Android/.test(navigator.userAgent) }, disableVideo: function () { return /iPad|iPhone|iPod|Android/.test(navigator.userAgent) } }) }
        $('.wpcf7-response-output').ajaxComplete(function () { window.setTimeout(function () { $('.wpcf7-response-output').addClass('display-none') }, 4000) })
    })
})(jQuery); (function (k, xa) { "object" === typeof exports && "undefined" !== typeof module ? xa(exports) : "function" === typeof define && define.amd ? define(["exports"], xa) : xa(k.THREE = {}) })(this, function (k) {
    function xa() { } function C(a, b) { this.x = a || 0; this.y = b || 0 } function M() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } function ja(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._w = void 0 !== d ? d : 1 } function p(a, b, c) { this.x = a || 0; this.y = b || 0; this.z = c || 0 } function sa() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } function Y(a, b, c, d, e, f, g, h, l, m) { Object.defineProperty(this, "id", { value: xf++ }); this.uuid = S.generateUUID(); this.name = ""; this.image = void 0 !== a ? a : Y.DEFAULT_IMAGE; this.mipmaps = []; this.mapping = void 0 !== b ? b : Y.DEFAULT_MAPPING; this.wrapS = void 0 !== c ? c : 1001; this.wrapT = void 0 !== d ? d : 1001; this.magFilter = void 0 !== e ? e : 1006; this.minFilter = void 0 !== f ? f : 1008; this.anisotropy = void 0 !== l ? l : 1; this.format = void 0 !== g ? g : 1023; this.type = void 0 !== h ? h : 1009; this.offset = new C(0, 0); this.repeat = new C(1, 1); this.center = new C(0, 0); this.rotation = 0; this.matrixAutoUpdate = !0; this.matrix = new sa; this.generateMipmaps = !0; this.premultiplyAlpha = !1; this.flipY = !0; this.unpackAlignment = 4; this.encoding = void 0 !== m ? m : 3E3; this.version = 0; this.onUpdate = null } function ea(a, b, c, d) { this.x = a || 0; this.y = b || 0; this.z = c || 0; this.w = void 0 !== d ? d : 1 } function hb(a, b, c) { this.width = a; this.height = b; this.scissor = new ea(0, 0, a, b); this.scissorTest = !1; this.viewport = new ea(0, 0, a, b); c = c || {}; void 0 === c.minFilter && (c.minFilter = 1006); this.texture = new Y(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding); this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0; this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0; this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null } function Ib(a, b, c) { hb.call(this, a, b, c); this.activeMipMapLevel = this.activeCubeFace = 0 } function ib(a, b, c, d, e, f, g, h, l, m, u, n) { Y.call(this, null, f, g, h, l, m, d, e, u, n); this.image = { data: a, width: b, height: c }; this.magFilter = void 0 !== l ? l : 1003; this.minFilter = void 0 !== m ? m : 1003; this.flipY = this.generateMipmaps = !1; this.unpackAlignment = 1 } function Va(a, b) { this.min = void 0 !== a ? a : new p(Infinity, Infinity, Infinity); this.max = void 0 !== b ? b : new p(-Infinity, -Infinity, -Infinity) } function Ea(a, b) { this.center = void 0 !== a ? a : new p; this.radius = void 0 !== b ? b : 0 } function Fa(a, b) { this.normal = void 0 !== a ? a : new p(1, 0, 0); this.constant = void 0 !== b ? b : 0 } function ld(a, b, c, d, e, f) { this.planes = [void 0 !== a ? a : new Fa, void 0 !== b ? b : new Fa, void 0 !== c ? c : new Fa, void 0 !== d ? d : new Fa, void 0 !== e ? e : new Fa, void 0 !== f ? f : new Fa] } function I(a, b, c) { return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c) } function yf(a) {
        function b(b, c) {
            var d = b.array, e = b.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW, h = a.createBuffer(); a.bindBuffer(c, h); a.bufferData(c, d, e); b.onUploadCallback(); c = a.FLOAT; d instanceof Float32Array ? c = a.FLOAT : d instanceof
                Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = a.UNSIGNED_SHORT : d instanceof Int16Array ? c = a.SHORT : d instanceof Uint32Array ? c = a.UNSIGNED_INT : d instanceof Int32Array ? c = a.INT : d instanceof Int8Array ? c = a.BYTE : d instanceof Uint8Array && (c = a.UNSIGNED_BYTE); return { buffer: h, type: c, bytesPerElement: d.BYTES_PER_ELEMENT, version: b.version }
        } var c = new WeakMap; return { get: function (a) { a.isInterleavedBufferAttribute && (a = a.data); return c.get(a) }, remove: function (b) { b.isInterleavedBufferAttribute && (b = b.data); var d = c.get(b); d && (a.deleteBuffer(d.buffer), c.delete(b)) }, update: function (d, e) { d.isInterleavedBufferAttribute && (d = d.data); var f = c.get(d); if (void 0 === f) c.set(d, b(d, e)); else if (f.version < d.version) { var g = d, h = g.array, l = g.updateRange; a.bindBuffer(e, f.buffer); !1 === g.dynamic ? a.bufferData(e, h, a.STATIC_DRAW) : -1 === l.count ? a.bufferSubData(e, 0, h) : 0 === l.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, l.offset * h.BYTES_PER_ELEMENT, h.subarray(l.offset, l.offset + l.count)), l.count = -1); f.version = d.version } } }
    } function jb(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._order = d || jb.DefaultOrder } function Sd() { this.mask = 1 } function A() { Object.defineProperty(this, "id", { value: zf++ }); this.uuid = S.generateUUID(); this.name = ""; this.type = "Object3D"; this.parent = null; this.children = []; this.up = A.DefaultUp.clone(); var a = new p, b = new jb, c = new ja, d = new p(1, 1, 1); b.onChange(function () { c.setFromEuler(b, !1) }); c.onChange(function () { b.setFromQuaternion(c, void 0, !1) }); Object.defineProperties(this, { position: { enumerable: !0, value: a }, rotation: { enumerable: !0, value: b }, quaternion: { enumerable: !0, value: c }, scale: { enumerable: !0, value: d }, modelViewMatrix: { value: new M }, normalMatrix: { value: new sa } }); this.matrix = new M; this.matrixWorld = new M; this.matrixAutoUpdate = A.DefaultMatrixAutoUpdate; this.matrixWorldNeedsUpdate = !1; this.layers = new Sd; this.visible = !0; this.receiveShadow = this.castShadow = !1; this.frustumCulled = !0; this.renderOrder = 0; this.userData = {} } function Qa() { A.call(this); this.type = "Camera"; this.matrixWorldInverse = new M; this.projectionMatrix = new M } function Jb(a, b, c, d, e, f) { Qa.call(this); this.type = "OrthographicCamera"; this.zoom = 1; this.view = null; this.left = a; this.right = b; this.top = c; this.bottom = d; this.near = void 0 !== e ? e : .1; this.far = void 0 !== f ? f : 2E3; this.updateProjectionMatrix() } function Wa(a, b, c, d, e, f) { this.a = a; this.b = b; this.c = c; this.normal = d && d.isVector3 ? d : new p; this.vertexNormals = Array.isArray(d) ? d : []; this.color = e && e.isColor ? e : new I; this.vertexColors = Array.isArray(e) ? e : []; this.materialIndex = void 0 !== f ? f : 0 } function N() { Object.defineProperty(this, "id", { value: Af += 2 }); this.uuid = S.generateUUID(); this.name = ""; this.type = "Geometry"; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphNormals = []; this.skinWeights = []; this.skinIndices = []; this.lineDistances = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1 } function T(a, b, c) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = ""; this.array = a; this.itemSize = b; this.count = void 0 !== a ? a.length / b : 0; this.normalized = !0 === c; this.dynamic = !1; this.updateRange = { offset: 0, count: -1 }; this.version = 0 } function rc(a, b, c) { T.call(this, new Int8Array(a), b, c) } function sc(a, b, c) { T.call(this, new Uint8Array(a), b, c) } function tc(a, b, c) { T.call(this, new Uint8ClampedArray(a), b, c) } function uc(a, b, c) { T.call(this, new Int16Array(a), b, c) } function kb(a, b, c) { T.call(this, new Uint16Array(a), b, c) } function vc(a, b, c) { T.call(this, new Int32Array(a), b, c) } function lb(a, b, c) { T.call(this, new Uint32Array(a), b, c) } function z(a, b, c) { T.call(this, new Float32Array(a), b, c) } function wc(a, b, c) { T.call(this, new Float64Array(a), b, c) } function Ce() { this.vertices = []; this.normals = []; this.colors = []; this.uvs = []; this.uvs2 = []; this.groups = []; this.morphTargets = {}; this.skinWeights = []; this.skinIndices = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1 } function De(a) { if (0 === a.length) return -Infinity; for (var b = a[0], c = 1, d = a.length; c < d; ++c)a[c] > b && (b = a[c]); return b } function F() { Object.defineProperty(this, "id", { value: Bf += 2 }); this.uuid = S.generateUUID(); this.name = ""; this.type = "BufferGeometry"; this.index = null; this.attributes = {}; this.morphAttributes = {}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.drawRange = { start: 0, count: Infinity } } function Kb(a, b, c, d, e, f) { N.call(this); this.type = "BoxGeometry"; this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f }; this.fromBufferGeometry(new mb(a, b, c, d, e, f)); this.mergeVertices() } function mb(a, b, c, d, e, f) { function g(a, b, c, d, e, f, g, k, P, H, ta) { var q = f / P, v = g / H, x = f / 2, K = g / 2, w = k / 2; g = P + 1; var y = H + 1, B = f = 0, G, C, z = new p; for (C = 0; C < y; C++) { var A = C * v - K; for (G = 0; G < g; G++)z[a] = (G * q - x) * d, z[b] = A * e, z[c] = w, m.push(z.x, z.y, z.z), z[a] = 0, z[b] = 0, z[c] = 0 < k ? 1 : -1, u.push(z.x, z.y, z.z), n.push(G / P), n.push(1 - C / H), f += 1 } for (C = 0; C < H; C++)for (G = 0; G < P; G++)a = t + G + g * (C + 1), b = t + (G + 1) + g * (C + 1), c = t + (G + 1) + g * C, l.push(t + G + g * C, a, c), l.push(a, b, c), B += 6; h.addGroup(r, B, ta); r += B; t += f } F.call(this); this.type = "BoxBufferGeometry"; this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f }; var h = this; a = a || 1; b = b || 1; c = c || 1; d = Math.floor(d) || 1; e = Math.floor(e) || 1; f = Math.floor(f) || 1; var l = [], m = [], u = [], n = [], t = 0, r = 0; g("z", "y", "x", -1, -1, c, b, a, f, e, 0); g("z", "y", "x", 1, -1, c, b, -a, f, e, 1); g("x", "z", "y", 1, 1, a, c, b, d, f, 2); g("x", "z", "y", 1, -1, a, c, -b, d, f, 3); g("x", "y", "z", 1, -1, a, b, c, d, e, 4); g("x", "y", "z", -1, -1, a, b, -c, d, e, 5); this.setIndex(l); this.addAttribute("position", new z(m, 3)); this.addAttribute("normal", new z(u, 3)); this.addAttribute("uv", new z(n, 2)) } function xc(a, b, c, d) { N.call(this); this.type = "PlaneGeometry"; this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; this.fromBufferGeometry(new pb(a, b, c, d)); this.mergeVertices() } function pb(a, b, c, d) { F.call(this); this.type = "PlaneBufferGeometry"; this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; a = a || 1; b = b || 1; var e = a / 2, f = b / 2; c = Math.floor(c) || 1; d = Math.floor(d) || 1; var g = c + 1, h = d + 1, l = a / c, m = b / d, u = [], n = [], t = [], r = []; for (a = 0; a < h; a++) { var q = a * m - f; for (b = 0; b < g; b++)n.push(b * l - e, -q, 0), t.push(0, 0, 1), r.push(b / c), r.push(1 - a / d) } for (a = 0; a < d; a++)for (b = 0; b < c; b++)e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, u.push(b + g * a, e, h), u.push(e, f, h); this.setIndex(u); this.addAttribute("position", new z(n, 3)); this.addAttribute("normal", new z(t, 3)); this.addAttribute("uv", new z(r, 2)) } function O() { Object.defineProperty(this, "id", { value: Cf++ }); this.uuid = S.generateUUID(); this.name = ""; this.type = "Material"; this.lights = this.fog = !0; this.blending = 1; this.side = 0; this.flatShading = !1; this.vertexColors = 0; this.opacity = 1; this.transparent = !1; this.blendSrc = 204; this.blendDst = 205; this.blendEquation = 100; this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null; this.depthFunc = 3; this.depthWrite = this.depthTest = !0; this.clippingPlanes = null; this.clipShadows = this.clipIntersection = !1; this.shadowSide = null; this.colorWrite = !0; this.precision = null; this.polygonOffset = !1; this.polygonOffsetUnits = this.polygonOffsetFactor = 0; this.dithering = !1; this.alphaTest = 0; this.premultipliedAlpha = !1; this.overdraw = 0; this.visible = !0; this.userData = {}; this.needsUpdate = !0 } function za(a) { O.call(this); this.type = "MeshBasicMaterial"; this.color = new I(16777215); this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.envMap = this.alphaMap = this.specularMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.lights = this.morphTargets = this.skinning = !1; this.setValues(a) } function va(a) { O.call(this); this.type = "ShaderMaterial"; this.defines = {}; this.uniforms = {}; this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"; this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; this.linewidth = 1; this.wireframe = !1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1; this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }; this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }; this.index0AttributeName = void 0; this.uniformsNeedUpdate = !1; void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a)) }
    function qb(a, b) { this.origin = void 0 !== a ? a : new p; this.direction = void 0 !== b ? b : new p } function Lb(a, b) { this.start = void 0 !== a ? a : new p; this.end = void 0 !== b ? b : new p } function Aa(a, b, c) { this.a = void 0 !== a ? a : new p; this.b = void 0 !== b ? b : new p; this.c = void 0 !== c ? c : new p } function oa(a, b) { A.call(this); this.type = "Mesh"; this.geometry = void 0 !== a ? a : new F; this.material = void 0 !== b ? b : new za({ color: 16777215 * Math.random() }); this.drawMode = 0; this.updateMorphTargets() } function Df(a, b, c, d) { function e(a, c) { b.buffers.color.setClear(a.r, a.g, a.b, c, d) } var f = new I(0), g = 0, h, l, m; return { getClearColor: function () { return f }, setClearColor: function (a, b) { f.set(a); g = void 0 !== b ? b : 1; e(f, g) }, getClearAlpha: function () { return g }, setClearAlpha: function (a) { g = a; e(f, g) }, render: function (b, d, t, r) { d = d.background; null === d ? e(f, g) : d && d.isColor && (e(d, 1), r = !0); (a.autoClear || r) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil); d && d.isCubeTexture ? (void 0 === m && (m = new oa(new mb(1, 1, 1), new va({ uniforms: rb.cube.uniforms, vertexShader: rb.cube.vertexShader, fragmentShader: rb.cube.fragmentShader, side: 1, depthTest: !0, depthWrite: !1, fog: !1 })), m.geometry.removeAttribute("normal"), m.geometry.removeAttribute("uv"), m.onBeforeRender = function (a, b, c) { this.matrixWorld.copyPosition(c.matrixWorld) }, c.update(m.geometry)), m.material.uniforms.tCube.value = d, b.push(m, m.geometry, m.material, 0, null)) : d && d.isTexture && (void 0 === h && (h = new Jb(-1, 1, 1, -1, 0, 1), l = new oa(new pb(2, 2), new za({ depthTest: !1, depthWrite: !1, fog: !1 })), c.update(l.geometry)), l.material.map = d, a.renderBufferDirect(h, null, l.geometry, l.material, l, null)) } } } function Ef(a, b, c) { var d; this.setMode = function (a) { d = a }; this.render = function (b, f) { a.drawArrays(d, b, f); c.update(f, d) }; this.renderInstances = function (a, f, g) { var e = b.get("ANGLE_instanced_arrays"); if (null === e) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else { var l = a.attributes.position; l.isInterleavedBufferAttribute ? (g = l.data.count, e.drawArraysInstancedANGLE(d, 0, g, a.maxInstancedCount)) : e.drawArraysInstancedANGLE(d, f, g, a.maxInstancedCount); c.update(g, d, a.maxInstancedCount) } } } function Ff(a, b, c) { function d(b) { if ("highp" === b) { if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp"; b = "mediump" } return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp" } var e, f = void 0 !== c.precision ? c.precision : "highp", g = d(f); g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g); c = !0 === c.logarithmicDepthBuffer; g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS); var h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), l = a.getParameter(a.MAX_TEXTURE_SIZE), m = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), u = a.getParameter(a.MAX_VERTEX_ATTRIBS), n = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), t = a.getParameter(a.MAX_VARYING_VECTORS), r = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), q = 0 < h, k = !!b.get("OES_texture_float"); return { getMaxAnisotropy: function () { if (void 0 !== e) return e; var c = b.get("EXT_texture_filter_anisotropic"); return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: d, precision: f, logarithmicDepthBuffer: c, maxTextures: g, maxVertexTextures: h, maxTextureSize: l, maxCubemapSize: m, maxAttributes: u, maxVertexUniforms: n, maxVaryings: t, maxFragmentUniforms: r, vertexTextures: q, floatFragmentTextures: k, floatVertexTextures: q && k } } function Gf() { function a() { m.value !== d && (m.value = d, m.needsUpdate = 0 < e); c.numPlanes = e; c.numIntersection = 0 } function b(a, b, d, e) { var f = null !== a ? a.length : 0, g = null; if (0 !== f) { g = m.value; if (!0 !== e || null === g) { e = d + 4 * f; b = b.matrixWorldInverse; l.getNormalMatrix(b); if (null === g || g.length < e) g = new Float32Array(e); for (e = 0; e !== f; ++e, d += 4)h.copy(a[e]).applyMatrix4(b, l), h.normal.toArray(g, d), g[d + 3] = h.constant } m.value = g; m.needsUpdate = !0 } c.numPlanes = f; return g } var c = this, d = null, e = 0, f = !1, g = !1, h = new Fa, l = new sa, m = { value: null, needsUpdate: !1 }; this.uniform = m; this.numIntersection = this.numPlanes = 0; this.init = function (a, c, g) { var h = 0 !== a.length || c || 0 !== e || f; f = c; d = b(a, g, 0); e = a.length; return h }; this.beginShadows = function () { g = !0; b(null) }; this.endShadows = function () { g = !1; a() }; this.setState = function (c, h, l, r, q, k) { if (!f || null === c || 0 === c.length || g && !l) g ? b(null) : a(); else { l = g ? 0 : e; var n = 4 * l, u = q.clippingState || null; m.value = u; u = b(c, r, n, k); for (c = 0; c !== n; ++c)u[c] = d[c]; q.clippingState = u; this.numIntersection = h ? this.numPlanes : 0; this.numPlanes += l } } } function Hf(a) { var b = {}; return { get: function (c) { if (void 0 !== b[c]) return b[c]; switch (c) { case "WEBGL_depth_texture": var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; case "WEBGL_compressed_texture_etc1": d = a.getExtension("WEBGL_compressed_texture_etc1"); break; default: d = a.getExtension(c) }null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."); return b[c] = d } } } function If(a, b, c) { function d(a) { a = a.target; var g = e[a.id]; null !== g.index && b.remove(g.index); for (var l in g.attributes) b.remove(g.attributes[l]); a.removeEventListener("dispose", d); delete e[a.id]; if (l = f[a.id]) b.remove(l), delete f[a.id]; if (l = f[g.id]) b.remove(l), delete f[g.id]; c.memory.geometries-- } var e = {}, f = {}; return { get: function (a, b) { var f = e[b.id]; if (f) return f; b.addEventListener("dispose", d); b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new F).setFromObject(a)), f = b._bufferGeometry); e[b.id] = f; c.memory.geometries++; return f }, update: function (c) { var d = c.index, e = c.attributes; null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER); for (var f in e) b.update(e[f], a.ARRAY_BUFFER); c = c.morphAttributes; for (f in c) { d = c[f]; e = 0; for (var g = d.length; e < g; e++)b.update(d[e], a.ARRAY_BUFFER) } }, getWireframeAttribute: function (c) { var d = f[c.id]; if (d) return d; d = []; var e = c.index, g = c.attributes; if (null !== e) { e = e.array; g = 0; for (var u = e.length; g < u; g += 3) { var n = e[g + 0], t = e[g + 1], r = e[g + 2]; d.push(n, t, t, r, r, n) } } else for (e = g.position.array, g = 0, u = e.length / 3 - 1; g < u; g += 3)n = g + 0, t = g + 1, r = g + 2, d.push(n, t, t, r, r, n); d = new (65535 < De(d) ? lb : kb)(d, 1); b.update(d, a.ELEMENT_ARRAY_BUFFER); return f[c.id] = d } } } function Jf(a, b, c) { var d, e, f; this.setMode = function (a) { d = a }; this.setIndex = function (a) { e = a.type; f = a.bytesPerElement }; this.render = function (b, h) { a.drawElements(d, h, e, b * f); c.update(h, d) }; this.renderInstances = function (a, h, l) { var g = b.get("ANGLE_instanced_arrays"); null === g ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (g.drawElementsInstancedANGLE(d, l, e, h * f, a.maxInstancedCount), c.update(l, d, a.maxInstancedCount)) } } function Kf(a) { var b = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: b, programs: null, autoReset: !0, reset: function () { b.frame++; b.calls = 0; b.triangles = 0; b.points = 0; b.lines = 0 }, update: function (c, d, e) { e = e || 1; b.calls++; switch (d) { case a.TRIANGLES: b.triangles += c / 3 * e; break; case a.TRIANGLE_STRIP: case a.TRIANGLE_FAN: b.triangles += e * (c - 2); break; case a.LINES: b.lines += c / 2 * e; break; case a.LINE_STRIP: b.lines += e * (c - 1); break; case a.LINE_LOOP: b.lines += e * c; break; case a.POINTS: b.points += e * c; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", d) } } } } function Lf(a, b) { return Math.abs(b[1]) - Math.abs(a[1]) } function Mf(a) { var b = {}, c = new Float32Array(8); return { update: function (d, e, f, g) { var h = d.morphTargetInfluences, l = h.length; d = b[e.id]; if (void 0 === d) { d = []; for (var m = 0; m < l; m++)d[m] = [m, 0]; b[e.id] = d } var u = f.morphTargets && e.morphAttributes.position; f = f.morphNormals && e.morphAttributes.normal; for (m = 0; m < l; m++) { var n = d[m]; 0 !== n[1] && (u && e.removeAttribute("morphTarget" + m), f && e.removeAttribute("morphNormal" + m)) } for (m = 0; m < l; m++)n = d[m], n[0] = m, n[1] = h[m]; d.sort(Lf); for (m = 0; 8 > m; m++) { if (n = d[m]) if (h = n[0], l = n[1]) { u && e.addAttribute("morphTarget" + m, u[h]); f && e.addAttribute("morphNormal" + m, f[h]); c[m] = l; continue } c[m] = 0 } g.getUniforms().setValue(a, "morphTargetInfluences", c) } } } function Nf(a, b) { var c = {}; return { update: function (d) { var e = b.render.frame, f = d.geometry, g = a.get(d, f); c[g.id] !== e && (f.isGeometry && g.updateFromObject(d), a.update(g), c[g.id] = e); return g }, dispose: function () { c = {} } } } function ab(a, b, c, d, e, f, g, h, l, m) { a = void 0 !== a ? a : []; Y.call(this, a, void 0 !== b ? b : 301, c, d, e, f, g, h, l, m); this.flipY = !1 } function Mb(a, b, c) { var d = a[0]; if (0 >= d || 0 < d) return a; var e = b * c, f = Ee[e]; void 0 === f && (f = new Float32Array(e), Ee[e] = f); if (0 !== b) for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d)e += c, a[d].toArray(f, e); return f } function Fe(a, b) { var c = Ge[b]; void 0 === c && (c = new Int32Array(b), Ge[b] = c); for (var d = 0; d !== b; ++d)c[d] = a.allocTextureUnit(); return c } function Of(a, b) { a.uniform1f(this.addr, b) } function Pf(a, b) { a.uniform1i(this.addr, b) } function Qf(a, b) { void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y) } function Rf(a, b) { void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b) } function Sf(a, b) { void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w) } function Tf(a, b) { a.uniformMatrix2fv(this.addr, !1, b.elements || b) } function Uf(a, b) { void 0 === b.elements ? a.uniformMatrix3fv(this.addr, !1, b) : (He.set(b.elements), a.uniformMatrix3fv(this.addr, !1, He)) } function Vf(a, b) { void 0 === b.elements ? a.uniformMatrix4fv(this.addr, !1, b) : (Ie.set(b.elements), a.uniformMatrix4fv(this.addr, !1, Ie)) } function Wf(a, b, c) { var d = c.allocTextureUnit(); a.uniform1i(this.addr, d); c.setTexture2D(b || Je, d) } function Xf(a, b, c) { var d = c.allocTextureUnit(); a.uniform1i(this.addr, d); c.setTextureCube(b || Ke, d) } function Le(a, b) { a.uniform2iv(this.addr, b) } function Me(a, b) { a.uniform3iv(this.addr, b) } function Ne(a, b) { a.uniform4iv(this.addr, b) } function Yf(a) { switch (a) { case 5126: return Of; case 35664: return Qf; case 35665: return Rf; case 35666: return Sf; case 35674: return Tf; case 35675: return Uf; case 35676: return Vf; case 35678: case 36198: return Wf; case 35680: return Xf; case 5124: case 35670: return Pf; case 35667: case 35671: return Le; case 35668: case 35672: return Me; case 35669: case 35673: return Ne } } function Zf(a, b) { a.uniform1fv(this.addr, b) } function $f(a, b) { a.uniform1iv(this.addr, b) } function ag(a, b) { a.uniform2fv(this.addr, Mb(b, this.size, 2)) } function bg(a, b) { a.uniform3fv(this.addr, Mb(b, this.size, 3)) } function cg(a, b) { a.uniform4fv(this.addr, Mb(b, this.size, 4)) } function dg(a, b) { a.uniformMatrix2fv(this.addr, !1, Mb(b, this.size, 4)) } function eg(a, b) { a.uniformMatrix3fv(this.addr, !1, Mb(b, this.size, 9)) } function fg(a, b) { a.uniformMatrix4fv(this.addr, !1, Mb(b, this.size, 16)) } function gg(a, b, c) { var d = b.length, e = Fe(c, d); a.uniform1iv(this.addr, e); for (a = 0; a !== d; ++a)c.setTexture2D(b[a] || Je, e[a]) } function hg(a, b, c) { var d = b.length, e = Fe(c, d); a.uniform1iv(this.addr, e); for (a = 0; a !== d; ++a)c.setTextureCube(b[a] || Ke, e[a]) } function ig(a) { switch (a) { case 5126: return Zf; case 35664: return ag; case 35665: return bg; case 35666: return cg; case 35674: return dg; case 35675: return eg; case 35676: return fg; case 35678: return gg; case 35680: return hg; case 5124: case 35670: return $f; case 35667: case 35671: return Le; case 35668: case 35672: return Me; case 35669: case 35673: return Ne } } function jg(a, b, c) { this.id = a; this.addr = c; this.setValue = Yf(b.type) } function kg(a, b, c) { this.id = a; this.addr = c; this.size = b.size; this.setValue = ig(b.type) } function Oe(a) { this.id = a; this.seq = []; this.map = {} } function bb(a, b, c) { this.seq = []; this.map = {}; this.renderer = c; c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS); for (var d = 0; d < c; ++d) { var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, l = h.length; for (Ud.lastIndex = 0; ;) { var m = Ud.exec(h), u = Ud.lastIndex, n = m[1], t = m[3]; "]" === m[2] && (n |= 0); if (void 0 === t || "[" === t && u + 2 === l) { h = g; e = void 0 === t ? new jg(n, e, f) : new kg(n, e, f); h.seq.push(e); h.map[e.id] = e; break } else t = g.map[n], void 0 === t && (t = new Oe(n), n = g, g = t, n.seq.push(g), n.map[g.id] = g), g = t } } } function lg(a) { a = a.split("\n"); for (var b = 0; b < a.length; b++)a[b] = b + 1 + ": " + a[b]; return a.join("\n") } function Pe(a, b, c) { var d = a.createShader(b); a.shaderSource(d, c); a.compileShader(d); !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."); "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), lg(c)); return d } function Qe(a) { switch (a) { case 3E3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw Error("unsupported encoding: " + a); } } function Vd(a, b) { b = Qe(b); return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }" } function mg(a, b) { b = Qe(b); return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }" } function ng(a, b) { switch (b) { case 1: b = "Linear"; break; case 2: b = "Reinhard"; break; case 3: b = "Uncharted2"; break; case 4: b = "OptimizedCineon"; break; default: throw Error("unsupported toneMapping: " + b); }return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }" } function og(a, b, c) { a = a || {}; return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(yc).join("\n") } function pg(a) { var b = [], c; for (c in a) { var d = a[c]; !1 !== d && b.push("#define " + c + " " + d) } return b.join("\n") } function yc(a) { return "" !== a } function Re(a, b) { return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights) } function Se(a, b) { return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection) } function Wd(a) {
        return a.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function (a, c) {
            a = V[c]; if (void 0 === a) throw Error("Can not resolve #include <" + c +
                ">"); return Wd(a)
        })
    } function Te(a) { return a.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (a, c, d, e) { a = ""; for (c = parseInt(c); c < parseInt(d); c++)a += e.replace(/\[ i \]/g, "[ " + c + " ]"); return a }) } function qg(a, b, c, d, e, f) {
        var g = a.context, h = d.defines, l = e.vertexShader, m = e.fragmentShader, u = "SHADOWMAP_TYPE_BASIC"; 1 === f.shadowMapType ? u = "SHADOWMAP_TYPE_PCF" : 2 === f.shadowMapType && (u = "SHADOWMAP_TYPE_PCF_SOFT"); var n = "ENVMAP_TYPE_CUBE", t = "ENVMAP_MODE_REFLECTION", r = "ENVMAP_BLENDING_MULTIPLY"; if (f.envMap) { switch (d.envMap.mapping) { case 301: case 302: n = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: n = "ENVMAP_TYPE_CUBE_UV"; break; case 303: case 304: n = "ENVMAP_TYPE_EQUIREC"; break; case 305: n = "ENVMAP_TYPE_SPHERE" }switch (d.envMap.mapping) { case 302: case 304: t = "ENVMAP_MODE_REFRACTION" }switch (d.combine) { case 0: r = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: r = "ENVMAP_BLENDING_MIX"; break; case 2: r = "ENVMAP_BLENDING_ADD" } } var k = 0 < a.gammaFactor ? a.gammaFactor : 1, v = og(d.extensions, f, b), x = pg(h), p = g.createProgram(); d.isRawShaderMaterial ? (h = [x].filter(yc).join("\n"), 0 < h.length && (h += "\n"), b = [v, x].filter(yc).join("\n"), 0 < b.length && (b += "\n")) : (h = ["precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, x, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + k, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + t : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + u : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && b.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(yc).join("\n"), b = [v, "precision " + f.precision + " float;", "precision " +
            f.precision + " int;", "#define SHADER_NAME " + e.name, x, f.alphaTest ? "#define ALPHATEST " + f.alphaTest : "", "#define GAMMA_FACTOR " + k, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + n : "", f.envMap ? "#define " + t : "", f.envMap ? "#define " + r : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + u : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && b.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", f.envMap && b.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== f.toneMapping ? "#define TONE_MAPPING" : "", 0 !== f.toneMapping ? V.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? ng("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? V.encodings_pars_fragment : "", f.mapEncoding ? Vd("mapTexelToLinear", f.mapEncoding) : "", f.envMapEncoding ? Vd("envMapTexelToLinear", f.envMapEncoding) : "", f.emissiveMapEncoding ? Vd("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.outputEncoding ? mg("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"].filter(yc).join("\n")); l = Wd(l); l = Re(l, f); l = Se(l, f); m = Wd(m); m = Re(m, f); m = Se(m, f); l = Te(l); m = Te(m); m = b + m; l = Pe(g, g.VERTEX_SHADER, h + l); m = Pe(g, g.FRAGMENT_SHADER, m); g.attachShader(p, l); g.attachShader(p, m); void 0 !== d.index0AttributeName ? g.bindAttribLocation(p, 0, d.index0AttributeName) : !0 === f.morphTargets && g.bindAttribLocation(p, 0, "position"); g.linkProgram(p); f = g.getProgramInfoLog(p).trim(); e = g.getShaderInfoLog(l).trim(); u = g.getShaderInfoLog(m).trim(); t = n = !0; if (!1 === g.getProgramParameter(p, g.LINK_STATUS)) n = !1, console.error("THREE.WebGLProgram: shader error: ", g.getError(), "gl.VALIDATE_STATUS", g.getProgramParameter(p, g.VALIDATE_STATUS), "gl.getProgramInfoLog", f, e, u); else if ("" !== f) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f); else if ("" === e || "" === u) t = !1; t && (this.diagnostics = { runnable: n, material: d, programLog: f, vertexShader: { log: e, prefix: h }, fragmentShader: { log: u, prefix: b } }); g.deleteShader(l); g.deleteShader(m); var w; this.getUniforms = function () { void 0 === w && (w = new bb(g, p, a)); return w }; var B; this.getAttributes = function () { if (void 0 === B) { for (var a = {}, b = g.getProgramParameter(p, g.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) { var d = g.getActiveAttrib(p, c).name; a[d] = g.getAttribLocation(p, d) } B = a } return B }; this.destroy = function () { g.deleteProgram(p); this.program = void 0 }; Object.defineProperties(this, { uniforms: { get: function () { console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."); return this.getUniforms() } }, attributes: { get: function () { console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."); return this.getAttributes() } } }); this.id = rg++; this.code = c; this.usedTimes = 1; this.program = p; this.vertexShader = l; this.fragmentShader = m; return this
    } function sg(a, b, c) { function d(a, b) { if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding); else var c = 3E3; 3E3 === c && b && (c = 3007); return c } var e = [], f = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow" }, g = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" "); this.getParameters = function (b, e, g, u, n, t, r) { var h = f[b.type]; if (r.isSkinnedMesh) { var l = r.skeleton.bones; if (c.floatVertexTextures) l = 1024; else { var m = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), l.length); m < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + m + "."), l = 0) : l = m } } else l = 0; m = c.precision; null !== b.precision && (m = c.getMaxPrecision(b.precision), m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead.")); var k = a.getRenderTarget(); return { shaderID: h, precision: m, supportsVertexTextures: c.vertexTextures, outputEncoding: d(k ? k.texture : null, a.gammaOutput), map: !!b.map, mapEncoding: d(b.map, a.gammaInput), envMap: !!b.envMap, envMapMode: b.envMap && b.envMap.mapping, envMapEncoding: d(b.envMap, a.gammaInput), envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping), lightMap: !!b.lightMap, aoMap: !!b.aoMap, emissiveMap: !!b.emissiveMap, emissiveMapEncoding: d(b.emissiveMap, a.gammaInput), bumpMap: !!b.bumpMap, normalMap: !!b.normalMap, displacementMap: !!b.displacementMap, roughnessMap: !!b.roughnessMap, metalnessMap: !!b.metalnessMap, specularMap: !!b.specularMap, alphaMap: !!b.alphaMap, gradientMap: !!b.gradientMap, combine: b.combine, vertexColors: b.vertexColors, fog: !!u, useFog: b.fog, fogExp: u && u.isFogExp2, flatShading: b.flatShading, sizeAttenuation: b.sizeAttenuation, logarithmicDepthBuffer: c.logarithmicDepthBuffer, skinning: b.skinning && 0 < l, maxBones: l, useVertexTexture: c.floatVertexTextures, morphTargets: b.morphTargets, morphNormals: b.morphNormals, maxMorphTargets: a.maxMorphTargets, maxMorphNormals: a.maxMorphNormals, numDirLights: e.directional.length, numPointLights: e.point.length, numSpotLights: e.spot.length, numRectAreaLights: e.rectArea.length, numHemiLights: e.hemi.length, numClippingPlanes: n, numClipIntersection: t, dithering: b.dithering, shadowMapEnabled: a.shadowMap.enabled && r.receiveShadow && 0 < g.length, shadowMapType: a.shadowMap.type, toneMapping: a.toneMapping, physicallyCorrectLights: a.physicallyCorrectLights, premultipliedAlpha: b.premultipliedAlpha, alphaTest: b.alphaTest, doubleSided: 2 === b.side, flipSided: 1 === b.side, depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1 } }; this.getProgramCode = function (b, c) { var d = []; c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader)); if (void 0 !== b.defines) for (var e in b.defines) d.push(e), d.push(b.defines[e]); for (e = 0; e < g.length; e++)d.push(c[g[e]]); d.push(b.onBeforeCompile.toString()); d.push(a.gammaOutput); return d.join() }; this.acquireProgram = function (c, d, f, g) { for (var h, l = 0, m = e.length; l < m; l++) { var u = e[l]; if (u.code === g) { h = u; ++h.usedTimes; break } } void 0 === h && (h = new qg(a, b, g, c, d, f), e.push(h)); return h }; this.releaseProgram = function (a) { if (0 === --a.usedTimes) { var b = e.indexOf(a); e[b] = e[e.length - 1]; e.pop(); a.destroy() } }; this.programs = e } function tg() { var a = new WeakMap; return { get: function (b) { var c = a.get(b); void 0 === c && (c = {}, a.set(b, c)); return c }, remove: function (b) { a.delete(b) }, update: function (b, c, d) { a.get(b)[c] = d }, dispose: function () { a = new WeakMap } } } function ug(a, b) { return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id } function vg(a, b) { return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id } function wg() { var a = [], b = 0, c = [], d = []; return { opaque: c, transparent: d, init: function () { b = 0; c.length = 0; d.length = 0 }, push: function (e, f, g, h, l) { var m = a[b]; void 0 === m ? (m = { id: e.id, object: e, geometry: f, material: g, program: g.program, renderOrder: e.renderOrder, z: h, group: l }, a[b] = m) : (m.id = e.id, m.object = e, m.geometry = f, m.material = g, m.program = g.program, m.renderOrder = e.renderOrder, m.z = h, m.group = l); (!0 === g.transparent ? d : c).push(m); b++ }, sort: function () { 1 < c.length && c.sort(ug); 1 < d.length && d.sort(vg) } } } function xg() { var a = {}; return { get: function (b, c) { b = b.id + "," + c.id; c = a[b]; void 0 === c && (c = new wg, a[b] = c); return c }, dispose: function () { a = {} } } } function yg() { var a = {}; return { get: function (b) { if (void 0 !== a[b.id]) return a[b.id]; switch (b.type) { case "DirectionalLight": var c = { direction: new p, color: new I, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C }; break; case "SpotLight": c = { position: new p, direction: new p, color: new I, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C }; break; case "PointLight": c = { position: new p, color: new I, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C, shadowCameraNear: 1, shadowCameraFar: 1E3 }; break; case "HemisphereLight": c = { direction: new p, skyColor: new I, groundColor: new I }; break; case "RectAreaLight": c = { color: new I, position: new p, halfWidth: new p, halfHeight: new p } }return a[b.id] = c } } } function zg() { var a = new yg, b = { id: Ag++, hash: "", ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, c = new p, d = new M, e = new M; return { setup: function (f, g, h) { var l = 0, m = 0, u = 0, n = 0, t = 0, r = 0, k = 0, v = 0; h = h.matrixWorldInverse; for (var x = 0, p = f.length; x < p; x++) { var w = f[x], B = w.color, G = w.intensity, K = w.distance, P = w.shadow && w.shadow.map ? w.shadow.map.texture : null; if (w.isAmbientLight) l += B.r * G, m += B.g * G, u += B.b * G; else if (w.isDirectionalLight) { var H = a.get(w); H.color.copy(w.color).multiplyScalar(w.intensity); H.direction.setFromMatrixPosition(w.matrixWorld); c.setFromMatrixPosition(w.target.matrixWorld); H.direction.sub(c); H.direction.transformDirection(h); if (H.shadow = w.castShadow) B = w.shadow, H.shadowBias = B.bias, H.shadowRadius = B.radius, H.shadowMapSize = B.mapSize; b.directionalShadowMap[n] = P; b.directionalShadowMatrix[n] = w.shadow.matrix; b.directional[n] = H; n++ } else if (w.isSpotLight) { H = a.get(w); H.position.setFromMatrixPosition(w.matrixWorld); H.position.applyMatrix4(h); H.color.copy(B).multiplyScalar(G); H.distance = K; H.direction.setFromMatrixPosition(w.matrixWorld); c.setFromMatrixPosition(w.target.matrixWorld); H.direction.sub(c); H.direction.transformDirection(h); H.coneCos = Math.cos(w.angle); H.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)); H.decay = 0 === w.distance ? 0 : w.decay; if (H.shadow = w.castShadow) B = w.shadow, H.shadowBias = B.bias, H.shadowRadius = B.radius, H.shadowMapSize = B.mapSize; b.spotShadowMap[r] = P; b.spotShadowMatrix[r] = w.shadow.matrix; b.spot[r] = H; r++ } else if (w.isRectAreaLight) H = a.get(w), H.color.copy(B).multiplyScalar(G), H.position.setFromMatrixPosition(w.matrixWorld), H.position.applyMatrix4(h), e.identity(), d.copy(w.matrixWorld), d.premultiply(h), e.extractRotation(d), H.halfWidth.set(.5 * w.width, 0, 0), H.halfHeight.set(0, .5 * w.height, 0), H.halfWidth.applyMatrix4(e), H.halfHeight.applyMatrix4(e), b.rectArea[k] = H, k++; else if (w.isPointLight) { H = a.get(w); H.position.setFromMatrixPosition(w.matrixWorld); H.position.applyMatrix4(h); H.color.copy(w.color).multiplyScalar(w.intensity); H.distance = w.distance; H.decay = 0 === w.distance ? 0 : w.decay; if (H.shadow = w.castShadow) B = w.shadow, H.shadowBias = B.bias, H.shadowRadius = B.radius, H.shadowMapSize = B.mapSize, H.shadowCameraNear = B.camera.near, H.shadowCameraFar = B.camera.far; b.pointShadowMap[t] = P; b.pointShadowMatrix[t] = w.shadow.matrix; b.point[t] = H; t++ } else w.isHemisphereLight && (H = a.get(w), H.direction.setFromMatrixPosition(w.matrixWorld), H.direction.transformDirection(h), H.direction.normalize(), H.skyColor.copy(w.color).multiplyScalar(G), H.groundColor.copy(w.groundColor).multiplyScalar(G), b.hemi[v] = H, v++) } b.ambient[0] = l; b.ambient[1] = m; b.ambient[2] = u; b.directional.length = n; b.spot.length = r; b.rectArea.length = k; b.point.length = t; b.hemi.length = v; b.hash = b.id + "," + n + "," + t + "," + r + "," + k + "," + v + "," + g.length }, state: b } } function Bg() { var a = new zg, b = [], c = [], d = []; return { init: function () { b.length = 0; c.length = 0; d.length = 0 }, state: { lightsArray: b, shadowsArray: c, spritesArray: d, lights: a }, setupLights: function (d) { a.setup(b, c, d) }, pushLight: function (a) { b.push(a) }, pushShadow: function (a) { c.push(a) }, pushSprite: function (a) { d.push(a) } } } function Cg() { var a = {}; return { get: function (b, c) { b = b.id + "," + c.id; c = a[b]; void 0 === c && (c = new Bg, a[b] = c); return c }, dispose: function () { a = {} } } } function cb(a) { O.call(this); this.type = "MeshDepthMaterial"; this.depthPacking = 3200; this.morphTargets = this.skinning = !1; this.displacementMap = this.alphaMap = this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe = !1; this.wireframeLinewidth = 1; this.lights = this.fog = !1; this.setValues(a) } function db(a) { O.call(this); this.type = "MeshDistanceMaterial"; this.referencePosition = new p; this.nearDistance = 1; this.farDistance = 1E3; this.morphTargets = this.skinning = !1; this.displacementMap = this.alphaMap = this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.lights = this.fog = !1; this.setValues(a) } function Ue(a, b, c) {
        function d(b, c, d, e, f, g) { var h = b.geometry; var l = n; var m = b.customDepthMaterial; d && (l = t, m = b.customDistanceMaterial); m ? l = m : (m = !1, c.morphTargets && (h && h.isBufferGeometry ? m = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (m = h.morphTargets && 0 < h.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, h = 0, m && (h |= 1), b && (h |= 2), l = l[h]); a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h = l.uuid, m = c.uuid, b = r[h], void 0 === b && (b = {}, r[h] = b), h = b[m], void 0 === h && (h = l.clone(), b[m] = h), l = h); l.visible = c.visible; l.wireframe = c.wireframe; l.side = null != c.shadowSide ? c.shadowSide : k[c.side]; l.clipShadows = c.clipShadows; l.clippingPlanes = c.clippingPlanes; l.clipIntersection = c.clipIntersection; l.wireframeLinewidth = c.wireframeLinewidth; l.linewidth = c.linewidth; d && l.isMeshDistanceMaterial && (l.referencePosition.copy(e), l.nearDistance = f, l.farDistance = g); return l }
        function e(c, g, h, l) { if (!1 !== c.visible) { if (c.layers.test(g.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || f.intersectsObject(c))) { c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, c.matrixWorld); var m = b.update(c), n = c.material; if (Array.isArray(n)) for (var t = m.groups, r = 0, k = t.length; r < k; r++) { var q = t[r], v = n[q.materialIndex]; v && v.visible && (v = d(c, v, l, u, h.near, h.far), a.renderBufferDirect(h, null, m, v, c, q)) } else n.visible && (v = d(c, n, l, u, h.near, h.far), a.renderBufferDirect(h, null, m, v, c, null)) } c = c.children; m = 0; for (n = c.length; m < n; m++)e(c[m], g, h, l) } } var f = new ld, g = new M, h = new C, l = new C(c, c), m = new p, u = new p, n = Array(4), t = Array(4), r = {}, k = { 0: 1, 1: 0, 2: 2 }, v = [new p(1, 0, 0), new p(-1, 0, 0), new p(0, 0, 1), new p(0, 0, -1), new p(0, 1, 0), new p(0, -1, 0)], x = [new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0), new p(0, 0, 1), new p(0, 0, -1)], y = [new ea, new ea, new ea, new ea, new ea, new ea]; for (c = 0; 4 !== c; ++c) { var w = 0 !== (c & 1), B = 0 !== (c & 2), G = new cb({ depthPacking: 3201, morphTargets: w, skinning: B }); n[c] = G; w = new db({ morphTargets: w, skinning: B }); t[c] = w } var K = this; this.enabled = !1; this.autoUpdate = !0; this.needsUpdate = !1; this.type = 1; this.render = function (b, c, d) { if (!1 !== K.enabled && (!1 !== K.autoUpdate || !1 !== K.needsUpdate) && 0 !== b.length) { var n = a.state; n.disable(a.context.BLEND); n.buffers.color.setClear(1, 1, 1, 1); n.buffers.depth.setTest(!0); n.setScissorTest(!1); for (var t, r = 0, k = b.length; r < k; r++) { var q = b[r]; t = q.shadow; var p = q && q.isPointLight; if (void 0 === t) console.warn("THREE.WebGLShadowMap:", q, "has no shadow."); else { var w = t.camera; h.copy(t.mapSize); h.min(l); if (p) { var P = h.x, H = h.y; y[0].set(2 * P, H, P, H); y[1].set(0, H, P, H); y[2].set(3 * P, H, P, H); y[3].set(P, H, P, H); y[4].set(3 * P, 0, P, H); y[5].set(P, 0, P, H); h.x *= 4; h.y *= 2 } null === t.map && (t.map = new hb(h.x, h.y, { minFilter: 1003, magFilter: 1003, format: 1023 }), t.map.texture.name = q.name + ".shadowMap", w.updateProjectionMatrix()); t.isSpotLightShadow && t.update(q); P = t.map; H = t.matrix; u.setFromMatrixPosition(q.matrixWorld); w.position.copy(u); p ? (t = 6, H.makeTranslation(-u.x, -u.y, -u.z)) : (t = 1, m.setFromMatrixPosition(q.target.matrixWorld), w.lookAt(m), w.updateMatrixWorld(), H.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), H.multiply(w.projectionMatrix), H.multiply(w.matrixWorldInverse)); a.setRenderTarget(P); a.clear(); for (q = 0; q < t; q++)p && (m.copy(w.position), m.add(v[q]), w.up.copy(x[q]), w.lookAt(m), w.updateMatrixWorld(), n.viewport(y[q])), g.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse), f.setFromMatrix(g), e(c, d, w, p) } } K.needsUpdate = !1 } }
    } function zc(a, b, c, d, e, f, g, h, l) { Y.call(this, a, b, c, d, e, f, g, h, l); this.needsUpdate = !0 } function Dg(a, b, c, d, e) { var f, g, h, l, m, u, n, t, r, k, v, x, y, w, B, G, K, P; function H(a, b) { return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id } var C, nb, Z, z, A = new p, F = new ja, I = new p; this.render = function (q, p, md) { if (0 !== q.length) { if (void 0 === Z) { var ta = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), ya = new Uint16Array([0, 1, 2, 0, 2, 3]); C = b.createBuffer(); nb = b.createBuffer(); b.bindBuffer(b.ARRAY_BUFFER, C); b.bufferData(b.ARRAY_BUFFER, ta, b.STATIC_DRAW); b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, nb); b.bufferData(b.ELEMENT_ARRAY_BUFFER, ya, b.STATIC_DRAW); ta = b.createProgram(); ya = b.createShader(b.VERTEX_SHADER); var Q = b.createShader(b.FRAGMENT_SHADER); b.shaderSource(ya, ["precision " + e.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 center;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvUV = uvOffset + uv * uvScale;\n\tvec2 alignedPosition = ( position - center ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\tfogDepth = - mvPosition.z;\n}"].join("\n")); b.shaderSource(Q, ["precision " + e.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\n\tif ( gl_FragColor.a < alphaTest ) discard;\n\tif ( fogType > 0 ) {\n\t\tfloat fogFactor = 0.0;\n\t\tif ( fogType == 1 ) {\n\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t\t} else {\n\t\t\tconst float LOG2 = 1.442695;\n\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );\n\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\t\t}\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}"].join("\n")); b.compileShader(ya); b.compileShader(Q); b.attachShader(ta, ya); b.attachShader(ta, Q); b.linkProgram(ta); Z = ta; K = b.getAttribLocation(Z, "position"); P = b.getAttribLocation(Z, "uv"); f = b.getUniformLocation(Z, "uvOffset"); g = b.getUniformLocation(Z, "uvScale"); h = b.getUniformLocation(Z, "rotation"); l = b.getUniformLocation(Z, "center"); m = b.getUniformLocation(Z, "scale"); u = b.getUniformLocation(Z, "color"); n = b.getUniformLocation(Z, "map"); t = b.getUniformLocation(Z, "opacity"); r = b.getUniformLocation(Z, "modelViewMatrix"); k = b.getUniformLocation(Z, "projectionMatrix"); v = b.getUniformLocation(Z, "fogType"); x = b.getUniformLocation(Z, "fogDensity"); y = b.getUniformLocation(Z, "fogNear"); w = b.getUniformLocation(Z, "fogFar"); B = b.getUniformLocation(Z, "fogColor"); b.getUniformLocation(Z, "fogDepth"); G = b.getUniformLocation(Z, "alphaTest"); ta = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); ta.width = 8; ta.height = 8; ya = ta.getContext("2d"); ya.fillStyle = "white"; ya.fillRect(0, 0, 8, 8); z = new zc(ta) } c.useProgram(Z); c.initAttributes(); c.enableAttribute(K); c.enableAttribute(P); c.disableUnusedAttributes(); c.disable(b.CULL_FACE); c.enable(b.BLEND); b.bindBuffer(b.ARRAY_BUFFER, C); b.vertexAttribPointer(K, 2, b.FLOAT, !1, 16, 0); b.vertexAttribPointer(P, 2, b.FLOAT, !1, 16, 8); b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, nb); b.uniformMatrix4fv(k, !1, md.projectionMatrix.elements); c.activeTexture(b.TEXTURE0); b.uniform1i(n, 0); ya = ta = 0; (Q = p.fog) ? (b.uniform3f(B, Q.color.r, Q.color.g, Q.color.b), Q.isFog ? (b.uniform1f(y, Q.near), b.uniform1f(w, Q.far), b.uniform1i(v, 1), ya = ta = 1) : Q.isFogExp2 && (b.uniform1f(x, Q.density), b.uniform1i(v, 2), ya = ta = 2)) : (b.uniform1i(v, 0), ya = ta = 0); Q = 0; for (var L = q.length; Q < L; Q++) { var E = q[Q]; E.modelViewMatrix.multiplyMatrices(md.matrixWorldInverse, E.matrixWorld); E.z = -E.modelViewMatrix.elements[14] } q.sort(H); var J = [], Td = []; Q = 0; for (L = q.length; Q < L; Q++) { E = q[Q]; var R = E.material; if (!1 !== R.visible) { E.onBeforeRender(a, p, md, void 0, R, void 0); b.uniform1f(G, R.alphaTest); b.uniformMatrix4fv(r, !1, E.modelViewMatrix.elements); E.matrixWorld.decompose(A, F, I); J[0] = I.x; J[1] = I.y; Td[0] = E.center.x - .5; Td[1] = E.center.y - .5; var nd = 0; p.fog && R.fog && (nd = ya); ta !== nd && (b.uniform1i(v, nd), ta = nd); null !== R.map ? (b.uniform2f(f, R.map.offset.x, R.map.offset.y), b.uniform2f(g, R.map.repeat.x, R.map.repeat.y)) : (b.uniform2f(f, 0, 0), b.uniform2f(g, 1, 1)); b.uniform1f(t, R.opacity); b.uniform3f(u, R.color.r, R.color.g, R.color.b); b.uniform1f(h, R.rotation); b.uniform2fv(l, Td); b.uniform2fv(m, J); c.setBlending(R.blending, R.blendEquation, R.blendSrc, R.blendDst, R.blendEquationAlpha, R.blendSrcAlpha, R.blendDstAlpha, R.premultipliedAlpha); c.buffers.depth.setTest(R.depthTest); c.buffers.depth.setMask(R.depthWrite); c.buffers.color.setMask(R.colorWrite); d.setTexture2D(R.map || z, 0); b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0); E.onAfterRender(a, p, md, void 0, R, void 0) } } c.enable(b.CULL_FACE); c.reset() } } } function Eg(a, b, c) { function d(b, c, d) { var e = new Uint8Array(4), f = a.createTexture(); a.bindTexture(b, f); a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST); a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST); for (b = 0; b < d; b++)a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e); return f } function e(b) { !0 !== w[b] && (a.enable(b), w[b] = !0) } function f(b) { !1 !== w[b] && (a.disable(b), w[b] = !1) } function g(b, d, g, h, l, m, n, u) { 0 !== b ? e(a.BLEND) : f(a.BLEND); if (5 !== b) { if (b !== K || u !== ya) switch (b) { case 2: u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)); break; case 3: u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)); break; case 4: u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)); break; default: u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) }z = Z = nb = C = H = P = null } else { l = l || d; m = m || g; n = n || h; if (d !== P || l !== nb) a.blendEquationSeparate(c.convert(d), c.convert(l)), P = d, nb = l; if (g !== H || h !== C || m !== Z || n !== z) a.blendFuncSeparate(c.convert(g), c.convert(h), c.convert(m), c.convert(n)), H = g, C = h, Z = m, z = n } K = b; ya = u } function h(b) { A !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), A = b) } function l(b) { 0 !== b ? (e(a.CULL_FACE), b !== E && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : f(a.CULL_FACE); E = b } function m(b, c, d) { if (b) { if (e(a.POLYGON_OFFSET_FILL), F !== c || I !== d) a.polygonOffset(c, d), F = c, I = d } else f(a.POLYGON_OFFSET_FILL) } function u(b) { void 0 === b && (b = a.TEXTURE0 + L - 1); M !== b && (a.activeTexture(b), M = b) } var n = new function () { var b = !1, c = new ea, d = null, e = new ea(0, 0, 0, 0); return { setMask: function (c) { d === c || b || (a.colorMask(c, c, c, c), d = c) }, setLocked: function (a) { b = a }, setClear: function (b, d, f, g, h) { !0 === h && (b *= g, d *= g, f *= g); c.set(b, d, f, g); !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c)) }, reset: function () { b = !1; d = null; e.set(-1, 0, 0, 0) } } }, t = new function () { var b = !1, c = null, d = null, g = null; return { setTest: function (b) { b ? e(a.DEPTH_TEST) : f(a.DEPTH_TEST) }, setMask: function (d) { c === d || b || (a.depthMask(d), c = d) }, setFunc: function (b) { if (d !== b) { if (b) switch (b) { case 0: a.depthFunc(a.NEVER); break; case 1: a.depthFunc(a.ALWAYS); break; case 2: a.depthFunc(a.LESS); break; case 3: a.depthFunc(a.LEQUAL); break; case 4: a.depthFunc(a.EQUAL); break; case 5: a.depthFunc(a.GEQUAL); break; case 6: a.depthFunc(a.GREATER); break; case 7: a.depthFunc(a.NOTEQUAL); break; default: a.depthFunc(a.LEQUAL) } else a.depthFunc(a.LEQUAL); d = b } }, setLocked: function (a) { b = a }, setClear: function (b) { g !== b && (a.clearDepth(b), g = b) }, reset: function () { b = !1; g = d = c = null } } }, r = new function () { var b = !1, c = null, d = null, g = null, h = null, l = null, m = null, n = null, u = null; return { setTest: function (b) { b ? e(a.STENCIL_TEST) : f(a.STENCIL_TEST) }, setMask: function (d) { c === d || b || (a.stencilMask(d), c = d) }, setFunc: function (b, c, e) { if (d !== b || g !== c || h !== e) a.stencilFunc(b, c, e), d = b, g = c, h = e }, setOp: function (b, c, d) { if (l !== b || m !== c || n !== d) a.stencilOp(b, c, d), l = b, m = c, n = d }, setLocked: function (a) { b = a }, setClear: function (b) { u !== b && (a.clearStencil(b), u = b) }, reset: function () { b = !1; u = n = m = l = h = g = d = c = null } } }, k = a.getParameter(a.MAX_VERTEX_ATTRIBS), v = new Uint8Array(k), p = new Uint8Array(k), y = new Uint8Array(k), w = {}, B = null, G = null, K = null, P = null, H = null, C = null, nb = null, Z = null, z = null, ya = !1, A = null, E = null, Q = null, F = null, I = null, L = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS), N = !1; k = 0; k = a.getParameter(a.VERSION); -1 !== k.indexOf("WebGL") ? (k = parseFloat(/^WebGL ([0-9])/.exec(k)[1]), N = 1 <= k) : -1 !== k.indexOf("OpenGL ES") && (k = parseFloat(/^OpenGL ES ([0-9])/.exec(k)[1]), N = 2 <= k); var M = null, O = {}, T = new ea, J = new ea, W = {}; W[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1); W[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6); n.setClear(0, 0, 0, 1); t.setClear(1); r.setClear(0); e(a.DEPTH_TEST); t.setFunc(3); h(!1); l(1); e(a.CULL_FACE); e(a.BLEND); g(1); return { buffers: { color: n, depth: t, stencil: r }, initAttributes: function () { for (var a = 0, b = v.length; a < b; a++)v[a] = 0 }, enableAttribute: function (c) { v[c] = 1; 0 === p[c] && (a.enableVertexAttribArray(c), p[c] = 1); 0 !== y[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), y[c] = 0) }, enableAttributeAndDivisor: function (c, d) { v[c] = 1; 0 === p[c] && (a.enableVertexAttribArray(c), p[c] = 1); y[c] !== d && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, d), y[c] = d) }, disableUnusedAttributes: function () { for (var b = 0, c = p.length; b !== c; ++b)p[b] !== v[b] && (a.disableVertexAttribArray(b), p[b] = 0) }, enable: e, disable: f, getCompressedTextureFormats: function () { if (null === B && (B = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc"))) for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++)B.push(c[d]); return B }, useProgram: function (b) { return G !== b ? (a.useProgram(b), G = b, !0) : !1 }, setBlending: g, setMaterial: function (b, c) { 2 === b.side ? f(a.CULL_FACE) : e(a.CULL_FACE); var d = 1 === b.side; c && (d = !d); h(d); !0 === b.transparent ? g(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha) : g(0); t.setFunc(b.depthFunc); t.setTest(b.depthTest); t.setMask(b.depthWrite); n.setMask(b.colorWrite); m(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits) }, setFlipSided: h, setCullFace: l, setLineWidth: function (b) { b !== Q && (N && a.lineWidth(b), Q = b) }, setPolygonOffset: m, setScissorTest: function (b) { b ? e(a.SCISSOR_TEST) : f(a.SCISSOR_TEST) }, activeTexture: u, bindTexture: function (b, c) { null === M && u(); var d = O[M]; void 0 === d && (d = { type: void 0, texture: void 0 }, O[M] = d); if (d.type !== b || d.texture !== c) a.bindTexture(b, c || W[b]), d.type = b, d.texture = c }, compressedTexImage2D: function () { try { a.compressedTexImage2D.apply(a, arguments) } catch (R) { console.error("THREE.WebGLState:", R) } }, texImage2D: function () { try { a.texImage2D.apply(a, arguments) } catch (R) { console.error("THREE.WebGLState:", R) } }, scissor: function (b) { !1 === T.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), T.copy(b)) }, viewport: function (b) { !1 === J.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), J.copy(b)) }, reset: function () { for (var b = 0; b < p.length; b++)1 === p[b] && (a.disableVertexAttribArray(b), p[b] = 0); w = {}; M = B = null; O = {}; E = A = K = G = null; n.reset(); t.reset(); r.reset() } } } function Fg(a, b, c, d, e, f, g) {
        function h(a, b) { if (a.width > b || a.height > b) { if ("data" in a) { console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + a.width + "x" + a.height + ")."); return } b /= Math.max(a.width, a.height); var c = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); c.width = Math.floor(a.width * b); c.height = Math.floor(a.height * b); c.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, c.width, c.height); console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + c.width + "x" + c.height, a); return c } return a } function l(a) { return S.isPowerOfTwo(a.width) && S.isPowerOfTwo(a.height) } function m(a, b) { return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter } function u(b, c, e, f) { a.generateMipmap(b); d.get(c).__maxMipLevel = Math.log2(Math.max(e, f)) } function n(b) { return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR } function t(b) { b = b.target; b.removeEventListener("dispose", t); a: { var c = d.get(b); if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube); else { if (void 0 === c.__webglInit) break a; a.deleteTexture(c.__webglTexture) } d.remove(b) } b.isVideoTexture && delete B[b.id]; g.memory.textures-- } function k(b) { b = b.target; b.removeEventListener("dispose", k); var c = d.get(b), e = d.get(b.texture); if (b) { void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture); b.depthTexture && b.depthTexture.dispose(); if (b.isWebGLRenderTargetCube) for (e = 0; 6 > e; e++)a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]); else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer); d.remove(b.texture); d.remove(b) } g.memory.textures-- } function q(b, n) {
            var k = d.get(b); if (b.isVideoTexture) { var r = b.id, q = g.render.frame; B[r] !== q && (B[r] = q, b.update()) } if (0 < b.version && k.__version !== b.version) if (r = b.image, void 0 === r) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", b); else if (!1 === r.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b); else {
                void 0 === k.__webglInit && (k.__webglInit = !0, b.addEventListener("dispose", t), k.__webglTexture = a.createTexture(), g.memory.textures++); c.activeTexture(a.TEXTURE0 + n); c.bindTexture(a.TEXTURE_2D, k.__webglTexture); a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY); a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha); a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment); n = h(b.image, e.maxTextureSize); (1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === l(n) && (n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof ImageBitmap) && (void 0 === G && (G = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), G.width = S.floorPowerOfTwo(n.width), G.height = S.floorPowerOfTwo(n.height), G.getContext("2d").drawImage(n, 0, 0, G.width, G.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + n.width + "x" + n.height + "). Resized to " +
                    G.width + "x" + G.height, n), n = G); r = l(n); q = f.convert(b.format); var p = f.convert(b.type); v(a.TEXTURE_2D, b, r); var x = b.mipmaps; if (b.isDepthTexture) { var K = a.DEPTH_COMPONENT; if (1015 === b.type) { if (!w) throw Error("Float Depth Texture only supported in WebGL2.0"); K = a.DEPTH_COMPONENT32F } else w && (K = a.DEPTH_COMPONENT16); 1026 === b.format && K === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), b.type = 1012, p = f.convert(b.type)); 1027 === b.format && (K = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, p = f.convert(b.type))); c.texImage2D(a.TEXTURE_2D, 0, K, n.width, n.height, 0, q, p, null) } else if (b.isDataTexture) if (0 < x.length && r) { for (var P = 0, y = x.length; P < y; P++)K = x[P], c.texImage2D(a.TEXTURE_2D, P, q, K.width, K.height, 0, q, p, K.data); b.generateMipmaps = !1; k.__maxMipLevel = x.length - 1 } else c.texImage2D(a.TEXTURE_2D, 0, q, n.width, n.height, 0, q, p, n.data), k.__maxMipLevel = 0; else if (b.isCompressedTexture) { P = 0; for (y = x.length; P < y; P++)K = x[P], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(q) ? c.compressedTexImage2D(a.TEXTURE_2D, P, q, K.width, K.height, 0, K.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, P, q, K.width, K.height, 0, q, p, K.data); k.__maxMipLevel = x.length - 1 } else if (0 < x.length && r) { P = 0; for (y = x.length; P < y; P++)K = x[P], c.texImage2D(a.TEXTURE_2D, P, q, q, p, K); b.generateMipmaps = !1; k.__maxMipLevel = x.length - 1 } else c.texImage2D(a.TEXTURE_2D, 0, q, q, p, n), k.__maxMipLevel = 0; m(b, r) && u(a.TEXTURE_2D, b, n.width, n.height); k.__version = b.version; if (b.onUpdate) b.onUpdate(b); return
            } c.activeTexture(a.TEXTURE0 + n); c.bindTexture(a.TEXTURE_2D, k.__webglTexture)
        } function v(c, g, h) { h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f.convert(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f.convert(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f.convert(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f.convert(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, n(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, n(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", g)); !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === b.get("OES_texture_half_float_linear") || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy) } function p(b, e, g, h) { var l = f.convert(e.texture.format), m = f.convert(e.texture.type); c.texImage2D(h, 0, l, e.width, e.height, 0, l, m, null); a.bindFramebuffer(a.FRAMEBUFFER, b); a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0); a.bindFramebuffer(a.FRAMEBUFFER, null) } function y(b, c) { a.bindRenderbuffer(a.RENDERBUFFER, b); c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height); a.bindRenderbuffer(a.RENDERBUFFER, null) } var w = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext, B = {}, G; this.setTexture2D = q; this.setTextureCube = function (b, n) {
            var k = d.get(b); if (6 === b.image.length) if (0 < b.version && k.__version !== b.version) {
                k.__image__webglTextureCube || (b.addEventListener("dispose", t), k.__image__webglTextureCube = a.createTexture(), g.memory.textures++); c.activeTexture(a.TEXTURE0 +
                    n); c.bindTexture(a.TEXTURE_CUBE_MAP, k.__image__webglTextureCube); a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY); n = b && b.isCompressedTexture; for (var r = b.image[0] && b.image[0].isDataTexture, q = [], p = 0; 6 > p; p++)q[p] = n || r ? r ? b.image[p].image : b.image[p] : h(b.image[p], e.maxCubemapSize); var x = q[0], w = l(x), K = f.convert(b.format), y = f.convert(b.type); v(a.TEXTURE_CUBE_MAP, b, w); for (p = 0; 6 > p; p++)if (n) for (var B, G = q[p].mipmaps, P = 0, C = G.length; P < C; P++)B = G[P], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(K) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, P, K, B.width, B.height, 0, B.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, P, K, B.width, B.height, 0, K, y, B.data); else r ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, K, q[p].width, q[p].height, 0, K, y, q[p].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, K, K, y, q[p]); k.__maxMipLevel = n ? G.length - 1 : 0; m(b, w) && u(a.TEXTURE_CUBE_MAP, b, x.width, x.height); k.__version = b.version; if (b.onUpdate) b.onUpdate(b)
            } else c.activeTexture(a.TEXTURE0 + n), c.bindTexture(a.TEXTURE_CUBE_MAP, k.__image__webglTextureCube)
        }; this.setTextureCubeDynamic = function (b, e) { c.activeTexture(a.TEXTURE0 + e); c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture) }; this.setupRenderTarget = function (b) { var e = d.get(b), f = d.get(b.texture); b.addEventListener("dispose", k); f.__webglTexture = a.createTexture(); g.memory.textures++; var h = !0 === b.isWebGLRenderTargetCube, n = l(b); if (h) { e.__webglFramebuffer = []; for (var t = 0; 6 > t; t++)e.__webglFramebuffer[t] = a.createFramebuffer() } else e.__webglFramebuffer = a.createFramebuffer(); if (h) { c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture); v(a.TEXTURE_CUBE_MAP, b.texture, n); for (t = 0; 6 > t; t++)p(e.__webglFramebuffer[t], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + t); m(b.texture, n) && u(a.TEXTURE_CUBE_MAP, b.texture, b.width, b.height); c.bindTexture(a.TEXTURE_CUBE_MAP, null) } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), v(a.TEXTURE_2D, b.texture, n), p(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), m(b.texture, n) && u(a.TEXTURE_2D, b.texture, b.width, b.height), c.bindTexture(a.TEXTURE_2D, null); if (b.depthBuffer) { e = d.get(b); f = !0 === b.isWebGLRenderTargetCube; if (b.depthTexture) { if (f) throw Error("target.depthTexture not supported in Cube render targets"); if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported"); a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer); if (!b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0); q(b.depthTexture, 0); e = d.get(b.depthTexture).__webglTexture; if (1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0); else if (1027 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0); else throw Error("Unknown depthTexture format"); } else if (f) for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++)a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), y(e.__webglDepthbuffer[f], b); else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), y(e.__webglDepthbuffer, b); a.bindFramebuffer(a.FRAMEBUFFER, null) } }; this.updateRenderTargetMipmap = function (b) { var e = b.texture, f = l(b); if (m(e, f)) { f = b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D; var g = d.get(e).__webglTexture; c.bindTexture(f, g); u(f, e, b.width, b.height); c.bindTexture(f, null) } }
    } function Ve(a, b) { return { convert: function (c) { if (1E3 === c) return a.REPEAT; if (1001 === c) return a.CLAMP_TO_EDGE; if (1002 === c) return a.MIRRORED_REPEAT; if (1003 === c) return a.NEAREST; if (1004 === c) return a.NEAREST_MIPMAP_NEAREST; if (1005 === c) return a.NEAREST_MIPMAP_LINEAR; if (1006 === c) return a.LINEAR; if (1007 === c) return a.LINEAR_MIPMAP_NEAREST; if (1008 === c) return a.LINEAR_MIPMAP_LINEAR; if (1009 === c) return a.UNSIGNED_BYTE; if (1017 === c) return a.UNSIGNED_SHORT_4_4_4_4; if (1018 === c) return a.UNSIGNED_SHORT_5_5_5_1; if (1019 === c) return a.UNSIGNED_SHORT_5_6_5; if (1010 === c) return a.BYTE; if (1011 === c) return a.SHORT; if (1012 === c) return a.UNSIGNED_SHORT; if (1013 === c) return a.INT; if (1014 === c) return a.UNSIGNED_INT; if (1015 === c) return a.FLOAT; if (1016 === c) { var d = b.get("OES_texture_half_float"); if (null !== d) return d.HALF_FLOAT_OES } if (1021 === c) return a.ALPHA; if (1022 === c) return a.RGB; if (1023 === c) return a.RGBA; if (1024 === c) return a.LUMINANCE; if (1025 === c) return a.LUMINANCE_ALPHA; if (1026 === c) return a.DEPTH_COMPONENT; if (1027 === c) return a.DEPTH_STENCIL; if (100 === c) return a.FUNC_ADD; if (101 === c) return a.FUNC_SUBTRACT; if (102 === c) return a.FUNC_REVERSE_SUBTRACT; if (200 === c) return a.ZERO; if (201 === c) return a.ONE; if (202 === c) return a.SRC_COLOR; if (203 === c) return a.ONE_MINUS_SRC_COLOR; if (204 === c) return a.SRC_ALPHA; if (205 === c) return a.ONE_MINUS_SRC_ALPHA; if (206 === c) return a.DST_ALPHA; if (207 === c) return a.ONE_MINUS_DST_ALPHA; if (208 === c) return a.DST_COLOR; if (209 === c) return a.ONE_MINUS_DST_COLOR; if (210 === c) return a.SRC_ALPHA_SATURATE; if (33776 === c || 33777 === c || 33778 === c || 33779 === c) if (d = b.get("WEBGL_compressed_texture_s3tc"), null !== d) { if (33776 === c) return d.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === c) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === c) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === c) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === c || 35841 === c || 35842 === c || 35843 === c) if (d = b.get("WEBGL_compressed_texture_pvrtc"), null !== d) { if (35840 === c) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === c) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === c) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === c) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === c && (d = b.get("WEBGL_compressed_texture_etc1"), null !== d)) return d.COMPRESSED_RGB_ETC1_WEBGL; if (37808 === c || 37809 === c || 37810 === c || 37811 === c || 37812 === c || 37813 === c || 37814 === c || 37815 === c || 37816 === c || 37817 === c || 37818 === c || 37819 === c || 37820 === c || 37821 === c) if (d = b.get("WEBGL_compressed_texture_astc"), null !== d) return c; if (103 === c || 104 === c) if (d = b.get("EXT_blend_minmax"), null !== d) { if (103 === c) return d.MIN_EXT; if (104 === c) return d.MAX_EXT } return 1020 === c && (d = b.get("WEBGL_depth_texture"), null !== d) ? d.UNSIGNED_INT_24_8_WEBGL : 0 } } } function la(a, b, c, d) { Qa.call(this); this.type = "PerspectiveCamera"; this.fov = void 0 !== a ? a : 50; this.zoom = 1; this.near = void 0 !== c ? c : .1; this.far = void 0 !== d ? d : 2E3; this.focus = 10; this.aspect = void 0 !== b ? b : 1; this.view = null; this.filmGauge = 35; this.filmOffset = 0; this.updateProjectionMatrix() } function qd(a) { la.call(this); this.cameras = a || [] } function We(a) { function b() { if (null !== d && d.isPresenting) { var b = d.getEyeParameters("left"), e = b.renderWidth; b = b.renderHeight; v = a.getPixelRatio(); q = a.getSize(); a.setDrawingBufferSize(2 * e, b, 1) } else c.enabled && a.setDrawingBufferSize(q.width, q.height, v) } var c = this, d = null, e = null, f = null, g = new M, h = new M; "undefined" !== typeof window && "VRFrameData" in window && (e = new window.VRFrameData); var l = new M, m = new ja, u = new p, n = new la; n.bounds = new ea(0, 0, .5, 1); n.layers.enable(1); var t = new la; t.bounds = new ea(.5, 0, .5, 1); t.layers.enable(2); var k = new qd([n, t]); k.layers.enable(1); k.layers.enable(2); var q, v; "undefined" !== typeof window && window.addEventListener("vrdisplaypresentchange", b, !1); this.enabled = !1; this.userHeight = 1.6; this.getDevice = function () { return d }; this.setDevice = function (a) { void 0 !== a && (d = a) }; this.setPoseTarget = function (a) { void 0 !== a && (f = a) }; this.getCamera = function (a) { if (null === d) return a; d.depthNear = a.near; d.depthFar = a.far; d.getFrameData(e); var b = d.stageParameters; b ? g.fromArray(b.sittingToStandingTransform) : g.makeTranslation(0, c.userHeight, 0); b = e.pose; var r = null !== f ? f : a; r.matrix.copy(g); r.matrix.decompose(r.position, r.quaternion, r.scale); null !== b.orientation && (m.fromArray(b.orientation), r.quaternion.multiply(m)); null !== b.position && (m.setFromRotationMatrix(g), u.fromArray(b.position), u.applyQuaternion(m), r.position.add(u)); r.updateMatrixWorld(); if (!1 === d.isPresenting) return a; n.near = a.near; t.near = a.near; n.far = a.far; t.far = a.far; k.matrixWorld.copy(a.matrixWorld); k.matrixWorldInverse.copy(a.matrixWorldInverse); n.matrixWorldInverse.fromArray(e.leftViewMatrix); t.matrixWorldInverse.fromArray(e.rightViewMatrix); h.getInverse(g); n.matrixWorldInverse.multiply(h); t.matrixWorldInverse.multiply(h); a = r.parent; null !== a && (l.getInverse(a.matrixWorld), n.matrixWorldInverse.multiply(l), t.matrixWorldInverse.multiply(l)); n.matrixWorld.getInverse(n.matrixWorldInverse); t.matrixWorld.getInverse(t.matrixWorldInverse); n.projectionMatrix.fromArray(e.leftProjectionMatrix); t.projectionMatrix.fromArray(e.rightProjectionMatrix); k.projectionMatrix.copy(n.projectionMatrix); a = d.getLayers(); a.length && (a = a[0], null !== a.leftBounds && 4 === a.leftBounds.length && n.bounds.fromArray(a.leftBounds), null !== a.rightBounds && 4 === a.rightBounds.length && t.bounds.fromArray(a.rightBounds)); return k }; this.getStandingMatrix = function () { return g }; this.submitFrame = function () { d && d.isPresenting && d.submitFrame() }; this.dispose = function () { "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", b) } } function Xd(a) {
        function b() { ka = new Hf(D); ka.get("WEBGL_depth_texture"); ka.get("OES_texture_float"); ka.get("OES_texture_float_linear"); ka.get("OES_texture_half_float"); ka.get("OES_texture_half_float_linear"); ka.get("OES_standard_derivatives"); ka.get("OES_element_index_uint"); ka.get("ANGLE_instanced_arrays"); ia = new Ve(D, ka); Ra = new Ff(D, ka, a); ba = new Eg(D, ka, ia); ba.scissor(V.copy(ca).multiplyScalar(R)); ba.viewport(ob.copy(Y).multiplyScalar(R)); da = new Kf(D); X = new tg; fa = new Fg(D, ka, ba, X, Ra, ia, da); qa = new yf(D); ra = new If(D, qa, da); sa = new Nf(ra, da); wa = new Mf(D); oa = new sg(A, ka, Ra); ua = new xg; pa = new Cg; ma = new Df(A, ba, ra, P); xa = new Ef(D, ka, da); za = new Jf(D, ka, da); Aa = new Dg(A, D, ba, fa, Ra); da.programs = oa.programs; A.context = D; A.capabilities = Ra; A.extensions = ka; A.properties = X; A.renderLists = ua; A.state = ba; A.info = da } function c(a) { a.preventDefault(); console.log("THREE.WebGLRenderer: Context Lost."); E = !0 } function d() { console.log("THREE.WebGLRenderer: Context Restored."); E = !1; b() } function e(a) { a = a.target; a.removeEventListener("dispose", e); f(a); X.remove(a) } function f(a) { var b = X.get(a).program; a.program = void 0; void 0 !== b && oa.releaseProgram(b) } function g(a, b, c) { a.render(function (a) { A.renderBufferImmediate(a, b, c) }) } function h() { var a = na.getDevice(); a && a.isPresenting ? a.requestAnimationFrame(l) : window.requestAnimationFrame(l) } function l(a) { !1 !== va && (Ba(a), h()) } function m(a, b, c) { if (!1 !== a.visible) { if (a.layers.test(b.layers)) if (a.isLight) Z.pushLight(a), a.castShadow && Z.pushShadow(a); else if (a.isSprite) a.frustumCulled && !ha.intersectsSprite(a) || Z.pushSprite(a); else if (a.isImmediateRenderObject) c && Nb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(pd), z.push(a, null, a.material, Nb.z, null); else if (a.isMesh || a.isLine || a.isPoints) if (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || ha.intersectsObject(a)) { c && Nb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(pd); var d = sa.update(a), e = a.material; if (Array.isArray(e)) for (var f = d.groups, g = 0, h = f.length; g < h; g++) { var l = f[g], n = e[l.materialIndex]; n && n.visible && z.push(a, d, n, Nb.z, l) } else e.visible && z.push(a, d, e, Nb.z, null) } a = a.children; g = 0; for (h = a.length; g < h; g++)m(a[g], b, c) } } function u(a, b, c, d) { for (var e = 0, f = a.length; e < f; e++) { var g = a[e], h = g.object, l = g.geometry, m = void 0 === d ? g.material : d; g = g.group; if (c.isArrayCamera) { T = c; for (var u = c.cameras, t = 0, k = u.length; t < k; t++) { var r = u[t]; if (h.layers.test(r.layers)) { var q = r.bounds; ba.viewport(ob.set(q.x * J, q.y * W, q.z * J, q.w * W).multiplyScalar(R)); n(h, b, r, l, m, g) } } } else T = null, n(h, b, c, l, m, g) } } function n(a, b, c, d, e, f) { a.onBeforeRender(A, b, c, d, e, f); Z = pa.get(b, T || c); a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld); a.normalMatrix.getNormalMatrix(a.modelViewMatrix); if (a.isImmediateRenderObject) { var h = a.isMesh && 0 > a.matrixWorld.determinant(); ba.setMaterial(e, h); h = k(c, b.fog, e, a); N = ""; g(a, h, e) } else A.renderBufferDirect(c, b.fog, d, e, a, f); a.onAfterRender(A, b, c, d, e, f); Z = pa.get(b, T || c) } function t(a, b, c) { var d = X.get(a), g = Z.state.lights; c = oa.getParameters(a, g.state, Z.state.shadowsArray, b, Ga.numPlanes, Ga.numIntersection, c); var h = oa.getProgramCode(a, c), l = d.program, m = !0; if (void 0 === l) a.addEventListener("dispose", e); else if (l.code !== h) f(a); else { if (d.lightsHash !== g.state.hash) X.update(a, "lightsHash", g.state.hash); else if (void 0 !== c.shaderID) return; m = !1 } m && (c.shaderID ? (l = rb[c.shaderID], d.shader = { name: a.type, uniforms: Da.clone(l.uniforms), vertexShader: l.vertexShader, fragmentShader: l.fragmentShader }) : d.shader = { name: a.type, uniforms: a.uniforms, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader }, a.onBeforeCompile(d.shader, A), l = oa.acquireProgram(a, d.shader, c, h), d.program = l, a.program = l); c = l.getAttributes(); if (a.morphTargets) for (h = a.numSupportedMorphTargets = 0; h < A.maxMorphTargets; h++)0 <= c["morphTarget" + h] && a.numSupportedMorphTargets++; if (a.morphNormals) for (h = a.numSupportedMorphNormals = 0; h < A.maxMorphNormals; h++)0 <= c["morphNormal" + h] && a.numSupportedMorphNormals++; c = d.shader.uniforms; if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = Ga.numPlanes, d.numIntersection = Ga.numIntersection, c.clippingPlanes = Ga.uniform; d.fog = b; d.lightsHash = g.state.hash; a.lights && (c.ambientLightColor.value = g.state.ambient, c.directionalLights.value = g.state.directional, c.spotLights.value = g.state.spot, c.rectAreaLights.value = g.state.rectArea, c.pointLights.value = g.state.point, c.hemisphereLights.value = g.state.hemi, c.directionalShadowMap.value = g.state.directionalShadowMap, c.directionalShadowMatrix.value = g.state.directionalShadowMatrix, c.spotShadowMap.value = g.state.spotShadowMap, c.spotShadowMatrix.value = g.state.spotShadowMatrix, c.pointShadowMap.value = g.state.pointShadowMap, c.pointShadowMatrix.value = g.state.pointShadowMatrix); a = d.program.getUniforms(); a = bb.seqWithValue(a.seq, c); d.uniformsList = a } function k(a, b, c, d) { aa = 0; var e = X.get(c), f = Z.state.lights; od && (la || a !== O) && Ga.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === O && c.id === Q); !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : c.lights && e.lightsHash !== f.state.hash ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes === Ga.numPlanes && e.numIntersection === Ga.numIntersection || (c.needsUpdate = !0)); c.needsUpdate && (t(c, b, d), c.needsUpdate = !1); var g = !1, h = !1, l = !1; f = e.program; var m = f.getUniforms(), n = e.shader.uniforms; ba.useProgram(f.program) && (l = h = g = !0); c.id !== Q && (Q = c.id, h = !0); if (g || a !== O) { m.setValue(D, "projectionMatrix", a.projectionMatrix); Ra.logarithmicDepthBuffer && m.setValue(D, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)); O !== (T || a) && (O = T || a, l = h = !0); if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) g = m.map.cameraPosition, void 0 !== g && g.setValue(D, Nb.setFromMatrixPosition(a.matrixWorld)); (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && m.setValue(D, "viewMatrix", a.matrixWorldInverse) } if (c.skinning && (m.setOptional(D, d, "bindMatrix"), m.setOptional(D, d, "bindMatrixInverse"), a = d.skeleton)) if (g = a.bones, Ra.floatVertexTextures) { if (void 0 === a.boneTexture) { g = Math.sqrt(4 * g.length); g = S.ceilPowerOfTwo(g); g = Math.max(g, 4); var u = new Float32Array(g * g * 4); u.set(a.boneMatrices); var k = new ib(u, g, g, 1023, 1015); k.needsUpdate = !0; a.boneMatrices = u; a.boneTexture = k; a.boneTextureSize = g } m.setValue(D, "boneTexture", a.boneTexture); m.setValue(D, "boneTextureSize", a.boneTextureSize) } else m.setOptional(D, a, "boneMatrices"); h && (m.setValue(D, "toneMappingExposure", A.toneMappingExposure), m.setValue(D, "toneMappingWhitePoint", A.toneMappingWhitePoint), c.lights && (h = l, n.ambientLightColor.needsUpdate = h, n.directionalLights.needsUpdate = h, n.pointLights.needsUpdate = h, n.spotLights.needsUpdate = h, n.rectAreaLights.needsUpdate = h, n.hemisphereLights.needsUpdate = h), b && c.fog && (n.fogColor.value = b.color, b.isFog ? (n.fogNear.value = b.near, n.fogFar.value = b.far) : b.isFogExp2 && (n.fogDensity.value = b.density)), c.isMeshBasicMaterial ? q(n, c) : c.isMeshLambertMaterial ? (q(n, c), c.emissiveMap && (n.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (q(n, c), c.isMeshToonMaterial ? (v(n, c), c.gradientMap && (n.gradientMap.value = c.gradientMap)) : v(n, c)) : c.isMeshStandardMaterial ? (q(n, c), c.isMeshPhysicalMaterial && (n.clearCoat.value = c.clearCoat, n.clearCoatRoughness.value = c.clearCoatRoughness), n.roughness.value = c.roughness, n.metalness.value = c.metalness, c.roughnessMap && (n.roughnessMap.value = c.roughnessMap), c.metalnessMap && (n.metalnessMap.value = c.metalnessMap), c.emissiveMap && (n.emissiveMap.value = c.emissiveMap), c.bumpMap && (n.bumpMap.value = c.bumpMap, n.bumpScale.value = c.bumpScale), c.normalMap && (n.normalMap.value = c.normalMap, n.normalScale.value.copy(c.normalScale)), c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias), c.envMap && (n.envMapIntensity.value = c.envMapIntensity)) : c.isMeshDepthMaterial ? (q(n, c), c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (q(n, c), c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias), n.referencePosition.value.copy(c.referencePosition), n.nearDistance.value = c.nearDistance, n.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (q(n, c), c.bumpMap && (n.bumpMap.value = c.bumpMap, n.bumpScale.value = c.bumpScale), c.normalMap && (n.normalMap.value = c.normalMap, n.normalScale.value.copy(c.normalScale)), c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ? (n.diffuse.value = c.color, n.opacity.value = c.opacity, c.isLineDashedMaterial && (n.dashSize.value = c.dashSize, n.totalSize.value = c.dashSize + c.gapSize, n.scale.value = c.scale)) : c.isPointsMaterial ? (n.diffuse.value = c.color, n.opacity.value = c.opacity, n.size.value = c.size * R, n.scale.value = .5 * W, n.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && (b = c.map.offset, h = c.map.repeat, l = c.map.center, c.map.matrix.setUvTransform(b.x, b.y, h.x, h.y, c.map.rotation, l.x, l.y)), n.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (n.color.value = c.color, n.opacity.value = c.opacity), void 0 !== n.ltc_1 && (n.ltc_1.value = L.LTC_1), void 0 !== n.ltc_2 && (n.ltc_2.value = L.LTC_2), bb.upload(D, e.uniformsList, n, A)); c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (bb.upload(D, e.uniformsList, n, A), c.uniformsNeedUpdate = !1); m.setValue(D, "modelViewMatrix", d.modelViewMatrix); m.setValue(D, "normalMatrix", d.normalMatrix); m.setValue(D, "modelMatrix", d.matrixWorld); return f } function q(a, b) { a.opacity.value = b.opacity; b.color && (a.diffuse.value = b.color); b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity); b.map && (a.map.value = b.map); b.alphaMap && (a.alphaMap.value = b.alphaMap); b.specularMap && (a.specularMap.value = b.specularMap); b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap && b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value = X.get(b.envMap).__maxMipLevel); b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity); b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity); if (b.map) var c = b.map; else b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap); if (void 0 !== c) { c.isWebGLRenderTarget && (c = c.texture); if (!0 === c.matrixAutoUpdate) { b = c.offset; var d = c.repeat, e = c.center; c.matrix.setUvTransform(b.x, b.y, d.x, d.y, c.rotation, e.x, e.y) } a.uvTransform.value.copy(c.matrix) } } function v(a, b) { a.specular.value = b.specular; a.shininess.value = Math.max(b.shininess, 1E-4); b.emissiveMap && (a.emissiveMap.value = b.emissiveMap); b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale); b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)); b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias) } console.log("THREE.WebGLRenderer", "91"); a = a || {}; var x = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), y = void 0 !== a.context ? a.context : null, w = void 0 !== a.alpha ? a.alpha : !1, B = void 0 !== a.depth ? a.depth : !0, G = void 0 !== a.stencil ? a.stencil : !0, K = void 0 !== a.antialias ? a.antialias : !1, P = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, H = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, C = void 0 !== a.powerPreference ? a.powerPreference : "default", z = null, Z = null; this.domElement = x; this.context = null; this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0; this.clippingPlanes = []; this.localClippingEnabled = !1; this.gammaFactor = 2; this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1; this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1; this.maxMorphTargets = 8; this.maxMorphNormals = 4; var A = this, E = !1, F = null, I = null, Q = -1, N = "", O = null, T = null, ob = new ea, V = new ea, U = null, aa = 0, J = x.width, W = x.height, R = 1, Y = new ea(0, 0, J, W), ca = new ea(0, 0, J, W), ja = !1, ha = new ld, Ga = new Gf, od = !1, la = !1, pd = new M, Nb = new p; try { w = { alpha: w, depth: B, stencil: G, antialias: K, premultipliedAlpha: P, preserveDrawingBuffer: H, powerPreference: C }; x.addEventListener("webglcontextlost", c, !1); x.addEventListener("webglcontextrestored", d, !1); var D = y || x.getContext("webgl", w) || x.getContext("experimental-webgl", w); if (null === D) { if (null !== x.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes."); throw Error("Error creating WebGL context."); } void 0 === D.getShaderPrecisionFormat && (D.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (Gg) {
            console.error("THREE.WebGLRenderer: " +
                Gg.message)
        } var ka, Ra, ba, da, X, fa, qa, ra, sa, oa, ua, pa, ma, wa, xa, za, Aa, ia; b(); var na = new We(A); this.vr = na; var Ca = new Ue(A, sa, Ra.maxTextureSize); this.shadowMap = Ca; this.getContext = function () { return D }; this.getContextAttributes = function () { return D.getContextAttributes() }; this.forceContextLoss = function () { var a = ka.get("WEBGL_lose_context"); a && a.loseContext() }; this.forceContextRestore = function () { var a = ka.get("WEBGL_lose_context"); a && a.restoreContext() }; this.getPixelRatio = function () { return R }; this.setPixelRatio = function (a) { void 0 !== a && (R = a, this.setSize(J, W, !1)) }; this.getSize = function () { return { width: J, height: W } }; this.setSize = function (a, b, c) { var d = na.getDevice(); d && d.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (J = a, W = b, x.width = a * R, x.height = b * R, !1 !== c && (x.style.width = a + "px", x.style.height = b + "px"), this.setViewport(0, 0, a, b)) }; this.getDrawingBufferSize = function () { return { width: J * R, height: W * R } }; this.setDrawingBufferSize = function (a, b, c) { J = a; W = b; R = c; x.width = a * c; x.height = b * c; this.setViewport(0, 0, a, b) }; this.getCurrentViewport = function () { return ob }; this.setViewport = function (a, b, c, d) { Y.set(a, W - b - d, c, d); ba.viewport(ob.copy(Y).multiplyScalar(R)) }; this.setScissor = function (a, b, c, d) { ca.set(a, W - b - d, c, d); ba.scissor(V.copy(ca).multiplyScalar(R)) }; this.setScissorTest = function (a) { ba.setScissorTest(ja = a) }; this.getClearColor = function () { return ma.getClearColor() }; this.setClearColor = function () { ma.setClearColor.apply(ma, arguments) }; this.getClearAlpha = function () { return ma.getClearAlpha() }; this.setClearAlpha = function () { ma.setClearAlpha.apply(ma, arguments) }; this.clear = function (a, b, c) { var d = 0; if (void 0 === a || a) d |= D.COLOR_BUFFER_BIT; if (void 0 === b || b) d |= D.DEPTH_BUFFER_BIT; if (void 0 === c || c) d |= D.STENCIL_BUFFER_BIT; D.clear(d) }; this.clearColor = function () { this.clear(!0, !1, !1) }; this.clearDepth = function () { this.clear(!1, !0, !1) }; this.clearStencil = function () { this.clear(!1, !1, !0) }; this.clearTarget = function (a, b, c, d) { this.setRenderTarget(a); this.clear(b, c, d) }; this.dispose = function () { x.removeEventListener("webglcontextlost", c, !1); x.removeEventListener("webglcontextrestored", d, !1); ua.dispose(); pa.dispose(); X.dispose(); sa.dispose(); na.dispose(); va = !1 }; this.renderBufferImmediate = function (a, b, c) { ba.initAttributes(); var d = X.get(a); a.hasPositions && !d.position && (d.position = D.createBuffer()); a.hasNormals && !d.normal && (d.normal = D.createBuffer()); a.hasUvs && !d.uv && (d.uv = D.createBuffer()); a.hasColors && !d.color && (d.color = D.createBuffer()); b = b.getAttributes(); a.hasPositions && (D.bindBuffer(D.ARRAY_BUFFER, d.position), D.bufferData(D.ARRAY_BUFFER, a.positionArray, D.DYNAMIC_DRAW), ba.enableAttribute(b.position), D.vertexAttribPointer(b.position, 3, D.FLOAT, !1, 0, 0)); if (a.hasNormals) { D.bindBuffer(D.ARRAY_BUFFER, d.normal); if (!c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && !0 === c.flatShading) for (var e = 0, f = 3 * a.count; e < f; e += 9) { var g = a.normalArray, h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3, l = (g[e + 1] + g[e + 4] + g[e + 7]) / 3, m = (g[e + 2] + g[e + 5] + g[e + 8]) / 3; g[e + 0] = h; g[e + 1] = l; g[e + 2] = m; g[e + 3] = h; g[e + 4] = l; g[e + 5] = m; g[e + 6] = h; g[e + 7] = l; g[e + 8] = m } D.bufferData(D.ARRAY_BUFFER, a.normalArray, D.DYNAMIC_DRAW); ba.enableAttribute(b.normal); D.vertexAttribPointer(b.normal, 3, D.FLOAT, !1, 0, 0) } a.hasUvs && c.map && (D.bindBuffer(D.ARRAY_BUFFER, d.uv), D.bufferData(D.ARRAY_BUFFER, a.uvArray, D.DYNAMIC_DRAW), ba.enableAttribute(b.uv), D.vertexAttribPointer(b.uv, 2, D.FLOAT, !1, 0, 0)); a.hasColors && 0 !== c.vertexColors && (D.bindBuffer(D.ARRAY_BUFFER, d.color), D.bufferData(D.ARRAY_BUFFER, a.colorArray, D.DYNAMIC_DRAW), ba.enableAttribute(b.color), D.vertexAttribPointer(b.color, 3, D.FLOAT, !1, 0, 0)); ba.disableUnusedAttributes(); D.drawArrays(D.TRIANGLES, 0, a.count); a.count = 0 }; this.renderBufferDirect = function (a, b, c, d, e, f) { var g = e.isMesh && 0 > e.matrixWorld.determinant(); ba.setMaterial(d, g); var h = k(a, b, d, e); a = c.id + "_" + h.id + "_" + (!0 === d.wireframe); var l = !1; a !== N && (N = a, l = !0); e.morphTargetInfluences && (wa.update(e, c, d, h), l = !0); g = c.index; var m = c.attributes.position; b = 1; !0 === d.wireframe && (g = ra.getWireframeAttribute(c), b = 2); a = xa; if (null !== g) { var n = qa.get(g); a = za; a.setIndex(n) } if (l) { l = void 0; if (c && c.isInstancedBufferGeometry && null === ka.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else { void 0 === l && (l = 0); ba.initAttributes(); var u = c.attributes; h = h.getAttributes(); var t = d.defaultAttributeValues; for (K in h) { var r = h[K]; if (0 <= r) { var q = u[K]; if (void 0 !== q) { var p = q.normalized, v = q.itemSize, x = qa.get(q); if (void 0 !== x) { var w = x.buffer, B = x.type; x = x.bytesPerElement; if (q.isInterleavedBufferAttribute) { var y = q.data, G = y.stride; q = q.offset; y && y.isInstancedInterleavedBuffer ? (ba.enableAttributeAndDivisor(r, y.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = y.meshPerAttribute * y.count)) : ba.enableAttribute(r); D.bindBuffer(D.ARRAY_BUFFER, w); D.vertexAttribPointer(r, v, B, p, G * x, (l * G + q) * x) } else q.isInstancedBufferAttribute ? (ba.enableAttributeAndDivisor(r, q.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = q.meshPerAttribute * q.count)) : ba.enableAttribute(r), D.bindBuffer(D.ARRAY_BUFFER, w), D.vertexAttribPointer(r, v, B, p, 0, l * v * x) } } else if (void 0 !== t && (p = t[K], void 0 !== p)) switch (p.length) { case 2: D.vertexAttrib2fv(r, p); break; case 3: D.vertexAttrib3fv(r, p); break; case 4: D.vertexAttrib4fv(r, p); break; default: D.vertexAttrib1fv(r, p) } } } ba.disableUnusedAttributes() } null !== g && D.bindBuffer(D.ELEMENT_ARRAY_BUFFER, n.buffer) } n = Infinity; null !== g ? n = g.count : void 0 !== m && (n = m.count); g = c.drawRange.start * b; m = null !== f ? f.start * b : 0; var K = Math.max(g, m); f = Math.max(0, Math.min(n, g + c.drawRange.count * b, m + (null !== f ? f.count * b : Infinity)) - 1 - K + 1); if (0 !== f) { if (e.isMesh) if (!0 === d.wireframe) ba.setLineWidth(d.wireframeLinewidth * (null === F ? R : 1)), a.setMode(D.LINES); else switch (e.drawMode) { case 0: a.setMode(D.TRIANGLES); break; case 1: a.setMode(D.TRIANGLE_STRIP); break; case 2: a.setMode(D.TRIANGLE_FAN) } else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), ba.setLineWidth(d * (null === F ? R : 1)), e.isLineSegments ? a.setMode(D.LINES) : e.isLineLoop ? a.setMode(D.LINE_LOOP) : a.setMode(D.LINE_STRIP)) : e.isPoints && a.setMode(D.POINTS); c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, K, f) : a.render(K, f) } }; this.compile = function (a, b) { Z = pa.get(a, b); Z.init(); a.traverse(function (a) { a.isLight && (Z.pushLight(a), a.castShadow && Z.pushShadow(a)) }); Z.setupLights(b); a.traverse(function (b) { if (b.material) if (Array.isArray(b.material)) for (var c = 0; c < b.material.length; c++)t(b.material[c], a.fog, b); else t(b.material, a.fog, b) }) }; var va = !1, Ba = null; this.animate = function (a) { Ba = a; null !== Ba ? va || (h(), va = !0) : va = !1 }; this.render = function (a, b, c, d) { if (!b || !b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else if (!E) { N = ""; Q = -1; O = null; !0 === a.autoUpdate && a.updateMatrixWorld(); null === b.parent && b.updateMatrixWorld(); na.enabled && (b = na.getCamera(b)); Z = pa.get(a, b); Z.init(); a.onBeforeRender(A, a, b, c); pd.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse); ha.setFromMatrix(pd); la = this.localClippingEnabled; od = Ga.init(this.clippingPlanes, la, b); z = ua.get(a, b); z.init(); m(a, b, A.sortObjects); !0 === A.sortObjects && z.sort(); od && Ga.beginShadows(); Ca.render(Z.state.shadowsArray, a, b); Z.setupLights(b); od && Ga.endShadows(); this.info.autoReset && this.info.reset(); void 0 === c && (c = null); this.setRenderTarget(c); ma.render(z, a, b, d); d = z.opaque; var e = z.transparent; if (a.overrideMaterial) { var f = a.overrideMaterial; d.length && u(d, a, b, f); e.length && u(e, a, b, f) } else d.length && u(d, a, b), e.length && u(e, a, b); Aa.render(Z.state.spritesArray, a, b); c && fa.updateRenderTargetMipmap(c); ba.buffers.depth.setTest(!0); ba.buffers.depth.setMask(!0); ba.buffers.color.setMask(!0); ba.setPolygonOffset(!1); a.onAfterRender(A, a, b); na.enabled && na.submitFrame(); Z = z = null } }; this.allocTextureUnit = function () {
            var a = aa; a >= Ra.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " +
                a + " texture units while this GPU supports only " + Ra.maxTextures); aa += 1; return a
        }; this.setTexture2D = function () { var a = !1; return function (b, c) { b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture); fa.setTexture2D(b, c) } }(); this.setTexture = function () { var a = !1; return function (b, c) { a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0); fa.setTexture2D(b, c) } }(); this.setTextureCube = function () { var a = !1; return function (b, c) { b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture); b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? fa.setTextureCube(b, c) : fa.setTextureCubeDynamic(b, c) } }(); this.getRenderTarget = function () { return F }; this.setRenderTarget = function (a) { (F = a) && void 0 === X.get(a).__webglFramebuffer && fa.setupRenderTarget(a); var b = null, c = !1; a ? (b = X.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube && (b = b[a.activeCubeFace], c = !0), ob.copy(a.viewport), V.copy(a.scissor), U = a.scissorTest) : (ob.copy(Y).multiplyScalar(R), V.copy(ca).multiplyScalar(R), U = ja); I !== b && (D.bindFramebuffer(D.FRAMEBUFFER, b), I = b); ba.viewport(ob); ba.scissor(V); ba.setScissorTest(U); c && (c = X.get(a.texture), D.framebufferTexture2D(D.FRAMEBUFFER, D.COLOR_ATTACHMENT0, D.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel)) }; this.readRenderTargetPixels = function (a, b, c, d, e, f) { if (a && a.isWebGLRenderTarget) { var g = X.get(a).__webglFramebuffer; if (g) { var h = !1; g !== I && (D.bindFramebuffer(D.FRAMEBUFFER, g), h = !0); try { var l = a.texture, m = l.format, n = l.type; 1023 !== m && ia.convert(m) !== D.getParameter(D.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === n || ia.convert(n) === D.getParameter(D.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === n && (ka.get("OES_texture_float") || ka.get("WEBGL_color_buffer_float")) || 1016 === n && ka.get("EXT_color_buffer_half_float") ? D.checkFramebufferStatus(D.FRAMEBUFFER) === D.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && D.readPixels(b, c, d, e, ia.convert(m), ia.convert(n), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.") } finally { h && D.bindFramebuffer(D.FRAMEBUFFER, I) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }; this.copyFramebufferToTexture = function (a, b, c) { var d = b.image.width, e = b.image.height, f = ia.convert(b.format); this.setTexture2D(b, 0); D.copyTexImage2D(D.TEXTURE_2D, c || 0, f, a.x, a.y, d, e, 0) }; this.copyTextureToTexture = function (a, b, c, d) { var e = b.image.width, f = b.image.height, g = ia.convert(c.format), h = ia.convert(c.type); b = b.isDataTexture ? b.image.data : b.image; this.setTexture2D(c, 0); D.texSubImage2D(D.TEXTURE_2D, d || 0, a.x, a.y, e, f, g, h, b) }
    } function Ob(a, b) { this.name = ""; this.color = new I(a); this.density = void 0 !== b ? b : 2.5E-4 } function Pb(a, b, c) { this.name = ""; this.color = new I(a); this.near = void 0 !== b ? b : 1; this.far = void 0 !== c ? c : 1E3 } function rd() { A.call(this); this.type = "Scene"; this.overrideMaterial = this.fog = this.background = null; this.autoUpdate = !0 } function eb(a) { O.call(this); this.type = "SpriteMaterial"; this.color = new I(16777215); this.map = null; this.rotation = 0; this.lights = this.fog = !1; this.setValues(a) }
    function Ac(a) { A.call(this); this.type = "Sprite"; this.material = void 0 !== a ? a : new eb; this.center = new C(.5, .5) } function Bc() { A.call(this); this.type = "LOD"; Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function Cc(a, b) { a = a || []; this.bones = a.slice(0); this.boneMatrices = new Float32Array(16 * this.bones.length); if (void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++)this.boneInverses.push(new M) } function sd() { A.call(this); this.type = "Bone" } function td(a, b) { oa.call(this, a, b); this.type = "SkinnedMesh"; this.bindMode = "attached"; this.bindMatrix = new M; this.bindMatrixInverse = new M; a = this.initBones(); a = new Cc(a); this.bind(a, this.matrixWorld); this.normalizeSkinWeights() } function U(a) { O.call(this); this.type = "LineBasicMaterial"; this.color = new I(16777215); this.linewidth = 1; this.linejoin = this.linecap = "round"; this.lights = !1; this.setValues(a) }
    function ua(a, b, c) { if (1 === c) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new aa(a, b); A.call(this); this.type = "Line"; this.geometry = void 0 !== a ? a : new F; this.material = void 0 !== b ? b : new U({ color: 16777215 * Math.random() }) } function aa(a, b) { ua.call(this, a, b); this.type = "LineSegments" } function ud(a, b) { ua.call(this, a, b); this.type = "LineLoop" } function Ha(a) { O.call(this); this.type = "PointsMaterial"; this.color = new I(16777215); this.map = null; this.size = 1; this.sizeAttenuation = !0; this.lights = !1; this.setValues(a) } function Qb(a, b) { A.call(this); this.type = "Points"; this.geometry = void 0 !== a ? a : new F; this.material = void 0 !== b ? b : new Ha({ color: 16777215 * Math.random() }) } function vd() { A.call(this); this.type = "Group" } function Yd(a, b, c, d, e, f, g, h, l) { Y.call(this, a, b, c, d, e, f, g, h, l); this.generateMipmaps = !1 } function Rb(a, b, c, d, e, f, g, h, l, m, u, n) { Y.call(this, null, f, g, h, l, m, d, e, u, n); this.image = { width: b, height: c }; this.mipmaps = a; this.generateMipmaps = this.flipY = !1 } function Dc(a, b, c, d, e, f, g, h, l, m) { m = void 0 !== m ? m : 1026; if (1026 !== m && 1027 !== m) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === c && 1026 === m && (c = 1012); void 0 === c && 1027 === m && (c = 1020); Y.call(this, null, d, e, f, g, h, m, c, l); this.image = { width: a, height: b }; this.magFilter = void 0 !== g ? g : 1003; this.minFilter = void 0 !== h ? h : 1003; this.generateMipmaps = this.flipY = !1 } function Sb(a) { F.call(this); this.type = "WireframeGeometry"; var b = [], c, d, e, f = [0, 0], g = {}, h = ["a", "b", "c"]; if (a && a.isGeometry) { var l = a.faces; var m = 0; for (d = l.length; m < d; m++) { var u = l[m]; for (c = 0; 3 > c; c++) { var n = u[h[c]]; var t = u[h[(c + 1) % 3]]; f[0] = Math.min(n, t); f[1] = Math.max(n, t); n = f[0] + "," + f[1]; void 0 === g[n] && (g[n] = { index1: f[0], index2: f[1] }) } } for (n in g) m = g[n], h = a.vertices[m.index1], b.push(h.x, h.y, h.z), h = a.vertices[m.index2], b.push(h.x, h.y, h.z) } else if (a && a.isBufferGeometry) if (h = new p, null !== a.index) { l = a.attributes.position; u = a.index; var k = a.groups; 0 === k.length && (k = [{ start: 0, count: u.count, materialIndex: 0 }]); a = 0; for (e = k.length; a < e; ++a)for (m = k[a], c = m.start, d = m.count, m = c, d = c + d; m < d; m += 3)for (c = 0; 3 > c; c++)n = u.getX(m + c), t = u.getX(m + (c + 1) % 3), f[0] = Math.min(n, t), f[1] = Math.max(n, t), n = f[0] + "," + f[1], void 0 === g[n] && (g[n] = { index1: f[0], index2: f[1] }); for (n in g) m = g[n], h.fromBufferAttribute(l, m.index1), b.push(h.x, h.y, h.z), h.fromBufferAttribute(l, m.index2), b.push(h.x, h.y, h.z) } else for (l = a.attributes.position, m = 0, d = l.count / 3; m < d; m++)for (c = 0; 3 > c; c++)g = 3 * m + c, h.fromBufferAttribute(l, g), b.push(h.x, h.y, h.z), g = 3 * m + (c + 1) % 3, h.fromBufferAttribute(l, g), b.push(h.x, h.y, h.z); this.addAttribute("position", new z(b, 3)) } function Ec(a, b, c) { N.call(this); this.type = "ParametricGeometry"; this.parameters = { func: a, slices: b, stacks: c }; this.fromBufferGeometry(new Tb(a, b, c)); this.mergeVertices() } function Tb(a, b, c) {
        F.call(this); this.type = "ParametricBufferGeometry"; this.parameters = { func: a, slices: b, stacks: c }; var d = [], e = [], f = [], g = [], h = new p, l = new p, m = new p, u = new p, n = new p, t, k, q = b + 1; for (t = 0; t <= c; t++) {
            var v = t / c; for (k = 0; k <= b; k++) {
                var x = k / b; a(x, v, l); e.push(l.x, l.y, l.z); 0 <= x - 1E-5 ? (a(x -
                    1E-5, v, m), u.subVectors(l, m)) : (a(x + 1E-5, v, m), u.subVectors(m, l)); 0 <= v - 1E-5 ? (a(x, v - 1E-5, m), n.subVectors(l, m)) : (a(x, v + 1E-5, m), n.subVectors(m, l)); h.crossVectors(u, n).normalize(); f.push(h.x, h.y, h.z); g.push(x, v)
            }
        } for (t = 0; t < c; t++)for (k = 0; k < b; k++)a = t * q + k + 1, h = (t + 1) * q + k + 1, l = (t + 1) * q + k, d.push(t * q + k, a, l), d.push(a, h, l); this.setIndex(d); this.addAttribute("position", new z(e, 3)); this.addAttribute("normal", new z(f, 3)); this.addAttribute("uv", new z(g, 2))
    } function Fc(a, b, c, d) { N.call(this); this.type = "PolyhedronGeometry"; this.parameters = { vertices: a, indices: b, radius: c, detail: d }; this.fromBufferGeometry(new pa(a, b, c, d)); this.mergeVertices() } function pa(a, b, c, d) { function e(a) { h.push(a.x, a.y, a.z) } function f(b, c) { b *= 3; c.x = a[b + 0]; c.y = a[b + 1]; c.z = a[b + 2] } function g(a, b, c, d) { 0 > d && 1 === a.x && (l[b] = a.x - 1); 0 === c.x && 0 === c.z && (l[b] = d / 2 / Math.PI + .5) } F.call(this); this.type = "PolyhedronBufferGeometry"; this.parameters = { vertices: a, indices: b, radius: c, detail: d }; c = c || 1; d = d || 0; var h = [], l = []; (function (a) { for (var c = new p, d = new p, g = new p, h = 0; h < b.length; h += 3) { f(b[h + 0], c); f(b[h + 1], d); f(b[h + 2], g); var l, m, k = c, y = d, w = g, B = Math.pow(2, a), G = []; for (m = 0; m <= B; m++) { G[m] = []; var K = k.clone().lerp(w, m / B), P = y.clone().lerp(w, m / B), H = B - m; for (l = 0; l <= H; l++)G[m][l] = 0 === l && m === B ? K : K.clone().lerp(P, l / H) } for (m = 0; m < B; m++)for (l = 0; l < 2 * (B - m) - 1; l++)k = Math.floor(l / 2), 0 === l % 2 ? (e(G[m][k + 1]), e(G[m + 1][k]), e(G[m][k])) : (e(G[m][k + 1]), e(G[m + 1][k + 1]), e(G[m + 1][k])) } })(d); (function (a) { for (var b = new p, c = 0; c < h.length; c += 3)b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z })(c); (function () { for (var a = new p, b = 0; b < h.length; b += 3)a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], l.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5)); a = new p; b = new p; for (var c = new p, d = new p, e = new C, f = new C, k = new C, x = 0, y = 0; x < h.length; x += 9, y += 6) { a.set(h[x + 0], h[x + 1], h[x + 2]); b.set(h[x + 3], h[x + 4], h[x + 5]); c.set(h[x + 6], h[x + 7], h[x + 8]); e.set(l[y + 0], l[y + 1]); f.set(l[y + 2], l[y + 3]); k.set(l[y + 4], l[y + 5]); d.copy(a).add(b).add(c).divideScalar(3); var w = Math.atan2(d.z, -d.x); g(e, y + 0, a, w); g(f, y + 2, b, w); g(k, y + 4, c, w) } for (a = 0; a < l.length; a += 6)b = l[a + 0], c = l[a + 2], d = l[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (l[a + 0] += 1), .2 > c && (l[a + 2] += 1), .2 > d && (l[a + 4] += 1)) })(); this.addAttribute("position", new z(h, 3)); this.addAttribute("normal", new z(h.slice(), 3)); this.addAttribute("uv", new z(l, 2)); 0 === d ? this.computeVertexNormals() : this.normalizeNormals() } function Gc(a, b) { N.call(this); this.type = "TetrahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Ub(a, b)); this.mergeVertices() } function Ub(a, b) { pa.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b); this.type = "TetrahedronBufferGeometry"; this.parameters = { radius: a, detail: b } } function Hc(a, b) { N.call(this); this.type = "OctahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new sb(a, b)); this.mergeVertices() } function sb(a, b) { pa.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b); this.type = "OctahedronBufferGeometry"; this.parameters = { radius: a, detail: b } } function Ic(a, b) { N.call(this); this.type = "IcosahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Vb(a, b)); this.mergeVertices() } function Vb(a, b) { var c = (1 + Math.sqrt(5)) / 2; pa.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b); this.type = "IcosahedronBufferGeometry"; this.parameters = { radius: a, detail: b } } function Jc(a, b) { N.call(this); this.type = "DodecahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Wb(a, b)); this.mergeVertices() } function Wb(a, b) { var c = (1 + Math.sqrt(5)) / 2, d = 1 / c; pa.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b); this.type = "DodecahedronBufferGeometry"; this.parameters = { radius: a, detail: b } } function Kc(a, b, c, d, e, f) { N.call(this); this.type = "TubeGeometry"; this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e }; void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."); a = new Xb(a, b, c, d, e); this.tangents = a.tangents; this.normals = a.normals; this.binormals = a.binormals; this.fromBufferGeometry(a); this.mergeVertices() } function Xb(a, b, c, d, e) { function f(e) { u = a.getPointAt(e / b, u); var f = g.normals[e]; e = g.binormals[e]; for (k = 0; k <= d; k++) { var m = k / d * Math.PI * 2, n = Math.sin(m); m = -Math.cos(m); l.x = m * f.x + n * e.x; l.y = m * f.y + n * e.y; l.z = m * f.z + n * e.z; l.normalize(); q.push(l.x, l.y, l.z); h.x = u.x + c * l.x; h.y = u.y + c * l.y; h.z = u.z + c * l.z; r.push(h.x, h.y, h.z) } } F.call(this); this.type = "TubeBufferGeometry"; this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e }; b = b || 64; c = c || 1; d = d || 8; e = e || !1; var g = a.computeFrenetFrames(b, e); this.tangents = g.tangents; this.normals = g.normals; this.binormals = g.binormals; var h = new p, l = new p, m = new C, u = new p, n, k, r = [], q = [], v = [], x = []; for (n = 0; n < b; n++)f(n); f(!1 === e ? b : 0); for (n = 0; n <= b; n++)for (k = 0; k <= d; k++)m.x = n / b, m.y = k / d, v.push(m.x, m.y); (function () { for (k = 1; k <= b; k++)for (n = 1; n <= d; n++) { var a = (d + 1) * k + (n - 1), c = (d + 1) * k + n, e = (d + 1) * (k - 1) + n; x.push((d + 1) * (k - 1) + (n - 1), a, e); x.push(a, c, e) } })(); this.setIndex(x); this.addAttribute("position", new z(r, 3)); this.addAttribute("normal", new z(q, 3)); this.addAttribute("uv", new z(v, 2)) } function Lc(a, b, c, d, e, f, g) { N.call(this); this.type = "TorusKnotGeometry"; this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f }; void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."); this.fromBufferGeometry(new Yb(a, b, c, d, e, f)); this.mergeVertices() } function Yb(a, b, c, d, e, f) { function g(a, b, c, d, e) { var f = Math.sin(a); b = c / b * a; c = Math.cos(b); e.x = d * (2 + c) * .5 * Math.cos(a); e.y = d * (2 + c) * f * .5; e.z = d * Math.sin(b) * .5 } F.call(this); this.type = "TorusKnotBufferGeometry"; this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f }; a = a || 1; b = b || .4; c = Math.floor(c) || 64; d = Math.floor(d) || 8; e = e || 2; f = f || 3; var h = [], l = [], m = [], u = [], n, k = new p, r = new p, q = new p, v = new p, x = new p, y = new p, w = new p; for (n = 0; n <= c; ++n) { var B = n / c * e * Math.PI * 2; g(B, e, f, a, q); g(B + .01, e, f, a, v); y.subVectors(v, q); w.addVectors(v, q); x.crossVectors(y, w); w.crossVectors(x, y); x.normalize(); w.normalize(); for (B = 0; B <= d; ++B) { var G = B / d * Math.PI * 2, K = -b * Math.cos(G); G = b * Math.sin(G); k.x = q.x + (K * w.x + G * x.x); k.y = q.y + (K * w.y + G * x.y); k.z = q.z + (K * w.z + G * x.z); l.push(k.x, k.y, k.z); r.subVectors(k, q).normalize(); m.push(r.x, r.y, r.z); u.push(n / c); u.push(B / d) } } for (B = 1; B <= c; B++)for (n = 1; n <= d; n++)a = (d + 1) * B + (n - 1), b = (d + 1) * B + n, e = (d + 1) * (B - 1) + n, h.push((d + 1) * (B - 1) + (n - 1), a, e), h.push(a, b, e); this.setIndex(h); this.addAttribute("position", new z(l, 3)); this.addAttribute("normal", new z(m, 3)); this.addAttribute("uv", new z(u, 2)) } function Mc(a, b, c, d, e) { N.call(this); this.type = "TorusGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; this.fromBufferGeometry(new Zb(a, b, c, d, e)); this.mergeVertices() } function Zb(a, b, c, d, e) { F.call(this); this.type = "TorusBufferGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; a = a || 1; b = b || .4; c = Math.floor(c) || 8; d = Math.floor(d) || 6; e = e || 2 * Math.PI; var f = [], g = [], h = [], l = [], m = new p, u = new p, n = new p, k, r; for (k = 0; k <= c; k++)for (r = 0; r <= d; r++) { var q = r / d * e, v = k / c * Math.PI * 2; u.x = (a + b * Math.cos(v)) * Math.cos(q); u.y = (a + b * Math.cos(v)) * Math.sin(q); u.z = b * Math.sin(v); g.push(u.x, u.y, u.z); m.x = a * Math.cos(q); m.y = a * Math.sin(q); n.subVectors(u, m).normalize(); h.push(n.x, n.y, n.z); l.push(r / d); l.push(k / c) } for (k = 1; k <= c; k++)for (r = 1; r <= d; r++)a = (d + 1) * (k - 1) + r - 1, b = (d + 1) * (k - 1) + r, e = (d + 1) * k + r, f.push((d + 1) * k + r - 1, a, e), f.push(a, b, e); this.setIndex(f); this.addAttribute("position", new z(g, 3)); this.addAttribute("normal", new z(h, 3)); this.addAttribute("uv", new z(l, 2)) } function Xe(a, b, c, d, e) { for (var f, g = 0, h = b, l = c - d; h < c; h += d)g += (a[l] - a[h]) * (a[h + 1] + a[l + 1]), l = h; if (e === 0 < g) for (e = b; e < c; e += d)f = Ye(e, a[e], a[e + 1], f); else for (e = c - d; e >= b; e -= d)f = Ye(e, a[e], a[e + 1], f); f && tb(f, f.next) && (Nc(f), f = f.next); return f } function Oc(a, b) { if (!a) return a; b || (b = a); do { var c = !1; if (a.steiner || !tb(a, a.next) && 0 !== ra(a.prev, a, a.next)) a = a.next; else { Nc(a); a = b = a.prev; if (a === a.next) break; c = !0 } } while (c || a !== b); return b } function Pc(a, b, c, d, e, f, g) { if (a) { if (!g && f) { var h = a, l = h; do null === l.z && (l.z = Zd(l.x, l.y, d, e, f)), l.prevZ = l.prev, l = l.nextZ = l.next; while (l !== h); l.prevZ.nextZ = null; l.prevZ = null; h = l; var m, u, n, k, r = 1; do { l = h; var q = h = null; for (u = 0; l;) { u++; var p = l; for (m = n = 0; m < r && (n++, p = p.nextZ, p); m++); for (k = r; 0 < n || 0 < k && p;)0 !== n && (0 === k || !p || l.z <= p.z) ? (m = l, l = l.nextZ, n--) : (m = p, p = p.nextZ, k--), q ? q.nextZ = m : h = m, m.prevZ = q, q = m; l = p } q.nextZ = null; r *= 2 } while (1 < u) } for (h = a; a.prev !== a.next;) { l = a.prev; p = a.next; if (f) a: { q = a; k = d; var x = e, y = f; u = q.prev; n = q; r = q.next; if (0 <= ra(u, n, r)) q = !1; else { var w = u.x > n.x ? u.x > r.x ? u.x : r.x : n.x > r.x ? n.x : r.x, B = u.y > n.y ? u.y > r.y ? u.y : r.y : n.y > r.y ? n.y : r.y; m = Zd(u.x < n.x ? u.x < r.x ? u.x : r.x : n.x < r.x ? n.x : r.x, u.y < n.y ? u.y < r.y ? u.y : r.y : n.y < r.y ? n.y : r.y, k, x, y); k = Zd(w, B, k, x, y); for (x = q.nextZ; x && x.z <= k;) { if (x !== q.prev && x !== q.next && wd(u.x, u.y, n.x, n.y, r.x, r.y, x.x, x.y) && 0 <= ra(x.prev, x, x.next)) { q = !1; break a } x = x.nextZ } for (x = q.prevZ; x && x.z >= m;) { if (x !== q.prev && x !== q.next && wd(u.x, u.y, n.x, n.y, r.x, r.y, x.x, x.y) && 0 <= ra(x.prev, x, x.next)) { q = !1; break a } x = x.prevZ } q = !0 } } else a: if (q = a, u = q.prev, n = q, r = q.next, 0 <= ra(u, n, r)) q = !1; else { for (m = q.next.next; m !== q.prev;) { if (wd(u.x, u.y, n.x, n.y, r.x, r.y, m.x, m.y) && 0 <= ra(m.prev, m, m.next)) { q = !1; break a } m = m.next } q = !0 } if (q) b.push(l.i / c), b.push(a.i / c), b.push(p.i / c), Nc(a), h = a = p.next; else if (a = p, a === h) { if (!g) Pc(Oc(a), b, c, d, e, f, 1); else if (1 === g) { g = b; h = c; l = a; do p = l.prev, q = l.next.next, !tb(p, q) && Ze(p, l, l.next, q) && Qc(p, q) && Qc(q, p) && (g.push(p.i / h), g.push(l.i / h), g.push(q.i / h), Nc(l), Nc(l.next), l = a = q), l = l.next; while (l !== a); a = l; Pc(a, b, c, d, e, f, 2) } else if (2 === g) a: { g = a; do { for (h = g.next.next; h !== g.prev;) { if (l = g.i !== h.i) { l = g; p = h; if (q = l.next.i !== p.i && l.prev.i !== p.i) { b: { q = l; do { if (q.i !== l.i && q.next.i !== l.i && q.i !== p.i && q.next.i !== p.i && Ze(q, q.next, l, p)) { q = !0; break b } q = q.next } while (q !== l); q = !1 } q = !q } if (q = q && Qc(l, p) && Qc(p, l)) { q = l; u = !1; n = (l.x + p.x) / 2; p = (l.y + p.y) / 2; do q.y > p !== q.next.y > p && q.next.y !== q.y && n < (q.next.x - q.x) * (p - q.y) / (q.next.y - q.y) + q.x && (u = !u), q = q.next; while (q !== l); q = u } l = q } if (l) { a = $e(g, h); g = Oc(g, g.next); a = Oc(a, a.next); Pc(g, b, c, d, e, f); Pc(a, b, c, d, e, f); break a } h = h.next } g = g.next } while (g !== a) } break } } } } function Hg(a, b) { return a.x - b.x } function Ig(a, b) { var c = b, d = a.x, e = a.y, f = -Infinity; do { if (e <= c.y && e >= c.next.y && c.next.y !== c.y) { var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y); if (g <= d && g > f) { f = g; if (g === d) { if (e === c.y) return c; if (e === c.next.y) return c.next } var h = c.x < c.next.x ? c : c.next } } c = c.next } while (c !== b); if (!h) return null; if (d === f) return h.prev; b = h; g = h.x; var l = h.y, m = Infinity; for (c = h.next; c !== b;) { if (d >= c.x && c.x >= g && d !== c.x && wd(e < l ? d : f, e, g, l, e < l ? f : d, e, c.x, c.y)) { var u = Math.abs(e - c.y) / (d - c.x); (u < m || u === m && c.x > h.x) && Qc(c, a) && (h = c, m = u) } c = c.next } return h } function Zd(a, b, c, d, e) { a = 32767 * (a - c) * e; b = 32767 * (b - d) * e; a = (a | a << 8) & 16711935; a = (a | a << 4) & 252645135; a = (a | a << 2) & 858993459; b = (b | b << 8) & 16711935; b = (b | b << 4) & 252645135; b = (b | b << 2) & 858993459; return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1 } function Jg(a) { var b = a, c = a; do b.x < c.x && (c = b), b = b.next; while (b !== a); return c } function wd(a, b, c, d, e, f, g, h) { return 0 <= (e - g) * (b - h) - (a - g) * (f - h) && 0 <= (a - g) * (d - h) - (c - g) * (b - h) && 0 <= (c - g) * (f - h) - (e - g) * (d - h) } function ra(a, b, c) { return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) } function tb(a, b) { return a.x === b.x && a.y === b.y } function Ze(a, b, c, d) { return tb(a, b) && tb(c, d) || tb(a, d) && tb(c, b) ? !0 : 0 < ra(a, b, c) !== 0 < ra(a, b, d) && 0 < ra(c, d, a) !== 0 < ra(c, d, b) } function Qc(a, b) { return 0 > ra(a.prev, a, a.next) ? 0 <= ra(a, b, a.next) && 0 <= ra(a, a.prev, b) : 0 > ra(a, b, a.prev) || 0 > ra(a, a.next, b) } function $e(a, b) { var c = new $d(a.i, a.x, a.y), d = new $d(b.i, b.x, b.y), e = a.next, f = b.prev; a.next = b; b.prev = a; c.next = e; e.prev = c; d.next = c; c.prev = d; f.next = d; d.prev = f; return d } function Ye(a, b, c, d) { a = new $d(a, b, c); d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a); return a } function Nc(a) { a.next.prev = a.prev; a.prev.next = a.next; a.prevZ && (a.prevZ.nextZ = a.nextZ); a.nextZ && (a.nextZ.prevZ = a.prevZ) } function $d(a, b, c) { this.i = a; this.x = b; this.y = c; this.nextZ = this.prevZ = this.z = this.next = this.prev = null; this.steiner = !1 } function af(a) { var b = a.length; 2 < b && a[b - 1].equals(a[0]) && a.pop() } function bf(a, b) { for (var c = 0; c < b.length; c++)a.push(b[c].x), a.push(b[c].y) } function fb(a, b) { N.call(this); this.type = "ExtrudeGeometry"; this.parameters = { shapes: a, options: b }; this.fromBufferGeometry(new Ia(a, b)); this.mergeVertices() } function Ia(a, b) { "undefined" !== typeof a && (F.call(this), this.type = "ExtrudeBufferGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeVertexNormals()) } function Rc(a, b) { N.call(this); this.type = "TextGeometry"; this.parameters = { text: a, parameters: b }; this.fromBufferGeometry(new $b(a, b)); this.mergeVertices() } function $b(a, b) { b = b || {}; var c = b.font; if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new N; a = c.generateShapes(a, b.size, b.curveSegments); b.amount = void 0 !== b.height ? b.height : 50; void 0 === b.bevelThickness && (b.bevelThickness = 10); void 0 === b.bevelSize && (b.bevelSize = 8); void 0 === b.bevelEnabled && (b.bevelEnabled = !1); Ia.call(this, a, b); this.type = "TextBufferGeometry" } function Sc(a, b, c, d, e, f, g) { N.call(this); this.type = "SphereGeometry"; this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g }; this.fromBufferGeometry(new ub(a, b, c, d, e, f, g)); this.mergeVertices() } function ub(a, b, c, d, e, f, g) { F.call(this); this.type = "SphereBufferGeometry"; this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g }; a = a || 1; b = Math.max(3, Math.floor(b) || 8); c = Math.max(2, Math.floor(c) || 6); d = void 0 !== d ? d : 0; e = void 0 !== e ? e : 2 * Math.PI; f = void 0 !== f ? f : 0; g = void 0 !== g ? g : Math.PI; var h = f + g, l, m, u = 0, n = [], k = new p, r = new p, q = [], v = [], x = [], y = []; for (m = 0; m <= c; m++) { var w = [], B = m / c; for (l = 0; l <= b; l++) { var G = l / b; k.x = -a * Math.cos(d + G * e) * Math.sin(f + B * g); k.y = a * Math.cos(f + B * g); k.z = a * Math.sin(d + G * e) * Math.sin(f + B * g); v.push(k.x, k.y, k.z); r.set(k.x, k.y, k.z).normalize(); x.push(r.x, r.y, r.z); y.push(G, 1 - B); w.push(u++) } n.push(w) } for (m = 0; m < c; m++)for (l = 0; l < b; l++)a = n[m][l + 1], d = n[m][l], e = n[m + 1][l], g = n[m + 1][l + 1], (0 !== m || 0 < f) && q.push(a, d, g), (m !== c - 1 || h < Math.PI) && q.push(d, e, g); this.setIndex(q); this.addAttribute("position", new z(v, 3)); this.addAttribute("normal", new z(x, 3)); this.addAttribute("uv", new z(y, 2)) } function Tc(a, b, c, d, e, f) { N.call(this); this.type = "RingGeometry"; this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f }; this.fromBufferGeometry(new ac(a, b, c, d, e, f)); this.mergeVertices() } function ac(a, b, c, d, e, f) { F.call(this); this.type = "RingBufferGeometry"; this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f }; a = a || .5; b = b || 1; e = void 0 !== e ? e : 0; f = void 0 !== f ? f : 2 * Math.PI; c = void 0 !== c ? Math.max(3, c) : 8; d = void 0 !== d ? Math.max(1, d) : 1; var g = [], h = [], l = [], m = [], k = a, n = (b - a) / d, t = new p, r = new C, q, v; for (q = 0; q <= d; q++) { for (v = 0; v <= c; v++)a = e + v / c * f, t.x = k * Math.cos(a), t.y = k * Math.sin(a), h.push(t.x, t.y, t.z), l.push(0, 0, 1), r.x = (t.x / b + 1) / 2, r.y = (t.y / b + 1) / 2, m.push(r.x, r.y); k += n } for (q = 0; q < d; q++)for (b = q * (c + 1), v = 0; v < c; v++)a = v + b, e = a + c + 1, f = a + c + 2, k = a + 1, g.push(a, e, k), g.push(e, f, k); this.setIndex(g); this.addAttribute("position", new z(h, 3)); this.addAttribute("normal", new z(l, 3)); this.addAttribute("uv", new z(m, 2)) } function Uc(a, b, c, d) { N.call(this); this.type = "LatheGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; this.fromBufferGeometry(new bc(a, b, c, d)); this.mergeVertices() } function bc(a, b, c, d) {
        F.call(this); this.type = "LatheBufferGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; b = Math.floor(b) || 12; c = c || 0; d = d || 2 * Math.PI; d = S.clamp(d, 0, 2 * Math.PI); var e = [], f = [], g = [], h = 1 / b, l = new p, m = new C, k; for (k = 0; k <= b; k++) { var n = c + k * h * d; var t = Math.sin(n), r = Math.cos(n); for (n = 0; n <= a.length - 1; n++)l.x = a[n].x * t, l.y = a[n].y, l.z = a[n].x * r, f.push(l.x, l.y, l.z), m.x = k / b, m.y = n / (a.length - 1), g.push(m.x, m.y) } for (k = 0; k < b; k++)for (n = 0; n < a.length - 1; n++)c = n +
            k * a.length, h = c + a.length, l = c + a.length + 1, m = c + 1, e.push(c, h, m), e.push(h, l, m); this.setIndex(e); this.addAttribute("position", new z(f, 3)); this.addAttribute("uv", new z(g, 2)); this.computeVertexNormals(); if (d === 2 * Math.PI) for (d = this.attributes.normal.array, e = new p, f = new p, g = new p, c = b * a.length * 3, n = k = 0; k < a.length; k++, n += 3)e.x = d[n + 0], e.y = d[n + 1], e.z = d[n + 2], f.x = d[c + n + 0], f.y = d[c + n + 1], f.z = d[c + n + 2], g.addVectors(e, f).normalize(), d[n + 0] = d[c + n + 0] = g.x, d[n + 1] = d[c + n + 1] = g.y, d[n + 2] = d[c + n + 2] = g.z
    } function vb(a, b) { N.call(this); this.type = "ShapeGeometry"; "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments); this.parameters = { shapes: a, curveSegments: b }; this.fromBufferGeometry(new wb(a, b)); this.mergeVertices() } function wb(a, b) { function c(a) { var c, h = e.length / 3; a = a.extractPoints(b); var m = a.shape, k = a.holes; if (!1 === Xa.isClockWise(m)) for (m = m.reverse(), a = 0, c = k.length; a < c; a++) { var u = k[a]; !0 === Xa.isClockWise(u) && (k[a] = u.reverse()) } var p = Xa.triangulateShape(m, k); a = 0; for (c = k.length; a < c; a++)u = k[a], m = m.concat(u); a = 0; for (c = m.length; a < c; a++)u = m[a], e.push(u.x, u.y, 0), f.push(0, 0, 1), g.push(u.x, u.y); a = 0; for (c = p.length; a < c; a++)m = p[a], d.push(m[0] + h, m[1] + h, m[2] + h), l += 3 } F.call(this); this.type = "ShapeBufferGeometry"; this.parameters = { shapes: a, curveSegments: b }; b = b || 12; var d = [], e = [], f = [], g = [], h = 0, l = 0; if (!1 === Array.isArray(a)) c(a); else for (var m = 0; m < a.length; m++)c(a[m]), this.addGroup(h, l, m), h += l, l = 0; this.setIndex(d); this.addAttribute("position", new z(e, 3)); this.addAttribute("normal", new z(f, 3)); this.addAttribute("uv", new z(g, 2)) } function cf(a, b) { b.shapes = []; if (Array.isArray(a)) for (var c = 0, d = a.length; c < d; c++)b.shapes.push(a[c].uuid); else b.shapes.push(a.uuid); return b } function cc(a, b) { F.call(this); this.type = "EdgesGeometry"; this.parameters = { thresholdAngle: b }; var c = []; b = Math.cos(S.DEG2RAD * (void 0 !== b ? b : 1)); var d = [0, 0], e = {}, f = ["a", "b", "c"]; if (a.isBufferGeometry) { var g = new N; g.fromBufferGeometry(a) } else g = a.clone(); g.mergeVertices(); g.computeFaceNormals(); a = g.vertices; g = g.faces; for (var h = 0, l = g.length; h < l; h++)for (var m = g[h], k = 0; 3 > k; k++) { var n = m[f[k]]; var t = m[f[(k + 1) % 3]]; d[0] = Math.min(n, t); d[1] = Math.max(n, t); n = d[0] + "," + d[1]; void 0 === e[n] ? e[n] = { index1: d[0], index2: d[1], face1: h, face2: void 0 } : e[n].face2 = h } for (n in e) if (d = e[n], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z); this.addAttribute("position", new z(c, 3)) } function xb(a, b, c, d, e, f, g, h) { N.call(this); this.type = "CylinderGeometry"; this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; this.fromBufferGeometry(new Ya(a, b, c, d, e, f, g, h)); this.mergeVertices() } function Ya(a, b, c, d, e, f, g, h) { function l(c) { var e, f = new C, l = new p, u = 0, v = !0 === c ? a : b, w = !0 === c ? 1 : -1; var A = q; for (e = 1; e <= d; e++)n.push(0, x * w, 0), t.push(0, w, 0), r.push(.5, .5), q++; var z = q; for (e = 0; e <= d; e++) { var E = e / d * h + g, F = Math.cos(E); E = Math.sin(E); l.x = v * E; l.y = x * w; l.z = v * F; n.push(l.x, l.y, l.z); t.push(0, w, 0); f.x = .5 * F + .5; f.y = .5 * E * w + .5; r.push(f.x, f.y); q++ } for (e = 0; e < d; e++)f = A + e, l = z + e, !0 === c ? k.push(l, l + 1, f) : k.push(l + 1, l, f), u += 3; m.addGroup(y, u, !0 === c ? 1 : 2); y += u } F.call(this); this.type = "CylinderBufferGeometry"; this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; var m = this; a = void 0 !== a ? a : 1; b = void 0 !== b ? b : 1; c = c || 1; d = Math.floor(d) || 8; e = Math.floor(e) || 1; f = void 0 !== f ? f : !1; g = void 0 !== g ? g : 0; h = void 0 !== h ? h : 2 * Math.PI; var k = [], n = [], t = [], r = [], q = 0, v = [], x = c / 2, y = 0; (function () { var f, l, u = new p, K = new p, P = 0, H = (b - a) / c; for (l = 0; l <= e; l++) { var C = [], A = l / e, z = A * (b - a) + a; for (f = 0; f <= d; f++) { var E = f / d, F = E * h + g, I = Math.sin(F); F = Math.cos(F); K.x = z * I; K.y = -A * c + x; K.z = z * F; n.push(K.x, K.y, K.z); u.set(I, H, F).normalize(); t.push(u.x, u.y, u.z); r.push(E, 1 - A); C.push(q++) } v.push(C) } for (f = 0; f < d; f++)for (l = 0; l < e; l++)u = v[l + 1][f], K = v[l + 1][f + 1], H = v[l][f + 1], k.push(v[l][f], u, H), k.push(u, K, H), P += 6; m.addGroup(y, P, 0); y += P })(); !1 === f && (0 < a && l(!0), 0 < b && l(!1)); this.setIndex(k); this.addAttribute("position", new z(n, 3)); this.addAttribute("normal", new z(t, 3)); this.addAttribute("uv", new z(r, 2)) } function Vc(a, b, c, d, e, f, g) { xb.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeGeometry"; this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g } } function Wc(a, b, c, d, e, f, g) { Ya.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeBufferGeometry"; this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g } } function Xc(a, b, c, d) { N.call(this); this.type = "CircleGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; this.fromBufferGeometry(new dc(a, b, c, d)); this.mergeVertices() } function dc(a, b, c, d) { F.call(this); this.type = "CircleBufferGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; a = a || 1; b = void 0 !== b ? Math.max(3, b) : 8; c = void 0 !== c ? c : 0; d = void 0 !== d ? d : 2 * Math.PI; var e = [], f = [], g = [], h = [], l, m = new p, k = new C; f.push(0, 0, 0); g.push(0, 0, 1); h.push(.5, .5); var n = 0; for (l = 3; n <= b; n++, l += 3) { var t = c + n / b * d; m.x = a * Math.cos(t); m.y = a * Math.sin(t); f.push(m.x, m.y, m.z); g.push(0, 0, 1); k.x = (f[l] / a + 1) / 2; k.y = (f[l + 1] / a + 1) / 2; h.push(k.x, k.y) } for (l = 1; l <= b; l++)e.push(l, l + 1, 0); this.setIndex(e); this.addAttribute("position", new z(f, 3)); this.addAttribute("normal", new z(g, 3)); this.addAttribute("uv", new z(h, 2)) } function yb(a) { O.call(this); this.type = "ShadowMaterial"; this.color = new I(0); this.transparent = !0; this.setValues(a) } function ec(a) { va.call(this, a); this.type = "RawShaderMaterial" } function Sa(a) { O.call(this); this.defines = { STANDARD: "" }; this.type = "MeshStandardMaterial"; this.color = new I(16777215); this.metalness = this.roughness = .5; this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new I(0); this.emissiveIntensity = 1; this.bumpMap = this.emissiveMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null; this.envMapIntensity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a) } function zb(a) { Sa.call(this); this.defines = { PHYSICAL: "" }; this.type = "MeshPhysicalMaterial"; this.reflectivity = .5; this.clearCoatRoughness = this.clearCoat = 0; this.setValues(a) } function Ja(a) { O.call(this); this.type = "MeshPhongMaterial"; this.color = new I(16777215); this.specular = new I(1118481); this.shininess = 30; this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new I(0); this.emissiveIntensity = 1; this.bumpMap = this.emissiveMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.envMap = this.alphaMap = this.specularMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a) }
    function Ab(a) { Ja.call(this); this.defines = { TOON: "" }; this.type = "MeshToonMaterial"; this.gradientMap = null; this.setValues(a) } function Bb(a) { O.call(this); this.type = "MeshNormalMaterial"; this.bumpMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe = !1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1; this.setValues(a) } function Cb(a) { O.call(this); this.type = "MeshLambertMaterial"; this.color = new I(16777215); this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new I(0); this.emissiveIntensity = 1; this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a) } function Db(a) { U.call(this); this.type = "LineDashedMaterial"; this.scale = 1; this.dashSize = 3; this.gapSize = 1; this.setValues(a) } function ae(a, b, c) { var d = this, e = !1, f = 0, g = 0, h = void 0; this.onStart = void 0; this.onLoad = a; this.onProgress = b; this.onError = c; this.itemStart = function (a) { g++; if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g); e = !0 }; this.itemEnd = function (a) { f++; if (void 0 !== d.onProgress) d.onProgress(a, f, g); if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad() }; this.itemError = function (a) { if (void 0 !== d.onError) d.onError(a) }; this.resolveURL = function (a) { return h ? h(a) : a }; this.setURLModifier = function (a) { h = a; return this } } function Ka(a) { this.manager = void 0 !== a ? a : ma } function df(a) { this.manager = void 0 !== a ? a : ma; this._parser = null } function be(a) { this.manager = void 0 !== a ? a : ma; this._parser = null } function Yc(a) { this.manager = void 0 !== a ? a : ma } function ce(a) { this.manager = void 0 !== a ? a : ma } function xd(a) { this.manager = void 0 !== a ? a : ma } function E() { this.type = "Curve"; this.arcLengthDivisions = 200 } function ia(a, b, c, d, e, f, g, h) { E.call(this); this.type = "EllipseCurve"; this.aX = a || 0; this.aY = b || 0; this.xRadius = c || 1; this.yRadius = d || 1; this.aStartAngle = e || 0; this.aEndAngle = f || 2 * Math.PI; this.aClockwise = g || !1; this.aRotation = h || 0 } function fc(a, b, c, d, e, f) { ia.call(this, a, b, c, c, d, e, f); this.type = "ArcCurve" } function de() { var a = 0, b = 0, c = 0, d = 0; return { initCatmullRom: function (e, f, g, h, l) { e = l * (g - e); h = l * (h - f); a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h }, initNonuniformCatmullRom: function (e, f, g, h, l, m, k) { e = ((f - e) / l - (g - e) / (l + m) + (g - f) / m) * m; h = ((g - f) / m - (h - f) / (m + k) + (h - g) / k) * m; a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h }, calc: function (e) { var f = e * e; return a + b * e + c * f + d * f * e } } } function X(a, b, c, d) { E.call(this); this.type = "CatmullRomCurve3"; this.points = a || []; this.closed = b || !1; this.curveType = c || "centripetal"; this.tension = d || .5 } function ef(a, b, c, d, e) { b = .5 * (d - b); e = .5 * (e - c); var f = a * a; return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c } function Zc(a, b, c, d) { var e = 1 - a; return e * e * b + 2 * (1 - a) * a * c + a * a * d } function $c(a, b, c, d, e) { var f = 1 - a, g = 1 - a; return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e } function La(a, b, c, d) { E.call(this); this.type = "CubicBezierCurve"; this.v0 = a || new C; this.v1 = b || new C; this.v2 = c || new C; this.v3 = d || new C } function Ta(a, b, c, d) { E.call(this); this.type = "CubicBezierCurve3"; this.v0 = a || new p; this.v1 = b || new p; this.v2 = c || new p; this.v3 = d || new p } function wa(a, b) { E.call(this); this.type = "LineCurve"; this.v1 = a || new C; this.v2 = b || new C } function Ma(a, b) { E.call(this); this.type = "LineCurve3"; this.v1 = a || new p; this.v2 = b || new p } function Na(a, b, c) { E.call(this); this.type = "QuadraticBezierCurve"; this.v0 = a || new C; this.v1 = b || new C; this.v2 = c || new C } function Ua(a, b, c) { E.call(this); this.type = "QuadraticBezierCurve3"; this.v0 = a || new p; this.v1 = b || new p; this.v2 = c || new p } function Oa(a) { E.call(this); this.type = "SplineCurve"; this.points = a || [] } function Za() { E.call(this); this.type = "CurvePath"; this.curves = []; this.autoClose = !1 } function Pa(a) { Za.call(this); this.type = "Path"; this.currentPoint = new C; a && this.setFromPoints(a) } function gb(a) { Pa.call(this, a); this.uuid = S.generateUUID(); this.type = "Shape"; this.holes = [] } function ca(a, b) { A.call(this); this.type = "Light"; this.color = new I(a); this.intensity = void 0 !== b ? b : 1; this.receiveShadow = void 0 } function yd(a, b, c) { ca.call(this, a, c); this.type = "HemisphereLight"; this.castShadow = void 0; this.position.copy(A.DefaultUp); this.updateMatrix(); this.groundColor = new I(b) } function Eb(a) { this.camera = a; this.bias = 0; this.radius = 1; this.mapSize = new C(512, 512); this.map = null; this.matrix = new M } function zd() { Eb.call(this, new la(50, 1, .5, 500)) } function Ad(a, b, c, d, e, f) { ca.call(this, a, b); this.type = "SpotLight"; this.position.copy(A.DefaultUp); this.updateMatrix(); this.target = new A; Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (a) { this.intensity = a / Math.PI } }); this.distance = void 0 !== c ? c : 0; this.angle = void 0 !== d ? d : Math.PI / 3; this.penumbra = void 0 !== e ? e : 0; this.decay = void 0 !== f ? f : 1; this.shadow = new zd } function Bd(a, b, c, d) { ca.call(this, a, b); this.type = "PointLight"; Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (a) { this.intensity = a / (4 * Math.PI) } }); this.distance = void 0 !== c ? c : 0; this.decay = void 0 !== d ? d : 1; this.shadow = new Eb(new la(90, 1, .5, 500)) } function Cd() { Eb.call(this, new Jb(-5, 5, 5, -5, .5, 500)) } function Dd(a, b) { ca.call(this, a, b); this.type = "DirectionalLight"; this.position.copy(A.DefaultUp); this.updateMatrix(); this.target = new A; this.shadow = new Cd } function Ed(a, b) { ca.call(this, a, b); this.type = "AmbientLight"; this.castShadow = void 0 } function Fd(a, b, c, d) { ca.call(this, a, b); this.type = "RectAreaLight"; this.width = void 0 !== c ? c : 10; this.height = void 0 !== d ? d : 10 } function Gd(a, b, c, d) { da.call(this, a, b, c, d) } function Hd(a, b, c) { da.call(this, a, b, c) } function na(a, b, c, d) { this.parameterPositions = a; this._cachedIndex = 0; this.resultBuffer = void 0 !== d ? d : new b.constructor(c); this.sampleValues = b; this.valueSize = c } function Id(a, b, c, d) { na.call(this, a, b, c, d) } function ad(a, b, c, d) { da.call(this, a, b, c, d) } function Jd(a, b, c, d) { da.call(this, a, b, c, d) } function gc(a, b, c, d) { da.call(this, a, b, c, d) } function Kd(a, b, c, d) { na.call(this, a, b, c, d); this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0 } function bd(a, b, c, d) { na.call(this, a, b, c, d) } function Ld(a, b, c, d) { na.call(this, a, b, c, d) } function da(a, b, c, d) { if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a); this.name = a; this.times = fa.convertArray(b, this.TimeBufferType); this.values = fa.convertArray(c, this.ValueBufferType); this.setInterpolation(d || this.DefaultInterpolation); this.validate(); this.optimize() } function hc(a, b, c, d) { da.call(this, a, b, c, d) } function Ba(a, b, c) { this.name = a; this.tracks = c; this.duration = void 0 !== b ? b : -1; this.uuid = S.generateUUID(); 0 > this.duration && this.resetDuration(); this.optimize() } function Md(a) { this.manager = void 0 !== a ? a : ma; this.textures = {} } function ee(a) { this.manager = void 0 !== a ? a : ma } function ic() { } function fe(a) { "boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0); this.manager = void 0 !== a ? a : ma; this.withCredentials = !1 } function ff(a) { this.manager = void 0 !== a ? a : ma; this.texturePath = "" }
    function ge(a) { "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."); "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."); this.manager = void 0 !== a ? a : ma; this.options = void 0 } function he() { this.type = "ShapePath"; this.subPaths = []; this.currentPath = null } function ie(a) { this.type = "Font"; this.data = a } function gf(a) { this.manager = void 0 !== a ? a : ma } function je(a) { this.manager = void 0 !== a ? a : ma } function hf() { this.type = "StereoCamera"; this.aspect = 1; this.eyeSep = .064; this.cameraL = new la; this.cameraL.layers.enable(1); this.cameraL.matrixAutoUpdate = !1; this.cameraR = new la; this.cameraR.layers.enable(2); this.cameraR.matrixAutoUpdate = !1 } function cd(a, b, c) { A.call(this); this.type = "CubeCamera"; var d = new la(90, 1, a, b); d.up.set(0, -1, 0); d.lookAt(new p(1, 0, 0)); this.add(d); var e = new la(90, 1, a, b); e.up.set(0, -1, 0); e.lookAt(new p(-1, 0, 0)); this.add(e); var f = new la(90, 1, a, b); f.up.set(0, 0, 1); f.lookAt(new p(0, 1, 0)); this.add(f); var g = new la(90, 1, a, b); g.up.set(0, 0, -1); g.lookAt(new p(0, -1, 0)); this.add(g); var h = new la(90, 1, a, b); h.up.set(0, -1, 0); h.lookAt(new p(0, 0, 1)); this.add(h); var l = new la(90, 1, a, b); l.up.set(0, -1, 0); l.lookAt(new p(0, 0, -1)); this.add(l); this.renderTarget = new Ib(c, c, { format: 1022, magFilter: 1006, minFilter: 1006 }); this.renderTarget.texture.name = "CubeCamera"; this.update = function (a, b) { null === this.parent && this.updateMatrixWorld(); var c = this.renderTarget, m = c.texture.generateMipmaps; c.texture.generateMipmaps = !1; c.activeCubeFace = 0; a.render(b, d, c); c.activeCubeFace = 1; a.render(b, e, c); c.activeCubeFace = 2; a.render(b, f, c); c.activeCubeFace = 3; a.render(b, g, c); c.activeCubeFace = 4; a.render(b, h, c); c.texture.generateMipmaps = m; c.activeCubeFace = 5; a.render(b, l, c); a.setRenderTarget(null) }; this.clear = function (a, b, c, d) { for (var e = this.renderTarget, f = 0; 6 > f; f++)e.activeCubeFace = f, a.setRenderTarget(e), a.clear(b, c, d); a.setRenderTarget(null) } } function ke() { A.call(this); this.type = "AudioListener"; this.context = le.getContext(); this.gain = this.context.createGain(); this.gain.connect(this.context.destination); this.filter = null } function jc(a) { A.call(this); this.type = "Audio"; this.context = a.context; this.gain = this.context.createGain(); this.gain.connect(a.getInput()); this.autoplay = !1; this.buffer = null; this.loop = !1; this.offset = this.startTime = 0; this.playbackRate = 1; this.isPlaying = !1; this.hasPlaybackControl = !0; this.sourceType = "empty"; this.filters = [] } function me(a) { jc.call(this, a); this.panner = this.context.createPanner(); this.panner.connect(this.gain) } function ne(a, b) { this.analyser = a.context.createAnalyser(); this.analyser.fftSize = void 0 !== b ? b : 2048; this.data = new Uint8Array(this.analyser.frequencyBinCount); a.getOutput().connect(this.analyser) } function oe(a, b, c) { this.binding = a; this.valueSize = c; a = Float64Array; switch (b) { case "quaternion": b = this._slerp; break; case "string": case "bool": a = Array; b = this._select; break; default: b = this._lerp }this.buffer = new a(4 * c); this._mixBufferRegion = b; this.referenceCount = this.useCount = this.cumulativeWeight = 0 } function jf(a, b, c) { c = c || qa.parseTrackName(b); this._targetGroup = a; this._bindings = a.subscribe_(b, c) } function qa(a, b, c) { this.path = b; this.parsedPath = c || qa.parseTrackName(b); this.node = qa.findNode(a, this.parsedPath.nodeName) || a; this.rootNode = a } function kf() { this.uuid = S.generateUUID(); this._objects = Array.prototype.slice.call(arguments); this.nCachedObjects_ = 0; var a = {}; this._indicesByUUID = a; for (var b = 0, c = arguments.length; b !== c; ++b)a[arguments[b].uuid] = b; this._paths = []; this._parsedPaths = []; this._bindings = []; this._bindingsIndicesByPath = {}; var d = this; this.stats = { objects: { get total() { return d._objects.length }, get inUse() { return this.total - d.nCachedObjects_ } }, get bindingsPerObject() { return d._bindings.length } } } function lf(a, b, c) { this._mixer = a; this._clip = b; this._localRoot = c || null; a = b.tracks; b = a.length; c = Array(b); for (var d = { endingStart: 2400, endingEnd: 2400 }, e = 0; e !== b; ++e) { var f = a[e].createInterpolant(null); c[e] = f; f.settings = d } this._interpolantSettings = d; this._interpolants = c; this._propertyBindings = Array(b); this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null; this.loop = 2201; this._loopCount = -1; this._startTime = null; this.time = 0; this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1; this.repetitions = Infinity; this.paused = !1; this.enabled = !0; this.clampWhenFinished = !1; this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0 } function pe(a) { this._root = a; this._initMemoryManager(); this.time = this._accuIndex = 0; this.timeScale = 1 } function Nd(a, b) { "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b); this.value = a } function qe() { F.call(this); this.type = "InstancedBufferGeometry"; this.maxInstancedCount = void 0 } function re(a, b, c, d) { this.data = a; this.itemSize = b; this.offset = c; this.normalized = !0 === d } function kc(a, b) { this.array = a; this.stride = b; this.count = void 0 !== a ? a.length / b : 0; this.dynamic = !1; this.updateRange = { offset: 0, count: -1 }; this.version = 0 } function se(a, b, c) { kc.call(this, a, b); this.meshPerAttribute = c || 1 } function te(a, b, c) { T.call(this, a, b); this.meshPerAttribute = c || 1 } function mf(a, b, c, d) { this.ray = new qb(a, b); this.near = c || 0; this.far = d || Infinity; this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }; Object.defineProperties(this.params, { PointCloud: { get: function () { console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."); return this.Points } } }) } function nf(a, b) { return a.distance - b.distance } function ue(a, b, c, d) { if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) { a = a.children; d = 0; for (var e = a.length; d < e; d++)ue(a[d], b, c, !0) } } function of(a) { this.autoStart = void 0 !== a ? a : !0; this.elapsedTime = this.oldTime = this.startTime = 0; this.running = !1 } function pf(a, b, c) { this.radius = void 0 !== a ? a : 1; this.phi = void 0 !== b ? b : 0; this.theta = void 0 !== c ? c : 0; return this } function qf(a, b, c) { this.radius = void 0 !== a ? a : 1; this.theta = void 0 !== b ? b : 0; this.y = void 0 !== c ? c : 0; return this } function ve(a, b) { this.min = void 0 !== a ? a : new C(Infinity, Infinity); this.max = void 0 !== b ? b : new C(-Infinity, -Infinity) } function dd(a) { A.call(this); this.material = a; this.render = function () { } } function ed(a, b, c, d) { this.object = a; this.size = void 0 !== b ? b : 1; a = void 0 !== c ? c : 16711680; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count); c = new F; b = new z(6 * b, 3); c.addAttribute("position", b); aa.call(this, c, new U({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update() } function lc(a, b) { A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = b; a = new F; b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (var c = 0, d = 1; 32 > c; c++, d++) { var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2; b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1) } a.addAttribute("position", new z(b, 3)); b = new U({ fog: !1 }); this.cone = new aa(a, b); this.add(this.cone); this.update() } function rf(a) { var b = []; a && a.isBone && b.push(a); for (var c = 0; c < a.children.length; c++)b.push.apply(b, rf(a.children[c])); return b } function mc(a) { for (var b = rf(a), c = new F, d = [], e = [], f = new I(0, 0, 1), g = new I(0, 1, 0), h = 0; h < b.length; h++) { var l = b[h]; l.parent && l.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b)) } c.addAttribute("position", new z(d, 3)); c.addAttribute("color", new z(e, 3)); d = new U({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }); aa.call(this, c, d); this.root = a; this.bones = b; this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1 } function nc(a, b, c) { this.light = a; this.light.updateMatrixWorld(); this.color = c; a = new ub(b, 4, 2); b = new za({ wireframe: !0, fog: !1 }); oa.call(this, a, b); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = !1; this.update() } function oc(a, b) { A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = b; a = new U({ fog: !1 }); b = new F; b.addAttribute("position", new T(new Float32Array(15), 3)); this.line = new ua(b, a); this.add(this.line); this.update() } function pc(a, b, c) { A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = c; a = new sb(b); a.rotateY(.5 * Math.PI); this.material = new za({ wireframe: !0, fog: !1 }); void 0 === this.color && (this.material.vertexColors = 2); b = a.getAttribute("position"); b = new Float32Array(3 * b.count); a.addAttribute("color", new T(b, 3)); this.add(new oa(a, this.material)); this.update() } function fd(a, b, c, d) { a = a || 10; b = b || 10; c = new I(void 0 !== c ? c : 4473924); d = new I(void 0 !== d ? d : 8947848); var e = b / 2, f = a / b, g = a / 2; a = []; for (var h = [], l = 0, m = 0, k = -g; l <= b; l++, k += f) { a.push(-g, 0, k, g, 0, k); a.push(k, 0, -g, k, 0, g); var n = l === e ? c : d; n.toArray(h, m); m += 3; n.toArray(h, m); m += 3; n.toArray(h, m); m += 3; n.toArray(h, m); m += 3 } b = new F; b.addAttribute("position", new z(a, 3)); b.addAttribute("color", new z(h, 3)); c = new U({ vertexColors: 2 }); aa.call(this, b, c) } function Od(a, b, c, d, e, f) { a = a || 10; b = b || 16; c = c || 8; d = d || 64; e = new I(void 0 !== e ? e : 4473924); f = new I(void 0 !== f ? f : 8947848); var g = [], h = [], l; for (l = 0; l <= b; l++) { var m = l / b * 2 * Math.PI; var k = Math.sin(m) * a; m = Math.cos(m) * a; g.push(0, 0, 0); g.push(k, 0, m); var n = l & 1 ? e : f; h.push(n.r, n.g, n.b); h.push(n.r, n.g, n.b) } for (l = 0; l <= c; l++) { n = l & 1 ? e : f; var t = a - a / c * l; for (b = 0; b < d; b++)m = b / d * 2 * Math.PI, k = Math.sin(m) * t, m = Math.cos(m) * t, g.push(k, 0, m), h.push(n.r, n.g, n.b), m = (b + 1) / d * 2 * Math.PI, k = Math.sin(m) * t, m = Math.cos(m) * t, g.push(k, 0, m), h.push(n.r, n.g, n.b) } a = new F; a.addAttribute("position", new z(g, 3)); a.addAttribute("color", new z(h, 3)); g = new U({ vertexColors: 2 }); aa.call(this, a, g) } function gd(a, b, c, d) { this.object = a; this.size = void 0 !== b ? b : 1; a = void 0 !== c ? c : 16776960; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); c = new F; b = new z(6 * b, 3); c.addAttribute("position", b); aa.call(this, c, new U({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update() } function qc(a, b, c) { A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = c; void 0 === b && (b = 1); a = new F; a.addAttribute("position", new z([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3)); b = new U({ fog: !1 }); this.lightPlane = new ua(a, b); this.add(this.lightPlane); a = new F; a.addAttribute("position", new z([0, 0, 0, 0, 0, 1], 3)); this.targetLine = new ua(a, b); this.add(this.targetLine); this.update() } function hd(a) { function b(a, b, d) { c(a, d); c(b, d) } function c(a, b) { f.push(0, 0, 0); g.push(b.r, b.g, b.b); void 0 === h[a] && (h[a] = []); h[a].push(f.length / 3 - 1) } var d = new F, e = new U({ color: 16777215, vertexColors: 1 }), f = [], g = [], h = {}, l = new I(16755200), m = new I(16711680), k = new I(43775), n = new I(16777215), t = new I(3355443); b("n1", "n2", l); b("n2", "n4", l); b("n4", "n3", l); b("n3", "n1", l); b("f1", "f2", l); b("f2", "f4", l); b("f4", "f3", l); b("f3", "f1", l); b("n1", "f1", l); b("n2", "f2", l); b("n3", "f3", l); b("n4", "f4", l); b("p", "n1", m); b("p", "n2", m); b("p", "n3", m); b("p", "n4", m); b("u1", "u2", k); b("u2", "u3", k); b("u3", "u1", k); b("c", "t", n); b("p", "c", t); b("cn1", "cn2", t); b("cn3", "cn4", t); b("cf1", "cf2", t); b("cf3", "cf4", t); d.addAttribute("position", new z(f, 3)); d.addAttribute("color", new z(g, 3)); aa.call(this, d, e); this.camera = a; this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.pointMap = h; this.update() } function Fb(a, b) { this.object = a; void 0 === b && (b = 16776960); a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new Float32Array(24), d = new F; d.setIndex(new T(a, 1)); d.addAttribute("position", new T(c, 3)); aa.call(this, d, new U({ color: b })); this.matrixAutoUpdate = !1; this.update() } function id(a, b) { this.type = "Box3Helper"; this.box = a; a = void 0 !== b ? b : 16776960; b = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new F; c.setIndex(new T(b, 1)); c.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)); aa.call(this, c, new U({ color: a })); this.geometry.computeBoundingSphere() } function jd(a, b, c) { this.type = "PlaneHelper"; this.plane = a; this.size = void 0 === b ? 1 : b; a = void 0 !== c ? c : 16776960; b = new F; b.addAttribute("position", new z([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)); b.computeBoundingSphere(); ua.call(this, b, new U({ color: a })); b = new F; b.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)); b.computeBoundingSphere(); this.add(new oa(b, new za({ color: a, opacity: .2, transparent: !0, depthWrite: !1 }))) } function Gb(a, b, c, d, e, f) { A.call(this); void 0 === d && (d = 16776960); void 0 === c && (c = 1); void 0 === e && (e = .2 * c); void 0 === f && (f = .2 * e); void 0 === Pd && (Pd = new F, Pd.addAttribute("position", new z([0, 0, 0, 0, 1, 0], 3)), we = new Ya(0, .5, 1, 5, 1), we.translate(0, -.5, 0)); this.position.copy(b); this.line = new ua(Pd, new U({ color: d })); this.line.matrixAutoUpdate = !1; this.add(this.line); this.cone = new oa(we, new za({ color: d })); this.cone.matrixAutoUpdate = !1; this.add(this.cone); this.setDirection(a); this.setLength(c, e, f) } function kd(a) { a = a || 1; var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]; a = new F; a.addAttribute("position", new z(b, 3)); a.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); b = new U({ vertexColors: 2 }); aa.call(this, a, b) } function sf(a) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); X.call(this, a); this.type = "catmullrom"; this.closed = !0 } function tf(a) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); X.call(this, a); this.type = "catmullrom" } function xe(a) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."); X.call(this, a); this.type = "catmullrom" } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)); void 0 === Number.isInteger && (Number.isInteger = function (a) { return "number" === typeof a && isFinite(a) && Math.floor(a) === a }); void 0 === Math.sign && (Math.sign = function (a) { return 0 > a ? -1 : 0 < a ? 1 : +a }); !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }); void 0 === Object.assign && function () { Object.assign = function (a) { if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object"); for (var b = Object(a), c = 1; c < arguments.length; c++) { var d = arguments[c]; if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]) } return b } }(); Object.assign(xa.prototype, { addEventListener: function (a, b) { void 0 === this._listeners && (this._listeners = {}); var c = this._listeners; void 0 === c[a] && (c[a] = []); -1 === c[a].indexOf(b) && c[a].push(b) }, hasEventListener: function (a, b) { if (void 0 === this._listeners) return !1; var c = this._listeners; return void 0 !== c[a] && -1 !== c[a].indexOf(b) }, removeEventListener: function (a, b) { void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1))) }, dispatchEvent: function (a) { if (void 0 !== this._listeners) { var b = this._listeners[a.type]; if (void 0 !== b) { a.target = this; b = b.slice(0); for (var c = 0, d = b.length; c < d; c++)b[c].call(this, a) } } } }); var S = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { for (var a = [], b = 0; 256 > b; b++)a[b] = (16 > b ? "0" : "") + b.toString(16).toUpperCase(); return function () { var b = 4294967295 * Math.random() | 0, d = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, f = 4294967295 * Math.random() | 0; return a[b & 255] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + "-" + a[d & 255] + a[d >> 8 & 255] + "-" + a[d >> 16 & 15 | 64] + a[d >> 24 & 255] + "-" + a[e & 63 | 128] + a[e >> 8 & 255] + "-" + a[e >> 16 & 255] + a[e >> 24 & 255] + a[f & 255] + a[f >> 8 & 255] + a[f >> 16 & 255] + a[f >> 24 & 255] } }(), clamp: function (a, b, c) { return Math.max(b, Math.min(c, a)) }, euclideanModulo: function (a, b) { return (a % b + b) % b }, mapLinear: function (a, b, c, d, e) { return d + (a - b) * (e - d) / (c - b) }, lerp: function (a, b, c) { return (1 - c) * a + c * b }, smoothstep: function (a, b, c) { if (a <= b) return 0; if (a >= c) return 1; a = (a - b) / (c - b); return a * a * (3 - 2 * a) }, smootherstep: function (a, b, c) { if (a <= b) return 0; if (a >= c) return 1; a = (a - b) / (c - b); return a * a * a * (a * (6 * a - 15) + 10) }, randInt: function (a, b) { return a + Math.floor(Math.random() * (b - a + 1)) }, randFloat: function (a, b) { return a + Math.random() * (b - a) }, randFloatSpread: function (a) { return a * (.5 - Math.random()) }, degToRad: function (a) { return a * S.DEG2RAD }, radToDeg: function (a) { return a * S.RAD2DEG }, isPowerOfTwo: function (a) { return 0 === (a & a - 1) && 0 !== a }, ceilPowerOfTwo: function (a) { return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2)) }, floorPowerOfTwo: function (a) { return Math.pow(2, Math.floor(Math.log(a) / Math.LN2)) } }; Object.defineProperties(C.prototype, { width: { get: function () { return this.x }, set: function (a) { this.x = a } }, height: { get: function () { return this.y }, set: function (a) { this.y = a } } }); Object.assign(C.prototype, {
        isVector2: !0, set: function (a, b) { this.x = a; this.y = b; return this }, setScalar: function (a) { this.y = this.x = a; return this }, setX: function (a) { this.x = a; return this }, setY: function (a) { this.y = a; return this }, setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; default: throw Error("index is out of range: " + a); }return this }, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (a) { this.x = a.x; this.y = a.y; return this }, add: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; return this }, addScalar: function (a) { this.x += a; this.y += a; return this }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; return this }, sub: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; return this }, subScalar: function (a) { this.x -= a; this.y -= a; return this }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; return this }, multiply: function (a) { this.x *= a.x; this.y *= a.y; return this }, multiplyScalar: function (a) { this.x *= a; this.y *= a; return this }, divide: function (a) { this.x /= a.x; this.y /= a.y; return this }, divideScalar: function (a) { return this.multiplyScalar(1 / a) }, applyMatrix3: function (a) { var b = this.x, c = this.y; a = a.elements; this.x = a[0] * b + a[3] * c + a[6]; this.y = a[1] * b + a[4] * c + a[7]; return this }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); return this }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); return this }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); return this }, clampScalar: function () { var a = new C, b = new C; return function (c, d) { a.set(c, c); b.set(d, d); return this.clamp(a, b) } }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))) }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); return this }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); return this }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); return this }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); return this }, negate: function () { this.x = -this.x; this.y = -this.y; return this }, dot: function (a) { return this.x * a.x + this.y * a.y }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { var a = Math.atan2(this.y, this.x); 0 > a && (a += 2 * Math.PI); return a }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)) }, distanceToSquared: function (a) { var b = this.x - a.x; a = this.y - a.y; return b * b + a * a }, manhattanDistanceTo: function (a) {
            return Math.abs(this.x -
                a.x) + Math.abs(this.y - a.y)
        }, setLength: function (a) { return this.normalize().multiplyScalar(a) }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; return this }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a) }, equals: function (a) { return a.x === this.x && a.y === this.y }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; return a }, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); return this }, rotateAround: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = this.x - a.x, e = this.y - a.y; this.x = d * c - e * b + a.x; this.y = d * b + e * c + a.y; return this }
    }); Object.assign(M.prototype, {
        isMatrix4: !0, set: function (a, b, c, d, e, f, g, h, l, m, k, n, t, r, q, p) { var u = this.elements; u[0] = a; u[4] = b; u[8] = c; u[12] = d; u[1] = e; u[5] = f; u[9] = g; u[13] = h; u[2] = l; u[6] = m; u[10] = k; u[14] = n; u[3] = t; u[7] = r; u[11] = q; u[15] = p; return this }, identity: function () { this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this }, clone: function () { return (new M).fromArray(this.elements) }, copy: function (a) { var b = this.elements; a = a.elements; b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9]; b[10] = a[10]; b[11] = a[11]; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; b[15] = a[15]; return this }, copyPosition: function (a) { var b = this.elements; a = a.elements; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; return this }, extractBasis: function (a, b, c) { a.setFromMatrixColumn(this, 0); b.setFromMatrixColumn(this, 1); c.setFromMatrixColumn(this, 2); return this }, makeBasis: function (a, b, c) { this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1); return this }, extractRotation: function () { var a = new p; return function (b) { var c = this.elements, d = b.elements, e = 1 / a.setFromMatrixColumn(b, 0).length(), f = 1 / a.setFromMatrixColumn(b, 1).length(); b = 1 / a.setFromMatrixColumn(b, 2).length(); c[0] = d[0] * e; c[1] = d[1] * e; c[2] = d[2] * e; c[4] = d[4] * f; c[5] = d[5] * f; c[6] = d[6] * f; c[8] = d[8] * b; c[9] = d[9] * b; c[10] = d[10] * b; return this } }(), makeRotationFromEuler: function (a) { a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c); c = Math.sin(c); var g = Math.cos(d); d = Math.sin(d); var h = Math.cos(e); e = Math.sin(e); if ("XYZ" === a.order) { a = f * h; var l = f * e, m = c * h, k = c * e; b[0] = g * h; b[4] = -g * e; b[8] = d; b[1] = l + m * d; b[5] = a - k * d; b[9] = -c * g; b[2] = k - a * d; b[6] = m + l * d; b[10] = f * g } else "YXZ" === a.order ? (a = g * h, l = g * e, m = d * h, k = d * e, b[0] = a + k * c, b[4] = m * c - l, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = l * c - m, b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, l = g * e, m = d * h, k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = m + l * c, b[1] = l + m * c, b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, l = f * e, m = c * h, k = c * e, b[0] = g * h, b[4] = m * d - l, b[8] = a * d + k, b[1] = g * e, b[5] = k * d + a, b[9] = l * d - m, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, l = f * d, m = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = m * e + l, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = l * e + m, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, l = f * d, m = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, b[5] = f * h, b[9] = l * e - m, b[2] = m * e - l, b[6] = c * h, b[10] = k * e + a); b[3] = 0; b[7] = 0; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return this }, makeRotationFromQuaternion: function (a) { var b = this.elements, c = a._x, d = a._y, e = a._z, f = a._w, g = c + c, h = d + d, l = e + e; a = c * g; var m = c * h; c *= l; var k = d * h; d *= l; e *= l; g *= f; h *= f; f *= l; b[0] = 1 - (k + e); b[4] = m - f; b[8] = c + h; b[1] = m + f; b[5] = 1 - (a + e); b[9] = d - g; b[2] = c - h; b[6] = d + g; b[10] = 1 - (a + k); b[3] = 0; b[7] = 0; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return this }, lookAt: function () { var a = new p, b = new p, c = new p; return function (d, e, f) { var g = this.elements; c.subVectors(d, e); 0 === c.lengthSq() && (c.z = 1); c.normalize(); a.crossVectors(f, c); 0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1E-4 : c.z += 1E-4, c.normalize(), a.crossVectors(f, c)); a.normalize(); b.crossVectors(c, a); g[0] = a.x; g[4] = b.x; g[8] = c.x; g[1] = a.y; g[5] = b.y; g[9] = c.y; g[2] = a.z; g[6] = b.z; g[10] = c.z; return this } }(), multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a) }, premultiply: function (a) { return this.multiplyMatrices(a, this) }, multiplyMatrices: function (a, b) {
            var c = a.elements, d = b.elements; b = this.elements; a = c[0]; var e = c[4], f = c[8], g = c[12], h = c[1], l = c[5], m = c[9], k = c[13], n = c[2], t = c[6], r = c[10], q = c[14], p = c[3], x = c[7], y = c[11]; c = c[15]; var w = d[0], B = d[4], G = d[8], K = d[12], P = d[1], H = d[5], C = d[9], A = d[13], z = d[2], E = d[6], F = d[10], I = d[14], L = d[3], Q = d[7], N = d[11]; d = d[15]; b[0] = a * w + e * P + f * z + g * L; b[4] = a * B + e * H + f * E + g * Q; b[8] = a * G + e * C + f * F +
                g * N; b[12] = a * K + e * A + f * I + g * d; b[1] = h * w + l * P + m * z + k * L; b[5] = h * B + l * H + m * E + k * Q; b[9] = h * G + l * C + m * F + k * N; b[13] = h * K + l * A + m * I + k * d; b[2] = n * w + t * P + r * z + q * L; b[6] = n * B + t * H + r * E + q * Q; b[10] = n * G + t * C + r * F + q * N; b[14] = n * K + t * A + r * I + q * d; b[3] = p * w + x * P + y * z + c * L; b[7] = p * B + x * H + y * E + c * Q; b[11] = p * G + x * C + y * F + c * N; b[15] = p * K + x * A + y * I + c * d; return this
        }, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[4] *= a; b[8] *= a; b[12] *= a; b[1] *= a; b[5] *= a; b[9] *= a; b[13] *= a; b[2] *= a; b[6] *= a; b[10] *= a; b[14] *= a; b[3] *= a; b[7] *= a; b[11] *= a; b[15] *= a; return this }, applyToBufferAttribute: function () { var a = new p; return function (b) { for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z); return b } }(), determinant: function () { var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], l = a[13], m = a[2], k = a[6], n = a[10], t = a[14]; return a[3] * (+e * h * k - d * l * k - e * g * n + c * l * n + d * g * t - c * h * t) + a[7] * (+b * h * t - b * l * n + e * f * n - d * f * t + d * l * m - e * h * m) + a[11] * (+b * l * k - b * g * t - e * f * k + c * f * t + e * g * m - c * l * m) + a[15] * (-d * g * m - b * h * k + b * g * n + d * f * k - c * f * n + c * h * m) }, transpose: function () { var a = this.elements; var b = a[1]; a[1] = a[4]; a[4] = b; b = a[2]; a[2] = a[8]; a[8] = b; b = a[6]; a[6] = a[9]; a[9] = b; b = a[3]; a[3] = a[12]; a[12] = b; b = a[7]; a[7] = a[13]; a[13] = b; b = a[11]; a[11] = a[14]; a[14] = b; return this }, setPosition: function (a) { var b = this.elements; b[12] = a.x; b[13] = a.y; b[14] = a.z; return this }, getInverse: function (a, b) { var c = this.elements, d = a.elements; a = d[0]; var e = d[1], f = d[2], g = d[3], h = d[4], l = d[5], m = d[6], k = d[7], n = d[8], t = d[9], r = d[10], q = d[11], p = d[12], x = d[13], y = d[14]; d = d[15]; var w = t * y * k - x * r * k + x * m * q - l * y * q - t * m * d + l * r * d, B = p * r * k - n * y * k - p * m * q + h * y * q + n * m * d - h * r * d, G = n * x * k - p * t * k + p * l * q - h * x * q - n * l * d + h * t * d, K = p * t * m - n * x * m - p * l * r + h * x * r + n * l * y - h * t * y, P = a * w + e * B + f * G + g * K; if (0 === P) { if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"); console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"); return this.identity() } b = 1 / P; c[0] = w * b; c[1] = (x * r * g - t * y * g - x * f * q + e * y * q + t * f * d - e * r * d) * b; c[2] = (l * y * g - x * m * g + x * f * k - e * y * k - l * f * d + e * m * d) * b; c[3] = (t * m * g - l * r * g - t * f * k + e * r * k + l * f * q - e * m * q) * b; c[4] = B * b; c[5] = (n * y * g - p * r * g + p * f * q - a * y * q - n * f * d + a * r * d) * b; c[6] = (p * m * g - h * y * g - p * f * k + a * y * k + h * f * d - a * m * d) * b; c[7] = (h * r * g - n * m * g + n * f * k - a * r * k - h * f * q + a * m * q) * b; c[8] = G * b; c[9] = (p * t * g - n * x * g - p * e * q + a * x * q + n * e * d - a * t * d) * b; c[10] = (h * x * g - p * l * g + p * e * k - a * x * k - h * e * d + a * l * d) * b; c[11] = (n * l * g - h * t * g - n * e * k + a * t * k + h * e * q - a * l * q) * b; c[12] = K * b; c[13] = (n * x * f - p * t * f + p * e * r - a * x * r - n * e * y + a * t * y) * b; c[14] = (p * l * f - h * x * f - p * e * m + a * x * m + h * e * y - a * l * y) * b; c[15] = (h * t * f - n * l * f + n * e * m - a * t * m - h * e * r + a * l * r) * b; return this }, scale: function (a) { var b = this.elements, c = a.x, d = a.y; a = a.z; b[0] *= c; b[4] *= d; b[8] *= a; b[1] *= c; b[5] *= d; b[9] *= a; b[2] *= c; b[6] *= d; b[10] *= a; b[3] *= c; b[7] *= d; b[11] *= a; return this }, getMaxScaleOnAxis: function () { var a = this.elements; return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])) }, makeTranslation: function (a, b, c) { this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1); return this }, makeRotationX: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1); return this }, makeRotationY: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1); return this }, makeRotationZ: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this }, makeRotationAxis: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = 1 - c, e = a.x, f = a.y; a = a.z; var g = d * e, h = d * f; this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1); return this }, makeScale: function (a, b, c) { this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1); return this }, makeShear: function (a, b, c) { this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1); return this }, compose: function (a, b, c) { this.makeRotationFromQuaternion(b); this.scale(c); this.setPosition(a); return this }, decompose: function () { var a = new p, b = new M; return function (c, d, e) { var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), l = a.set(f[8], f[9], f[10]).length(); 0 > this.determinant() && (g = -g); c.x = f[12]; c.y = f[13]; c.z = f[14]; b.copy(this); c = 1 / g; f = 1 / h; var m = 1 / l; b.elements[0] *= c; b.elements[1] *= c; b.elements[2] *= c; b.elements[4] *= f; b.elements[5] *= f; b.elements[6] *= f; b.elements[8] *= m; b.elements[9] *= m; b.elements[10] *= m; d.setFromRotationMatrix(b); e.x = g; e.y = h; e.z = l; return this } }(), makePerspective: function (a, b, c, d, e, f) { void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var g = this.elements; g[0] = 2 * e / (b - a); g[4] = 0; g[8] = (b + a) / (b - a); g[12] = 0; g[1] = 0; g[5] = 2 * e / (c - d); g[9] = (c + d) / (c - d); g[13] = 0; g[2] = 0; g[6] = 0; g[10] = -(f + e) / (f - e); g[14] = -2 * f * e / (f - e); g[3] = 0; g[7] = 0; g[11] = -1; g[15] = 0; return this }, makeOrthographic: function (a, b, c, d, e, f) { var g = this.elements, h = 1 / (b - a), l = 1 / (c - d), m = 1 / (f - e); g[0] = 2 * h; g[4] = 0; g[8] = 0; g[12] = -((b + a) * h); g[1] = 0; g[5] = 2 * l; g[9] = 0; g[13] = -((c + d) * l); g[2] = 0; g[6] = 0; g[10] = -2 * m; g[14] = -((f + e) * m); g[3] = 0; g[7] = 0; g[11] = 0; g[15] = 1; return this }, equals: function (a) { var b = this.elements; a = a.elements; for (var c = 0; 16 > c; c++)if (b[c] !== a[c]) return !1; return !0 }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 16 > c; c++)this.elements[c] = a[c + b]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); var c = this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8]; a[b + 9] = c[9]; a[b + 10] = c[10]; a[b + 11] = c[11]; a[b + 12] = c[12]; a[b + 13] = c[13]; a[b + 14] = c[14]; a[b + 15] = c[15]; return a }
    }); Object.assign(ja, { slerp: function (a, b, c, d) { return c.copy(a).slerp(b, d) }, slerpFlat: function (a, b, c, d, e, f, g) { var h = c[d + 0], l = c[d + 1], m = c[d + 2]; c = c[d + 3]; d = e[f + 0]; var k = e[f + 1], n = e[f + 2]; e = e[f + 3]; if (c !== e || h !== d || l !== k || m !== n) { f = 1 - g; var p = h * d + l * k + m * n + c * e, r = 0 <= p ? 1 : -1, q = 1 - p * p; q > Number.EPSILON && (q = Math.sqrt(q), p = Math.atan2(q, p * r), f = Math.sin(f * p) / q, g = Math.sin(g * p) / q); r *= g; h = h * f + d * r; l = l * f + k * r; m = m * f + n * r; c = c * f + e * r; f === 1 - g && (g = 1 / Math.sqrt(h * h + l * l + m * m + c * c), h *= g, l *= g, m *= g, c *= g) } a[b] = h; a[b + 1] = l; a[b + 2] = m; a[b + 3] = c } }); Object.defineProperties(ja.prototype, { x: { get: function () { return this._x }, set: function (a) { this._x = a; this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (a) { this._y = a; this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (a) { this._z = a; this.onChangeCallback() } }, w: { get: function () { return this._w }, set: function (a) { this._w = a; this.onChangeCallback() } } }); Object.assign(ja.prototype, {
        set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._w = d; this.onChangeCallback(); return this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (a) { this._x = a.x; this._y = a.y; this._z = a.z; this._w = a.w; this.onChangeCallback(); return this }, setFromEuler: function (a, b) { if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var c = a._x, d = a._y, e = a._z; a = a.order; var f = Math.cos, g = Math.sin, h = f(c / 2), l = f(d / 2); f = f(e / 2); c = g(c / 2); d = g(d / 2); e = g(e / 2); "XYZ" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f - c * d * e) : "YXZ" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f + c * d * e) : "ZXY" === a ? (this._x = c * l * f - h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f - c * d * e) : "ZYX" === a ? (this._x = c * l * f - h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f + c * d * e) : "YZX" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f - c * d * e) : "XZY" === a && (this._x = c * l * f - h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f + c * d * e); if (!1 !== b) this.onChangeCallback(); return this }, setFromAxisAngle: function (a, b) { b /= 2; var c = Math.sin(b); this._x = a.x * c; this._y = a.y * c; this._z = a.z * c; this._w = Math.cos(b); this.onChangeCallback(); return this }, setFromRotationMatrix: function (a) { var b = a.elements, c = b[0]; a = b[4]; var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], l = b[6]; b = b[10]; var m = c + f + b; 0 < m ? (c = .5 / Math.sqrt(m + 1), this._w = .25 / c, this._x = (l - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (l - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + l) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + l) / c, this._z = .25 * c); this.onChangeCallback(); return this }, setFromUnitVectors: function () { var a = new p, b; return function (c, d) { void 0 === a && (a = new p); b = c.dot(d) + 1; 1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d); this._x = a.x; this._y = a.y; this._z = a.z; this._w = b; return this.normalize() } }(), inverse: function () { return this.conjugate() }, conjugate: function () { this._x *= -1; this._y *= -1; this._z *= -1; this.onChangeCallback(); return this }, dot: function (a) { return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var a = this.length(); 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a); this.onChangeCallback(); return this }, multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a) }, premultiply: function (a) { return this.multiplyQuaternions(a, this) }, multiplyQuaternions: function (a, b) { var c = a._x, d = a._y, e = a._z; a = a._w; var f = b._x, g = b._y, h = b._z; b = b._w; this._x = c * b + a * f + d * h - e * g; this._y = d * b + a * g + e * f - c * h; this._z = e * b + a * h + c * g - d * f; this._w = a * b - c * f - d * g - e * h; this.onChangeCallback(); return this }, slerp: function (a, b) { if (0 === b) return this; if (1 === b) return this.copy(a); var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z; 0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a); if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this; a = Math.sqrt(1 - g * g); if (.001 > Math.abs(a)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this; var h = Math.atan2(a, g); g = Math.sin((1 - b) * h) / a; b = Math.sin(b * h) / a; this._w = f * g + this._w * b; this._x = c * g + this._x * b; this._y = d * g + this._y * b; this._z = e * g + this._z * b; this.onChangeCallback(); return this }, equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w }, fromArray: function (a, b) {
            void 0 === b && (b = 0); this._x = a[b]; this._y = a[b +
                1]; this._z = a[b + 2]; this._w = a[b + 3]; this.onChangeCallback(); return this
        }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._w; return a }, onChange: function (a) { this.onChangeCallback = a; return this }, onChangeCallback: function () { }
    }); Object.assign(p.prototype, {
        isVector3: !0, set: function (a, b, c) { this.x = a; this.y = b; this.z = c; return this }, setScalar: function (a) { this.z = this.y = this.x = a; return this }, setX: function (a) { this.x = a; return this }, setY: function (a) { this.y = a; return this }, setZ: function (a) { this.z = a; return this }, setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; case 2: this.z = b; break; default: throw Error("index is out of range: " + a); }return this }, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; return this }, add: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; return this }, addScalar: function (a) { this.x += a; this.y += a; this.z += a; return this }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; return this }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; return this }, sub: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; this.z -= a.z; return this }, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; return this }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; return this }, multiply: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b); this.x *= a.x; this.y *= a.y; this.z *= a.z; return this }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; return this }, multiplyVectors: function (a, b) { this.x = a.x * b.x; this.y = a.y * b.y; this.z = a.z * b.z; return this }, applyEuler: function () { var a = new ja; return function (b) { b && b.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."); return this.applyQuaternion(a.setFromEuler(b)) } }(), applyAxisAngle: function () { var a = new ja; return function (b, c) { return this.applyQuaternion(a.setFromAxisAngle(b, c)) } }(), applyMatrix3: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[3] * c + a[6] * d; this.y = a[1] * b + a[4] * c + a[7] * d; this.z = a[2] * b + a[5] * c + a[8] * d; return this }, applyMatrix4: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]); this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e; this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e; this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e; return this }, applyQuaternion: function (a) { var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z; a = a.w; var h = a * b + f * d - g * c, l = a * c + g * b - e * d, m = a * d + e * c - f * b; b = -e * b - f * c - g * d; this.x = h * a + b * -e + l * -g - m * -f; this.y = l * a + b * -f + m * -e - h * -g; this.z = m * a + b * -g + h * -f - l * -e; return this }, project: function () { var a = new M; return function (b) { a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)); return this.applyMatrix4(a) } }(), unproject: function () { var a = new M; return function (b) { a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)); return this.applyMatrix4(a) } }(), transformDirection: function (a) {
            var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d; this.y = a[1] * b + a[5] * c +
                a[9] * d; this.z = a[2] * b + a[6] * c + a[10] * d; return this.normalize()
        }, divide: function (a) { this.x /= a.x; this.y /= a.y; this.z /= a.z; return this }, divideScalar: function (a) { return this.multiplyScalar(1 / a) }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); return this }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); return this }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); return this }, clampScalar: function () { var a = new p, b = new p; return function (c, d) { a.set(c, c, c); b.set(d, d, d); return this.clamp(a, b) } }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))) }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); return this }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z); return this }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); return this }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); return this }, negate: function () { this.x = -this.x; this.y = -this.y; this.z = -this.z; return this }, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (a) { return this.normalize().multiplyScalar(a) }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; return this }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a) }, cross: function (a, b) { return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a) }, crossVectors: function (a, b) { var c = a.x, d = a.y; a = a.z; var e = b.x, f = b.y; b = b.z; this.x = d * b - a * f; this.y = a * e - c * b; this.z = c * f - d * e; return this }, projectOnVector: function (a) { var b = a.dot(this) / a.lengthSq(); return this.copy(a).multiplyScalar(b) }, projectOnPlane: function () { var a = new p; return function (b) { a.copy(this).projectOnVector(b); return this.sub(a) } }(), reflect: function () { var a = new p; return function (b) { return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b))) } }(), angleTo: function (a) { a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq()); return Math.acos(S.clamp(a, -1, 1)) }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)) }, distanceToSquared: function (a) { var b = this.x - a.x, c = this.y - a.y; a = this.z - a.z; return b * b + c * c + a * a }, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z) }, setFromSpherical: function (a) { var b = Math.sin(a.phi) * a.radius; this.x = b * Math.sin(a.theta); this.y = Math.cos(a.phi) * a.radius; this.z = b * Math.cos(a.theta); return this }, setFromCylindrical: function (a) { this.x = a.radius * Math.sin(a.theta); this.y = a.y; this.z = a.radius * Math.cos(a.theta); return this }, setFromMatrixPosition: function (a) { a = a.elements; this.x = a[12]; this.y = a[13]; this.z = a[14]; return this }, setFromMatrixScale: function (a) { var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length(); a = this.setFromMatrixColumn(a, 2).length(); this.x = b; this.y = c; this.z = a; return this }, setFromMatrixColumn: function (a, b) { return this.fromArray(a.elements, 4 * b) }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; return a }, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); return this }
    }); Object.assign(sa.prototype, { isMatrix3: !0, set: function (a, b, c, d, e, f, g, h, l) { var m = this.elements; m[0] = a; m[1] = d; m[2] = g; m[3] = b; m[4] = e; m[5] = h; m[6] = c; m[7] = f; m[8] = l; return this }, identity: function () { this.set(1, 0, 0, 0, 1, 0, 0, 0, 1); return this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (a) { var b = this.elements; a = a.elements; b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; return this }, setFromMatrix4: function (a) { a = a.elements; this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]); return this }, applyToBufferAttribute: function () { var a = new p; return function (b) { for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z); return b } }(), multiply: function (a) { return this.multiplyMatrices(this, a) }, premultiply: function (a) { return this.multiplyMatrices(a, this) }, multiplyMatrices: function (a, b) { var c = a.elements, d = b.elements; b = this.elements; a = c[0]; var e = c[3], f = c[6], g = c[1], h = c[4], l = c[7], m = c[2], k = c[5]; c = c[8]; var n = d[0], p = d[3], r = d[6], q = d[1], v = d[4], x = d[7], y = d[2], w = d[5]; d = d[8]; b[0] = a * n + e * q + f * y; b[3] = a * p + e * v + f * w; b[6] = a * r + e * x + f * d; b[1] = g * n + h * q + l * y; b[4] = g * p + h * v + l * w; b[7] = g * r + h * x + l * d; b[2] = m * n + k * q + c * y; b[5] = m * p + k * v + c * w; b[8] = m * r + k * x + c * d; return this }, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[3] *= a; b[6] *= a; b[1] *= a; b[4] *= a; b[7] *= a; b[2] *= a; b[5] *= a; b[8] *= a; return this }, determinant: function () { var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], l = a[7]; a = a[8]; return b * f * a - b * g * l - c * e * a + c * g * h + d * e * l - d * f * h }, getInverse: function (a, b) { a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var c = a.elements; a = this.elements; var d = c[0], e = c[1], f = c[2], g = c[3], h = c[4], l = c[5], m = c[6], k = c[7]; c = c[8]; var n = c * h - l * k, p = l * m - c * g, r = k * g - h * m, q = d * n + e * p + f * r; if (0 === q) { if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"); console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"); return this.identity() } b = 1 / q; a[0] = n * b; a[1] = (f * k - c * e) * b; a[2] = (l * e - f * h) * b; a[3] = p * b; a[4] = (c * d - f * m) * b; a[5] = (f * g - l * d) * b; a[6] = r * b; a[7] = (e * m - k * d) * b; a[8] = (h * d - e * g) * b; return this }, transpose: function () { var a = this.elements; var b = a[1]; a[1] = a[3]; a[3] = b; b = a[2]; a[2] = a[6]; a[6] = b; b = a[5]; a[5] = a[7]; a[7] = b; return this }, getNormalMatrix: function (a) { return this.setFromMatrix4(a).getInverse(this).transpose() }, transposeIntoArray: function (a) { var b = this.elements; a[0] = b[0]; a[1] = b[3]; a[2] = b[6]; a[3] = b[1]; a[4] = b[4]; a[5] = b[7]; a[6] = b[2]; a[7] = b[5]; a[8] = b[8]; return this }, setUvTransform: function (a, b, c, d, e, f, g) { var h = Math.cos(e); e = Math.sin(e); this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1) }, scale: function (a, b) { var c = this.elements; c[0] *= a; c[3] *= a; c[6] *= a; c[1] *= b; c[4] *= b; c[7] *= b; return this }, rotate: function (a) { var b = Math.cos(a); a = Math.sin(a); var c = this.elements, d = c[0], e = c[3], f = c[6], g = c[1], h = c[4], l = c[7]; c[0] = b * d + a * g; c[3] = b * e + a * h; c[6] = b * f + a * l; c[1] = -a * d + b * g; c[4] = -a * e + b * h; c[7] = -a * f + b * l; return this }, translate: function (a, b) { var c = this.elements; c[0] += a * c[2]; c[3] += a * c[5]; c[6] += a * c[8]; c[1] += b * c[2]; c[4] += b * c[5]; c[7] += b * c[8]; return this }, equals: function (a) { var b = this.elements; a = a.elements; for (var c = 0; 9 > c; c++)if (b[c] !== a[c]) return !1; return !0 }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 9 > c; c++)this.elements[c] = a[c + b]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); var c = this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8]; return a } }); var xf = 0; Y.DEFAULT_IMAGE = void 0; Y.DEFAULT_MAPPING = 300; Y.prototype = Object.assign(Object.create(xa.prototype), { constructor: Y, isTexture: !0, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.name = a.name; this.image = a.image; this.mipmaps = a.mipmaps.slice(0); this.mapping = a.mapping; this.wrapS = a.wrapS; this.wrapT = a.wrapT; this.magFilter = a.magFilter; this.minFilter = a.minFilter; this.anisotropy = a.anisotropy; this.format = a.format; this.type = a.type; this.offset.copy(a.offset); this.repeat.copy(a.repeat); this.center.copy(a.center); this.rotation = a.rotation; this.matrixAutoUpdate = a.matrixAutoUpdate; this.matrix.copy(a.matrix); this.generateMipmaps = a.generateMipmaps; this.premultiplyAlpha = a.premultiplyAlpha; this.flipY = a.flipY; this.unpackAlignment = a.unpackAlignment; this.encoding = a.encoding; return this }, toJSON: function (a) { var b = void 0 === a || "string" === typeof a; if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid]; var c = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY }; if (void 0 !== this.image) { var d = this.image; void 0 === d.uuid && (d.uuid = S.generateUUID()); if (!b && void 0 === a.images[d.uuid]) { var e = a.images, f = d.uuid, g = d.uuid; if (d instanceof HTMLCanvasElement) var h = d; else { h = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); h.width = d.width; h.height = d.height; var l = h.getContext("2d"); d instanceof ImageData ? l.putImageData(d, 0, 0) : l.drawImage(d, 0, 0, d.width, d.height) } h = 2048 < h.width || 2048 < h.height ? h.toDataURL("image/jpeg", .6) : h.toDataURL("image/png"); e[f] = { uuid: g, url: h } } c.image = d.uuid } b || (a.textures[this.uuid] = c); return c }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (a) { if (300 === this.mapping) { a.applyMatrix3(this.matrix); if (0 > a.x || 1 < a.x) switch (this.wrapS) { case 1E3: a.x -= Math.floor(a.x); break; case 1001: a.x = 0 > a.x ? 0 : 1; break; case 1002: a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x) }if (0 > a.y || 1 < a.y) switch (this.wrapT) { case 1E3: a.y -= Math.floor(a.y); break; case 1001: a.y = 0 > a.y ? 0 : 1; break; case 1002: a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y) }this.flipY && (a.y = 1 - a.y) } } }); Object.defineProperty(Y.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++ } }); Object.assign(ea.prototype, { isVector4: !0, set: function (a, b, c, d) { this.x = a; this.y = b; this.z = c; this.w = d; return this }, setScalar: function (a) { this.w = this.z = this.y = this.x = a; return this }, setX: function (a) { this.x = a; return this }, setY: function (a) { this.y = a; return this }, setZ: function (a) { this.z = a; return this }, setW: function (a) { this.w = a; return this }, setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; case 2: this.z = b; break; case 3: this.w = b; break; default: throw Error("index is out of range: " + a); }return this }, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; this.w = void 0 !== a.w ? a.w : 1; return this }, add: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; this.w += a.w; return this }, addScalar: function (a) { this.x += a; this.y += a; this.z += a; this.w += a; return this }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; this.w += a.w * b; return this }, sub: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; this.z -= a.z; this.w -= a.w; return this }, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; this.w -= a; return this }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; this.w *= a; return this }, applyMatrix4: function (a) { var b = this.x, c = this.y, d = this.z, e = this.w; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e; this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e; this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e; this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e; return this }, divideScalar: function (a) { return this.multiplyScalar(1 / a) }, setAxisAngleFromQuaternion: function (a) { this.w = 2 * Math.acos(a.w); var b = Math.sqrt(1 - a.w * a.w); 1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b); return this }, setAxisAngleFromRotationMatrix: function (a) { a = a.elements; var b = a[0]; var c = a[4]; var d = a[8], e = a[1], f = a[5], g = a[9]; var h = a[2]; var l = a[6]; var m = a[10]; if (.01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - l)) { if (.1 > Math.abs(c + e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + l) && .1 > Math.abs(b + f + m - 3)) return this.set(1, 0, 0, 0), this; a = Math.PI; b = (b + 1) / 2; f = (f + 1) / 2; m = (m + 1) / 2; c = (c + e) / 4; d = (d + h) / 4; g = (g + l) / 4; b > f && b > m ? .01 > b ? (l = 0, c = h = .707106781) : (l = Math.sqrt(b), h = c / l, c = d / l) : f > m ? .01 > f ? (l = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), l = c / h, c = g / h) : .01 > m ? (h = l = .707106781, c = 0) : (c = Math.sqrt(m), l = d / c, h = g / c); this.set(l, h, c, a); return this } a = Math.sqrt((l - g) * (l - g) + (d - h) * (d - h) + (e - c) * (e - c)); .001 > Math.abs(a) && (a = 1); this.x = (l - g) / a; this.y = (d - h) / a; this.z = (e - c) / a; this.w = Math.acos((b + f + m - 1) / 2); return this }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); this.w = Math.min(this.w, a.w); return this }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); this.w = Math.max(this.w, a.w); return this }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); this.w = Math.max(a.w, Math.min(b.w, this.w)); return this }, clampScalar: function () { var a, b; return function (c, d) { void 0 === a && (a = new ea, b = new ea); a.set(c, c, c, c); b.set(d, d, d, d); return this.clamp(a, b) } }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))) }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); this.w = Math.floor(this.w); return this }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z); this.w = Math.ceil(this.w); return this }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); this.w = Math.round(this.w); return this }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w); return this }, negate: function () { this.x = -this.x; this.y = -this.y; this.z = -this.z; this.w = -this.w; return this }, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (a) { return this.normalize().multiplyScalar(a) }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; this.w += (a.w - this.w) * b; return this }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a) }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; this.w = a[b + 3]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; a[b + 3] = this.w; return a }, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); this.w = a.getW(b); return this } }); hb.prototype = Object.assign(Object.create(xa.prototype), { constructor: hb, isWebGLRenderTarget: !0, setSize: function (a, b) { if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose(); this.viewport.set(0, 0, a, b); this.scissor.set(0, 0, a, b) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.width = a.width; this.height = a.height; this.viewport.copy(a.viewport); this.texture = a.texture.clone(); this.depthBuffer = a.depthBuffer; this.stencilBuffer = a.stencilBuffer; this.depthTexture = a.depthTexture; return this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); Ib.prototype = Object.create(hb.prototype); Ib.prototype.constructor = Ib; Ib.prototype.isWebGLRenderTargetCube = !0; ib.prototype = Object.create(Y.prototype); ib.prototype.constructor = ib; ib.prototype.isDataTexture = !0; Object.assign(Va.prototype, { isBox3: !0, set: function (a, b) { this.min.copy(a); this.max.copy(b); return this }, setFromArray: function (a) { for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, l = a.length; h < l; h += 3) { var m = a[h], k = a[h + 1], n = a[h + 2]; m < b && (b = m); k < c && (c = k); n < d && (d = n); m > e && (e = m); k > f && (f = k); n > g && (g = n) } this.min.set(b, c, d); this.max.set(e, f, g); return this }, setFromBufferAttribute: function (a) { for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, l = a.count; h < l; h++) { var m = a.getX(h), k = a.getY(h), n = a.getZ(h); m < b && (b = m); k < c && (c = k); n < d && (d = n); m > e && (e = m); k > f && (f = k); n > g && (g = n) } this.min.set(b, c, d); this.max.set(e, f, g); return this }, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]); return this }, setFromCenterAndSize: function () { var a = new p; return function (b, c) { c = a.copy(c).multiplyScalar(.5); this.min.copy(b).sub(c); this.max.copy(b).add(c); return this } }(), setFromObject: function (a) { this.makeEmpty(); return this.expandByObject(a) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = Infinity; this.max.x = this.max.y = this.max.z = -Infinity; return this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (a) { void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new p); return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (a) { void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new p); return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min) }, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this }, expandByScalar: function (a) { this.min.addScalar(-a); this.max.addScalar(a); return this }, expandByObject: function () { function a(a) { var f = a.geometry; if (void 0 !== f) if (f.isGeometry) for (f = f.vertices, c = 0, d = f.length; c < d; c++)e.copy(f[c]), e.applyMatrix4(a.matrixWorld), b.expandByPoint(e); else if (f.isBufferGeometry && (f = f.attributes.position, void 0 !== f)) for (c = 0, d = f.count; c < d; c++)e.fromBufferAttribute(f, c).applyMatrix4(a.matrixWorld), b.expandByPoint(e) } var b, c, d, e = new p; return function (c) { b = this; c.updateMatrixWorld(!0); c.traverse(a); return this } }(), containsPoint: function (a) { return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0 }, containsBox: function (a) { return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z }, getParameter: function (a, b) { void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new p); return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (a) { return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0 }, intersectsSphere: function () { var a = new p; return function (b) { this.clampPoint(b.center, a); return a.distanceToSquared(b.center) <= b.radius * b.radius } }(), intersectsPlane: function (a) { if (0 < a.normal.x) { var b = a.normal.x * this.min.x; var c = a.normal.x * this.max.x } else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x; 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y); 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z); return b <= a.constant && c >= a.constant }, intersectsTriangle: function () { function a(a) { var e; var f = 0; for (e = a.length - 3; f <= e; f += 3) { h.fromArray(a, f); var g = m.x * Math.abs(h.x) + m.y * Math.abs(h.y) + m.z * Math.abs(h.z), l = b.dot(h), k = c.dot(h), n = d.dot(h); if (Math.max(-Math.max(l, k, n), Math.min(l, k, n)) > g) return !1 } return !0 } var b = new p, c = new p, d = new p, e = new p, f = new p, g = new p, h = new p, l = new p, m = new p, k = new p; return function (h) { if (this.isEmpty()) return !1; this.getCenter(l); m.subVectors(this.max, l); b.subVectors(h.a, l); c.subVectors(h.b, l); d.subVectors(h.c, l); e.subVectors(c, b); f.subVectors(d, c); g.subVectors(b, d); h = [0, -e.z, e.y, 0, -f.z, f.y, 0, -g.z, g.y, e.z, 0, -e.x, f.z, 0, -f.x, g.z, 0, -g.x, -e.y, e.x, 0, -f.y, f.x, 0, -g.y, g.x, 0]; if (!a(h)) return !1; h = [1, 0, 0, 0, 1, 0, 0, 0, 1]; if (!a(h)) return !1; k.crossVectors(e, f); h = [k.x, k.y, k.z]; return a(h) } }(), clampPoint: function (a, b) { void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new p); return b.copy(a).clamp(this.min, this.max) }, distanceToPoint: function () { var a = new p; return function (b) { return a.copy(b).clamp(this.min, this.max).sub(b).length() } }(), getBoundingSphere: function () { var a = new p; return function (b) { void 0 === b && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), b = new Ea); this.getCenter(b.center); b.radius = .5 * this.getSize(a).length(); return b } }(), intersect: function (a) { this.min.max(a.min); this.max.min(a.max); this.isEmpty() && this.makeEmpty(); return this }, union: function (a) { this.min.min(a.min); this.max.max(a.max); return this }, applyMatrix4: function () { var a = [new p, new p, new p, new p, new p, new p, new p, new p]; return function (b) { if (this.isEmpty()) return this; a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b); a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b); a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b); a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b); a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b); a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b); a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b); a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b); this.setFromPoints(a); return this } }(), translate: function (a) { this.min.add(a); this.max.add(a); return this }, equals: function (a) { return a.min.equals(this.min) && a.max.equals(this.max) } }); Object.assign(Ea.prototype, { set: function (a, b) { this.center.copy(a); this.radius = b; return this }, setFromPoints: function () { var a = new Va; return function (b, c) { var d = this.center; void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d); for (var e = c = 0, f = b.length; e < f; e++)c = Math.max(c, d.distanceToSquared(b[e])); this.radius = Math.sqrt(c); return this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.center.copy(a.center); this.radius = a.radius; return this }, empty: function () { return 0 >= this.radius }, containsPoint: function (a) { return a.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (a) { return a.distanceTo(this.center) - this.radius }, intersectsSphere: function (a) { var b = this.radius + a.radius; return a.center.distanceToSquared(this.center) <= b * b }, intersectsBox: function (a) { return a.intersectsSphere(this) }, intersectsPlane: function (a) { return Math.abs(a.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (a, b) { var c = this.center.distanceToSquared(a); void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new p); b.copy(a); c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center)); return b }, getBoundingBox: function (a) { void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new Va); a.set(this.center, this.center); a.expandByScalar(this.radius); return a }, applyMatrix4: function (a) { this.center.applyMatrix4(a); this.radius *= a.getMaxScaleOnAxis(); return this }, translate: function (a) { this.center.add(a); return this }, equals: function (a) { return a.center.equals(this.center) && a.radius === this.radius } }); Object.assign(Fa.prototype, {
        set: function (a, b) { this.normal.copy(a); this.constant = b; return this }, setComponents: function (a, b, c, d) { this.normal.set(a, b, c); this.constant = d; return this }, setFromNormalAndCoplanarPoint: function (a, b) { this.normal.copy(a); this.constant = -b.dot(this.normal); return this }, setFromCoplanarPoints: function () { var a = new p, b = new p; return function (c, d, e) { d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(); this.setFromNormalAndCoplanarPoint(d, c); return this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.normal.copy(a.normal); this.constant = a.constant; return this }, normalize: function () { var a = 1 / this.normal.length(); this.normal.multiplyScalar(a); this.constant *= a; return this }, negate: function () { this.constant *= -1; this.normal.negate(); return this }, distanceToPoint: function (a) {
            return this.normal.dot(a) +
                this.constant
        }, distanceToSphere: function (a) { return this.distanceToPoint(a.center) - a.radius }, projectPoint: function (a, b) { void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new p); return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a) }, intersectLine: function () { var a = new p; return function (b, c) { void 0 === c && (console.warn("THREE.Plane: .intersectLine() target is now required"), c = new p); var d = b.delta(a), e = this.normal.dot(d); if (0 === e) { if (0 === this.distanceToPoint(b.start)) return c.copy(b.start) } else if (e = -(b.start.dot(this.normal) + this.constant) / e, !(0 > e || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start) } }(), intersectsLine: function (a) { var b = this.distanceToPoint(a.start); a = this.distanceToPoint(a.end); return 0 > b && 0 < a || 0 > a && 0 < b }, intersectsBox: function (a) { return a.intersectsPlane(this) }, intersectsSphere: function (a) { return a.intersectsPlane(this) }, coplanarPoint: function (a) { void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new p); return a.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var a = new p, b = new sa; return function (c, d) { d = d || b.getNormalMatrix(c); c = this.coplanarPoint(a).applyMatrix4(c); d = this.normal.applyMatrix3(d).normalize(); this.constant = -c.dot(d); return this } }(), translate: function (a) { this.constant -= a.dot(this.normal); return this }, equals: function (a) { return a.normal.equals(this.normal) && a.constant === this.constant }
    }); Object.assign(ld.prototype, {
        set: function (a, b, c, d, e, f) { var g = this.planes; g[0].copy(a); g[1].copy(b); g[2].copy(c); g[3].copy(d); g[4].copy(e); g[5].copy(f); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)b[c].copy(a.planes[c]); return this }, setFromMatrix: function (a) {
            var b = this.planes, c = a.elements; a = c[0]; var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], l = c[6], m = c[7], k = c[8], n = c[9], p = c[10], r = c[11], q = c[12], v = c[13], x = c[14]; c = c[15]; b[0].setComponents(f - a, m - g, r - k, c - q).normalize(); b[1].setComponents(f + a, m + g, r + k, c + q).normalize(); b[2].setComponents(f + d, m + h, r + n, c + v).normalize(); b[3].setComponents(f -
                d, m - h, r - n, c - v).normalize(); b[4].setComponents(f - e, m - l, r - p, c - x).normalize(); b[5].setComponents(f + e, m + l, r + p, c + x).normalize(); return this
        }, intersectsObject: function () { var a = new Ea; return function (b) { var c = b.geometry; null === c.boundingSphere && c.computeBoundingSphere(); a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld); return this.intersectsSphere(a) } }(), intersectsSprite: function () { var a = new Ea; return function (b) { a.center.set(0, 0, 0); a.radius = .7071067811865476; a.applyMatrix4(b.matrixWorld); return this.intersectsSphere(a) } }(), intersectsSphere: function (a) { var b = this.planes, c = a.center; a = -a.radius; for (var d = 0; 6 > d; d++)if (b[d].distanceToPoint(c) < a) return !1; return !0 }, intersectsBox: function () { var a = new p, b = new p; return function (c) { for (var d = this.planes, e = 0; 6 > e; e++) { var f = d[e]; a.x = 0 < f.normal.x ? c.min.x : c.max.x; b.x = 0 < f.normal.x ? c.max.x : c.min.x; a.y = 0 < f.normal.y ? c.min.y : c.max.y; b.y = 0 < f.normal.y ? c.max.y : c.min.y; a.z = 0 < f.normal.z ? c.min.z : c.max.z; b.z = 0 < f.normal.z ? c.max.z : c.min.z; var g = f.distanceToPoint(a); f = f.distanceToPoint(b); if (0 > g && 0 > f) return !1 } return !0 } }(), containsPoint: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)if (0 > b[c].distanceToPoint(a)) return !1; return !0 }
    }); var V = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "\nvec3 transformed = vec3( position );\n", beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n", bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n", lights_pars_maps: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n", normal_fragment_maps: "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n", dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n", cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n" }, Da = { merge: function (a) { for (var b = {}, c = 0; c < a.length; c++) { var d = this.clone(a[c]), e; for (e in d) b[e] = d[e] } return b }, clone: function (a) { var b = {}, c; for (c in a) { b[c] = {}; for (var d in a[c]) { var e = a[c][d]; e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e } } return b } }, Kg = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; Object.assign(I.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (a) { a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a); return this }, setScalar: function (a) { this.b = this.g = this.r = a; return this }, setHex: function (a) { a = Math.floor(a); this.r = (a >> 16 & 255) / 255; this.g = (a >> 8 & 255) / 255; this.b = (a & 255) / 255; return this }, setRGB: function (a, b, c) { this.r = a; this.g = b; this.b = c; return this }, setHSL: function () { function a(a, c, d) { 0 > d && (d += 1); 1 < d && --d; return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a } return function (b, c, d) { b = S.euclideanModulo(b, 1); c = S.clamp(c, 0, 1); d = S.clamp(d, 0, 1); 0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)); return this } }(), setStyle: function (a) { function b(b) { void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.") } var c; if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) { var d = c[2]; switch (c[1]) { case "rgb": case "rgba": if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this; if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this; break; case "hsl": case "hsla": if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) { d = parseFloat(c[1]) / 360; var e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100; b(c[5]); return this.setHSL(d, e, f) } } } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) { c = c[1]; d = c.length; if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this } a && 0 < a.length && (c = Kg[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)); return this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (a) { this.r = a.r; this.g = a.g; this.b = a.b; return this }, copyGammaToLinear: function (a, b) { void 0 === b && (b = 2); this.r = Math.pow(a.r, b); this.g = Math.pow(a.g, b); this.b = Math.pow(a.b, b); return this }, copyLinearToGamma: function (a, b) { void 0 === b && (b = 2); b = 0 < b ? 1 / b : 1; this.r = Math.pow(a.r, b); this.g = Math.pow(a.g, b); this.b = Math.pow(a.b, b); return this }, convertGammaToLinear: function () { var a = this.r, b = this.g, c = this.b; this.r = a * a; this.g = b * b; this.b = c * c; return this }, convertLinearToGamma: function () { this.r = Math.sqrt(this.r); this.g = Math.sqrt(this.g); this.b = Math.sqrt(this.b); return this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (a) { void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = { h: 0, s: 0, l: 0 }); var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2; if (f === e) f = g = 0; else { var l = e - f; f = .5 >= h ? l / (e + f) : l / (2 - e - f); switch (e) { case b: g = (c - d) / l + (c < d ? 6 : 0); break; case c: g = (d - b) / l + 2; break; case d: g = (b - c) / l + 4 }g /= 6 } a.h = g; a.s = f; a.l = h; return a }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function () { var a = {}; return function (b, c, d) { this.getHSL(a); a.h += b; a.s += c; a.l += d; this.setHSL(a.h, a.s, a.l); return this } }(), add: function (a) { this.r += a.r; this.g += a.g; this.b += a.b; return this }, addColors: function (a, b) { this.r = a.r + b.r; this.g = a.g + b.g; this.b = a.b + b.b; return this }, addScalar: function (a) { this.r += a; this.g += a; this.b += a; return this }, sub: function (a) { this.r = Math.max(0, this.r - a.r); this.g = Math.max(0, this.g - a.g); this.b = Math.max(0, this.b - a.b); return this }, multiply: function (a) { this.r *= a.r; this.g *= a.g; this.b *= a.b; return this }, multiplyScalar: function (a) { this.r *= a; this.g *= a; this.b *= a; return this }, lerp: function (a, b) { this.r += (a.r - this.r) * b; this.g += (a.g - this.g) * b; this.b += (a.b - this.b) * b; return this }, equals: function (a) { return a.r === this.r && a.g === this.g && a.b === this.b }, fromArray: function (a, b) { void 0 === b && (b = 0); this.r = a[b]; this.g = a[b + 1]; this.b = a[b + 2]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.r; a[b + 1] = this.g; a[b + 2] = this.b; return a }, toJSON: function () { return this.getHex() } }); var L = { common: { diffuse: { value: new I(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new sa }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new C(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 2.5E-4 }, fogNear: { value: 1 }, fogFar: { value: 2E3 }, fogColor: { value: new I(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new I(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new sa } } }, rb = { basic: { uniforms: Da.merge([L.common, L.specularmap, L.envmap, L.aomap, L.lightmap, L.fog]), vertexShader: V.meshbasic_vert, fragmentShader: V.meshbasic_frag }, lambert: { uniforms: Da.merge([L.common, L.specularmap, L.envmap, L.aomap, L.lightmap, L.emissivemap, L.fog, L.lights, { emissive: { value: new I(0) } }]), vertexShader: V.meshlambert_vert, fragmentShader: V.meshlambert_frag }, phong: { uniforms: Da.merge([L.common, L.specularmap, L.envmap, L.aomap, L.lightmap, L.emissivemap, L.bumpmap, L.normalmap, L.displacementmap, L.gradientmap, L.fog, L.lights, { emissive: { value: new I(0) }, specular: { value: new I(1118481) }, shininess: { value: 30 } }]), vertexShader: V.meshphong_vert, fragmentShader: V.meshphong_frag }, standard: { uniforms: Da.merge([L.common, L.envmap, L.aomap, L.lightmap, L.emissivemap, L.bumpmap, L.normalmap, L.displacementmap, L.roughnessmap, L.metalnessmap, L.fog, L.lights, { emissive: { value: new I(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: V.meshphysical_vert, fragmentShader: V.meshphysical_frag }, points: { uniforms: Da.merge([L.points, L.fog]), vertexShader: V.points_vert, fragmentShader: V.points_frag }, dashed: { uniforms: Da.merge([L.common, L.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: V.linedashed_vert, fragmentShader: V.linedashed_frag }, depth: { uniforms: Da.merge([L.common, L.displacementmap]), vertexShader: V.depth_vert, fragmentShader: V.depth_frag }, normal: { uniforms: Da.merge([L.common, L.bumpmap, L.normalmap, L.displacementmap, { opacity: { value: 1 } }]), vertexShader: V.normal_vert, fragmentShader: V.normal_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: V.cube_vert, fragmentShader: V.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: V.equirect_vert, fragmentShader: V.equirect_frag }, distanceRGBA: { uniforms: Da.merge([L.common, L.displacementmap, { referencePosition: { value: new p }, nearDistance: { value: 1 }, farDistance: { value: 1E3 } }]), vertexShader: V.distanceRGBA_vert, fragmentShader: V.distanceRGBA_frag }, shadow: { uniforms: Da.merge([L.lights, L.fog, { color: { value: new I(0) }, opacity: { value: 1 } }]), vertexShader: V.shadow_vert, fragmentShader: V.shadow_frag } }; rb.physical = { uniforms: Da.merge([rb.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: V.meshphysical_vert, fragmentShader: V.meshphysical_frag }; jb.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "); jb.DefaultOrder = "XYZ"; Object.defineProperties(jb.prototype, { x: { get: function () { return this._x }, set: function (a) { this._x = a; this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (a) { this._y = a; this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (a) { this._z = a; this.onChangeCallback() } }, order: { get: function () { return this._order }, set: function (a) { this._order = a; this.onChangeCallback() } } }); Object.assign(jb.prototype, { isEuler: !0, set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._order = d || this._order; this.onChangeCallback(); return this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (a) { this._x = a._x; this._y = a._y; this._z = a._z; this._order = a._order; this.onChangeCallback(); return this }, setFromRotationMatrix: function (a, b, c) { var d = S.clamp, e = a.elements; a = e[0]; var f = e[4], g = e[8], h = e[1], l = e[5], m = e[9], k = e[2], n = e[6]; e = e[10]; b = b || this._order; "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-m, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(n, l), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-k, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(n, -1, 1)), .99999 > Math.abs(n) ? (this._y = Math.atan2(-k, e), this._z = Math.atan2(-f, l)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), .99999 > Math.abs(k) ? (this._x = Math.atan2(n, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, l))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-m, l), this._y = Math.atan2(-k, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(n, l), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b); this._order = b; if (!1 !== c) this.onChangeCallback(); return this }, setFromQuaternion: function () { var a = new M; return function (b, c, d) { a.makeRotationFromQuaternion(b); return this.setFromRotationMatrix(a, c, d) } }(), setFromVector3: function (a, b) { return this.set(a.x, a.y, a.z, b || this._order) }, reorder: function () { var a = new ja; return function (b) { a.setFromEuler(this); return this.setFromQuaternion(a, b) } }(), equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order }, fromArray: function (a) { this._x = a[0]; this._y = a[1]; this._z = a[2]; void 0 !== a[3] && (this._order = a[3]); this.onChangeCallback(); return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._order; return a }, toVector3: function (a) { return a ? a.set(this._x, this._y, this._z) : new p(this._x, this._y, this._z) }, onChange: function (a) { this.onChangeCallback = a; return this }, onChangeCallback: function () { } }); Object.assign(Sd.prototype, { set: function (a) { this.mask = 1 << a | 0 }, enable: function (a) { this.mask = this.mask | 1 << a | 0 }, toggle: function (a) { this.mask ^= 1 << a | 0 }, disable: function (a) { this.mask &= ~(1 << a | 0) }, test: function (a) { return 0 !== (this.mask & a.mask) } }); var zf = 0; A.DefaultUp = new p(0, 1, 0); A.DefaultMatrixAutoUpdate = !0; A.prototype = Object.assign(Object.create(xa.prototype), { constructor: A, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (a) { this.matrix.multiplyMatrices(a, this.matrix); this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (a) { this.quaternion.premultiply(a); return this }, setRotationFromAxisAngle: function (a, b) { this.quaternion.setFromAxisAngle(a, b) }, setRotationFromEuler: function (a) { this.quaternion.setFromEuler(a, !0) }, setRotationFromMatrix: function (a) { this.quaternion.setFromRotationMatrix(a) }, setRotationFromQuaternion: function (a) { this.quaternion.copy(a) }, rotateOnAxis: function () { var a = new ja; return function (b, c) { a.setFromAxisAngle(b, c); this.quaternion.multiply(a); return this } }(), rotateOnWorldAxis: function () { var a = new ja; return function (b, c) { a.setFromAxisAngle(b, c); this.quaternion.premultiply(a); return this } }(), rotateX: function () { var a = new p(1, 0, 0); return function (b) { return this.rotateOnAxis(a, b) } }(), rotateY: function () { var a = new p(0, 1, 0); return function (b) { return this.rotateOnAxis(a, b) } }(), rotateZ: function () { var a = new p(0, 0, 1); return function (b) { return this.rotateOnAxis(a, b) } }(), translateOnAxis: function () { var a = new p; return function (b, c) { a.copy(b).applyQuaternion(this.quaternion); this.position.add(a.multiplyScalar(c)); return this } }(), translateX: function () { var a = new p(1, 0, 0); return function (b) { return this.translateOnAxis(a, b) } }(), translateY: function () { var a = new p(0, 1, 0); return function (b) { return this.translateOnAxis(a, b) } }(), translateZ: function () { var a = new p(0, 0, 1); return function (b) { return this.translateOnAxis(a, b) } }(), localToWorld: function (a) { return a.applyMatrix4(this.matrixWorld) }, worldToLocal: function () { var a = new M; return function (b) { return b.applyMatrix4(a.getInverse(this.matrixWorld)) } }(), lookAt: function () { var a = new M, b = new p; return function (c, d, e) { c.isVector3 ? b.copy(c) : b.set(c, d, e); this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up); this.quaternion.setFromRotationMatrix(a) } }(), add: function (a) { if (1 < arguments.length) { for (var b = 0; b < arguments.length; b++)this.add(arguments[b]); return this } if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this; a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({ type: "added" }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a); return this }, remove: function (a) { if (1 < arguments.length) { for (var b = 0; b < arguments.length; b++)this.remove(arguments[b]); return this } b = this.children.indexOf(a); -1 !== b && (a.parent = null, a.dispatchEvent({ type: "removed" }), this.children.splice(b, 1)); return this }, getObjectById: function (a) { return this.getObjectByProperty("id", a) }, getObjectByName: function (a) { return this.getObjectByProperty("name", a) }, getObjectByProperty: function (a, b) { if (this[a] === b) return this; for (var c = 0, d = this.children.length; c < d; c++) { var e = this.children[c].getObjectByProperty(a, b); if (void 0 !== e) return e } }, getWorldPosition: function (a) { void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new p); this.updateMatrixWorld(!0); return a.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function () { var a = new p, b = new p; return function (c) { void 0 === c && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), c = new ja); this.updateMatrixWorld(!0); this.matrixWorld.decompose(a, c, b); return c } }(), getWorldScale: function () { var a = new p, b = new ja; return function (c) { void 0 === c && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), c = new p); this.updateMatrixWorld(!0); this.matrixWorld.decompose(a, b, c); return c } }(), getWorldDirection: function () { var a = new ja; return function (b) { void 0 === b && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), b = new p); this.getWorldQuaternion(a); return b.set(0, 0, 1).applyQuaternion(a) } }(), raycast: function () { }, traverse: function (a) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverse(a) }, traverseVisible: function (a) { if (!1 !== this.visible) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverseVisible(a) } }, traverseAncestors: function (a) { var b = this.parent; null !== b && (a(b), b.traverseAncestors(a)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale); this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (a) { this.matrixAutoUpdate && this.updateMatrix(); if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0; for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].updateMatrixWorld(a) }, toJSON: function (a) { function b(b, c) { void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)); return c.uuid } function c(a) { var b = [], c; for (c in a) { var d = a[c]; delete d.metadata; b.push(d) } return b } var d = void 0 === a || "string" === typeof a, e = {}; d && (a = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var f = {}; f.uuid = this.uuid; f.type = this.type; "" !== this.name && (f.name = this.name); !0 === this.castShadow && (f.castShadow = !0); !0 === this.receiveShadow && (f.receiveShadow = !0); !1 === this.visible && (f.visible = !1); !1 === this.frustumCulled && (f.frustumCulled = !1); 0 !== this.renderOrder && (f.renderOrder = this.renderOrder); "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData); f.matrix = this.matrix.toArray(); if (void 0 !== this.geometry) { f.geometry = b(a.geometries, this.geometry); var g = this.geometry.parameters; if (void 0 !== g && void 0 !== g.shapes) if (g = g.shapes, Array.isArray(g)) for (var h = 0, l = g.length; h < l; h++)b(a.shapes, g[h]); else b(a.shapes, g) } if (void 0 !== this.material) if (Array.isArray(this.material)) { g = []; h = 0; for (l = this.material.length; h < l; h++)g.push(b(a.materials, this.material[h])); f.material = g } else f.material = b(a.materials, this.material); if (0 < this.children.length) for (f.children = [], h = 0; h < this.children.length; h++)f.children.push(this.children[h].toJSON(a).object); if (d) { d = c(a.geometries); h = c(a.materials); l = c(a.textures); var m = c(a.images); g = c(a.shapes); 0 < d.length && (e.geometries = d); 0 < h.length && (e.materials = h); 0 < l.length && (e.textures = l); 0 < m.length && (e.images = m); 0 < g.length && (e.shapes = g) } e.object = f; return e }, clone: function (a) { return (new this.constructor).copy(this, a) }, copy: function (a, b) { void 0 === b && (b = !0); this.name = a.name; this.up.copy(a.up); this.position.copy(a.position); this.quaternion.copy(a.quaternion); this.scale.copy(a.scale); this.matrix.copy(a.matrix); this.matrixWorld.copy(a.matrixWorld); this.matrixAutoUpdate = a.matrixAutoUpdate; this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate; this.layers.mask = a.layers.mask; this.visible = a.visible; this.castShadow = a.castShadow; this.receiveShadow = a.receiveShadow; this.frustumCulled = a.frustumCulled; this.renderOrder = a.renderOrder; this.userData = JSON.parse(JSON.stringify(a.userData)); if (!0 === b) for (b = 0; b < a.children.length; b++)this.add(a.children[b].clone()); return this } }); Qa.prototype = Object.assign(Object.create(A.prototype), { constructor: Qa, isCamera: !0, copy: function (a, b) { A.prototype.copy.call(this, a, b); this.matrixWorldInverse.copy(a.matrixWorldInverse); this.projectionMatrix.copy(a.projectionMatrix); return this }, getWorldDirection: function () { var a = new ja; return function (b) { void 0 === b && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), b = new p); this.getWorldQuaternion(a); return b.set(0, 0, -1).applyQuaternion(a) } }(), updateMatrixWorld: function (a) { A.prototype.updateMatrixWorld.call(this, a); this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }); Jb.prototype = Object.assign(Object.create(Qa.prototype), { constructor: Jb, isOrthographicCamera: !0, copy: function (a, b) { Qa.prototype.copy.call(this, a, b); this.left = a.left; this.right = a.right; this.top = a.top; this.bottom = a.bottom; this.near = a.near; this.far = a.far; this.zoom = a.zoom; this.view = null === a.view ? null : Object.assign({}, a.view); return this }, setViewOffset: function (a, b, c, d, e, f) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }); this.view.enabled = !0; this.view.fullWidth = a; this.view.fullHeight = b; this.view.offsetX = c; this.view.offsetY = d; this.view.width = e; this.view.height = f; this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1); this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2, e = c - a; c += a; a = d + b; b = d - b; if (null !== this.view && this.view.enabled) { c = this.zoom / (this.view.width / this.view.fullWidth); b = this.zoom / (this.view.height / this.view.fullHeight); var f = (this.right - this.left) / this.view.width; d = (this.top - this.bottom) / this.view.height; e += this.view.offsetX / c * f; c = e + this.view.width / c * f; a -= this.view.offsetY / b * d; b = a - this.view.height / b * d } this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far) }, toJSON: function (a) { a = A.prototype.toJSON.call(this, a); a.object.zoom = this.zoom; a.object.left = this.left; a.object.right = this.right; a.object.top = this.top; a.object.bottom = this.bottom; a.object.near = this.near; a.object.far = this.far; null !== this.view && (a.object.view = Object.assign({}, this.view)); return a } }); Object.assign(Wa.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.a = a.a; this.b = a.b; this.c = a.c; this.normal.copy(a.normal); this.color.copy(a.color); this.materialIndex = a.materialIndex; for (var b = 0, c = a.vertexNormals.length; b < c; b++)this.vertexNormals[b] = a.vertexNormals[b].clone(); b = 0; for (c = a.vertexColors.length; b < c; b++)this.vertexColors[b] = a.vertexColors[b].clone(); return this } }); var Af = 0; N.prototype = Object.assign(Object.create(xa.prototype), { constructor: N, isGeometry: !0, applyMatrix: function (a) { for (var b = (new sa).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)this.vertices[c].applyMatrix4(a); c = 0; for (d = this.faces.length; c < d; c++) { a = this.faces[c]; a.normal.applyMatrix3(b).normalize(); for (var e = 0, f = a.vertexNormals.length; e < f; e++)a.vertexNormals[e].applyMatrix3(b).normalize() } null !== this.boundingBox && this.computeBoundingBox(); null !== this.boundingSphere && this.computeBoundingSphere(); this.normalsNeedUpdate = this.verticesNeedUpdate = !0; return this }, rotateX: function () { var a = new M; return function (b) { a.makeRotationX(b); this.applyMatrix(a); return this } }(), rotateY: function () { var a = new M; return function (b) { a.makeRotationY(b); this.applyMatrix(a); return this } }(), rotateZ: function () { var a = new M; return function (b) { a.makeRotationZ(b); this.applyMatrix(a); return this } }(), translate: function () { var a = new M; return function (b, c, d) { a.makeTranslation(b, c, d); this.applyMatrix(a); return this } }(), scale: function () { var a = new M; return function (b, c, d) { a.makeScale(b, c, d); this.applyMatrix(a); return this } }(), lookAt: function () { var a = new A; return function (b) { a.lookAt(b); a.updateMatrix(); this.applyMatrix(a.matrix) } }(), fromBufferGeometry: function (a) { function b(a, b, d, e) { var f = void 0 !== g ? [k[a].clone(), k[b].clone(), k[d].clone()] : [], p = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : []; e = new Wa(a, b, d, f, p, e); c.faces.push(e); void 0 !== l && c.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[d].clone()]); void 0 !== m && c.faceVertexUvs[1].push([t[a].clone(), t[b].clone(), t[d].clone()]) } var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes, f = e.position.array, g = void 0 !== e.normal ? e.normal.array : void 0, h = void 0 !== e.color ? e.color.array : void 0, l = void 0 !== e.uv ? e.uv.array : void 0, m = void 0 !== e.uv2 ? e.uv2.array : void 0; void 0 !== m && (this.faceVertexUvs[1] = []); for (var k = [], n = [], t = [], r = e = 0; e < f.length; e += 3, r += 2)c.vertices.push(new p(f[e], f[e + 1], f[e + 2])), void 0 !== g && k.push(new p(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new I(h[e], h[e + 1], h[e + 2])), void 0 !== l && n.push(new C(l[r], l[r + 1])), void 0 !== m && t.push(new C(m[r], m[r + 1])); var q = a.groups; if (0 < q.length) for (e = 0; e < q.length; e++) { f = q[e]; var v = f.start, x = f.count; r = v; for (v += x; r < v; r += 3)void 0 !== d ? b(d[r], d[r + 1], d[r + 2], f.materialIndex) : b(r, r + 1, r + 2, f.materialIndex) } else if (void 0 !== d) for (e = 0; e < d.length; e += 3)b(d[e], d[e + 1], d[e + 2]); else for (e = 0; e < f.length / 3; e += 3)b(e, e + 1, e + 2); this.computeFaceNormals(); null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()); null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()); return this }, center: function () { var a = new p; return function () { this.computeBoundingBox(); this.boundingBox.getCenter(a).negate(); this.translate(a.x, a.y, a.z); return this } }(), normalize: function () { this.computeBoundingSphere(); var a = this.boundingSphere.center, b = this.boundingSphere.radius; b = 0 === b ? 1 : 1 / b; var c = new M; c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1); this.applyMatrix(c); return this }, computeFaceNormals: function () { for (var a = new p, b = new p, c = 0, d = this.faces.length; c < d; c++) { var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b]; a.subVectors(this.vertices[e.c], g); b.subVectors(f, g); a.cross(b); a.normalize(); e.normal.copy(a) } }, computeVertexNormals: function (a) { void 0 === a && (a = !0); var b; var c = Array(this.vertices.length); var d = 0; for (b = this.vertices.length; d < b; d++)c[d] = new p; if (a) { var e = new p, f = new p; a = 0; for (d = this.faces.length; a < d; a++) { b = this.faces[a]; var g = this.vertices[b.a]; var h = this.vertices[b.b]; var l = this.vertices[b.c]; e.subVectors(l, h); f.subVectors(g, h); e.cross(f); c[b.a].add(e); c[b.b].add(e); c[b.c].add(e) } } else for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++)b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal); d = 0; for (b = this.vertices.length; d < b; d++)c[d].normalize(); a = 0; for (d = this.faces.length; a < d; a++)b = this.faces[a], g = b.vertexNormals, 3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone()); 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { var a; this.computeFaceNormals(); var b = 0; for (a = this.faces.length; b < a; b++) { var c = this.faces[b]; var d = c.vertexNormals; 3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone()) } 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { var a, b; var c = 0; for (b = this.faces.length; c < b; c++) { var d = this.faces[c]; d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone(); d.__originalVertexNormals || (d.__originalVertexNormals = []); var e = 0; for (a = d.vertexNormals.length; e < a; e++)d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone() } var f = new N; f.faces = this.faces; e = 0; for (a = this.morphTargets.length; e < a; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}; this.morphNormals[e].faceNormals = []; this.morphNormals[e].vertexNormals = []; d = this.morphNormals[e].faceNormals; var g = this.morphNormals[e].vertexNormals; c = 0; for (b = this.faces.length; c < b; c++) { var h = new p; var l = { a: new p, b: new p, c: new p }; d.push(h); g.push(l) } } g = this.morphNormals[e]; f.vertices = this.morphTargets[e].vertices; f.computeFaceNormals(); f.computeVertexNormals(); c = 0; for (b = this.faces.length; c < b; c++)d = this.faces[c], h = g.faceNormals[c], l = g.vertexNormals[c], h.copy(d.normal), l.a.copy(d.vertexNormals[0]), l.b.copy(d.vertexNormals[1]), l.c.copy(d.vertexNormals[2]) } c = 0; for (b = this.faces.length; c < b; c++)d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Va); this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Ea); this.boundingSphere.setFromPoints(this.vertices) }, merge: function (a, b, c) { if (a && a.isGeometry) { var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, l = a.faces, m = this.faceVertexUvs[0], k = a.faceVertexUvs[0], n = this.colors, p = a.colors; void 0 === c && (c = 0); void 0 !== b && (d = (new sa).getNormalMatrix(b)); a = 0; for (var r = g.length; a < r; a++) { var q = g[a].clone(); void 0 !== b && q.applyMatrix4(b); f.push(q) } a = 0; for (r = p.length; a < r; a++)n.push(p[a].clone()); a = 0; for (r = l.length; a < r; a++) { g = l[a]; var v = g.vertexNormals; p = g.vertexColors; n = new Wa(g.a + e, g.b + e, g.c + e); n.normal.copy(g.normal); void 0 !== d && n.normal.applyMatrix3(d).normalize(); b = 0; for (f = v.length; b < f; b++)q = v[b].clone(), void 0 !== d && q.applyMatrix3(d).normalize(), n.vertexNormals.push(q); n.color.copy(g.color); b = 0; for (f = p.length; b < f; b++)q = p[b], n.vertexColors.push(q.clone()); n.materialIndex = g.materialIndex + c; h.push(n) } a = 0; for (r = k.length; a < r; a++)if (c = k[a], d = [], void 0 !== c) { b = 0; for (f = c.length; b < f; b++)d.push(c[b].clone()); m.push(d) } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a) }, mergeMesh: function (a) { a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) }, mergeVertices: function () { var a = {}, b = [], c = [], d = Math.pow(10, 4), e; var f = 0; for (e = this.vertices.length; f < e; f++) { var g = this.vertices[f]; g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d); void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]] } a = []; f = 0; for (e = this.faces.length; f < e; f++)for (d = this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++)if (d[g] === d[(g + 1) % 3]) { a.push(f); break } for (f = a.length - 1; 0 <= f; f--)for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++)this.faceVertexUvs[c].splice(d, 1); f = this.vertices.length - b.length; this.vertices = b; return f }, setFromPoints: function (a) { this.vertices = []; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; this.vertices.push(new p(d.x, d.y, d.z || 0)) } return this }, sortFacesByMaterialIndex: function () { for (var a = this.faces, b = a.length, c = 0; c < b; c++)a[c]._id = c; a.sort(function (a, b) { return a.materialIndex - b.materialIndex }); var d = this.faceVertexUvs[0], e = this.faceVertexUvs[1], f, g; d && d.length === b && (f = []); e && e.length === b && (g = []); for (c = 0; c < b; c++) { var h = a[c]._id; f && f.push(d[h]); g && g.push(e[h]) } f && (this.faceVertexUvs[0] = f); g && (this.faceVertexUvs[1] = g) }, toJSON: function () { function a(a, b, c) { return c ? a | 1 << b : a & ~(1 << b) } function b(a) { var b = a.x.toString() + a.y.toString() + a.z.toString(); if (void 0 !== m[b]) return m[b]; m[b] = l.length / 3; l.push(a.x, a.y, a.z); return m[b] } function c(a) { var b = a.r.toString() + a.g.toString() + a.b.toString(); if (void 0 !== n[b]) return n[b]; n[b] = k.length; k.push(a.getHex()); return n[b] } function d(a) { var b = a.x.toString() + a.y.toString(); if (void 0 !== r[b]) return r[b]; r[b] = p.length / 2; p.push(a.x, a.y); return r[b] } var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; e.uuid = this.uuid; e.type = this.type; "" !== this.name && (e.name = this.name); if (void 0 !== this.parameters) { var f = this.parameters, g; for (g in f) void 0 !== f[g] && (e[g] = f[g]); return e } f = []; for (g = 0; g < this.vertices.length; g++) { var h = this.vertices[g]; f.push(h.x, h.y, h.z) } h = []; var l = [], m = {}, k = [], n = {}, p = [], r = {}; for (g = 0; g < this.faces.length; g++) { var q = this.faces[g], v = void 0 !== this.faceVertexUvs[0][g], x = 0 < q.normal.length(), y = 0 < q.vertexNormals.length, w = 1 !== q.color.r || 1 !== q.color.g || 1 !== q.color.b, B = 0 < q.vertexColors.length, G = 0; G = a(G, 0, 0); G = a(G, 1, !0); G = a(G, 2, !1); G = a(G, 3, v); G = a(G, 4, x); G = a(G, 5, y); G = a(G, 6, w); G = a(G, 7, B); h.push(G); h.push(q.a, q.b, q.c); h.push(q.materialIndex); v && (v = this.faceVertexUvs[0][g], h.push(d(v[0]), d(v[1]), d(v[2]))); x && h.push(b(q.normal)); y && (x = q.vertexNormals, h.push(b(x[0]), b(x[1]), b(x[2]))); w && h.push(c(q.color)); B && (q = q.vertexColors, h.push(c(q[0]), c(q[1]), c(q[2]))) } e.data = {}; e.data.vertices = f; e.data.normals = l; 0 < k.length && (e.data.colors = k); 0 < p.length && (e.data.uvs = [p]); e.data.faces = h; return e }, clone: function () { return (new N).copy(this) }, copy: function (a) { var b, c, d; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphNormals = []; this.skinWeights = []; this.skinIndices = []; this.lineDistances = []; this.boundingSphere = this.boundingBox = null; this.name = a.name; var e = a.vertices; var f = 0; for (b = e.length; f < b; f++)this.vertices.push(e[f].clone()); e = a.colors; f = 0; for (b = e.length; f < b; f++)this.colors.push(e[f].clone()); e = a.faces; f = 0; for (b = e.length; f < b; f++)this.faces.push(e[f].clone()); f = 0; for (b = a.faceVertexUvs.length; f < b; f++) { var g = a.faceVertexUvs[f]; void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []); e = 0; for (c = g.length; e < c; e++) { var h = g[e], l = []; var m = 0; for (d = h.length; m < d; m++)l.push(h[m].clone()); this.faceVertexUvs[f].push(l) } } m = a.morphTargets; f = 0; for (b = m.length; f < b; f++) { d = {}; d.name = m[f].name; if (void 0 !== m[f].vertices) for (d.vertices = [], e = 0, c = m[f].vertices.length; e < c; e++)d.vertices.push(m[f].vertices[e].clone()); if (void 0 !== m[f].normals) for (d.normals = [], e = 0, c = m[f].normals.length; e < c; e++)d.normals.push(m[f].normals[e].clone()); this.morphTargets.push(d) } m = a.morphNormals; f = 0; for (b = m.length; f < b; f++) { d = {}; if (void 0 !== m[f].vertexNormals) for (d.vertexNormals = [], e = 0, c = m[f].vertexNormals.length; e < c; e++)g = m[f].vertexNormals[e], h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h); if (void 0 !== m[f].faceNormals) for (d.faceNormals = [], e = 0, c = m[f].faceNormals.length; e < c; e++)d.faceNormals.push(m[f].faceNormals[e].clone()); this.morphNormals.push(d) } e = a.skinWeights; f = 0; for (b = e.length; f < b; f++)this.skinWeights.push(e[f].clone()); e = a.skinIndices; f = 0; for (b = e.length; f < b; f++)this.skinIndices.push(e[f].clone()); e = a.lineDistances; f = 0; for (b = e.length; f < b; f++)this.lineDistances.push(e[f]); f = a.boundingBox; null !== f && (this.boundingBox = f.clone()); f = a.boundingSphere; null !== f && (this.boundingSphere = f.clone()); this.elementsNeedUpdate = a.elementsNeedUpdate; this.verticesNeedUpdate = a.verticesNeedUpdate; this.uvsNeedUpdate = a.uvsNeedUpdate; this.normalsNeedUpdate = a.normalsNeedUpdate; this.colorsNeedUpdate = a.colorsNeedUpdate; this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate; this.groupsNeedUpdate = a.groupsNeedUpdate; return this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); Object.defineProperty(T.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++ } }); Object.assign(T.prototype, {
        isBufferAttribute: !0, onUploadCallback: function () { }, setArray: function (a) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.count = void 0 !== a ? a.length / this.itemSize : 0; this.array = a }, setDynamic: function (a) { this.dynamic = a; return this }, copy: function (a) { this.array = new a.array.constructor(a.array); this.itemSize = a.itemSize; this.count = a.count; this.normalized = a.normalized; this.dynamic = a.dynamic; return this }, copyAt: function (a, b, c) { a *= this.itemSize; c *= b.itemSize; for (var d = 0, e = this.itemSize; d < e; d++)this.array[a + d] = b.array[c + d]; return this }, copyArray: function (a) { this.array.set(a); return this }, copyColorsArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new I); b[c++] = f.r; b[c++] = f.g; b[c++] = f.b } return this }, copyVector2sArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new C); b[c++] = f.x; b[c++] = f.y } return this }, copyVector3sArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new p); b[c++] = f.x; b[c++] = f.y; b[c++] = f.z } return this }, copyVector4sArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new ea); b[c++] = f.x; b[c++] = f.y; b[c++] = f.z; b[c++] = f.w } return this }, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this }, getX: function (a) { return this.array[a * this.itemSize] }, setX: function (a, b) { this.array[a * this.itemSize] = b; return this }, getY: function (a) {
            return this.array[a * this.itemSize +
                1]
        }, setY: function (a, b) { this.array[a * this.itemSize + 1] = b; return this }, getZ: function (a) { return this.array[a * this.itemSize + 2] }, setZ: function (a, b) { this.array[a * this.itemSize + 2] = b; return this }, getW: function (a) { return this.array[a * this.itemSize + 3] }, setW: function (a, b) { this.array[a * this.itemSize + 3] = b; return this }, setXY: function (a, b, c) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; return this }, setXYZ: function (a, b, c, d) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; return this }, setXYZW: function (a, b, c, d, e) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; this.array[a + 3] = e; return this }, onUpload: function (a) { this.onUploadCallback = a; return this }, clone: function () { return (new this.constructor(this.array, this.itemSize)).copy(this) }
    }); rc.prototype = Object.create(T.prototype); rc.prototype.constructor = rc; sc.prototype = Object.create(T.prototype); sc.prototype.constructor = sc; tc.prototype = Object.create(T.prototype); tc.prototype.constructor = tc; uc.prototype = Object.create(T.prototype); uc.prototype.constructor = uc; kb.prototype = Object.create(T.prototype); kb.prototype.constructor = kb; vc.prototype = Object.create(T.prototype); vc.prototype.constructor = vc; lb.prototype = Object.create(T.prototype); lb.prototype.constructor = lb; z.prototype = Object.create(T.prototype); z.prototype.constructor = z; wc.prototype = Object.create(T.prototype); wc.prototype.constructor = wc; Object.assign(Ce.prototype, { computeGroups: function (a) { var b = [], c = void 0; a = a.faces; for (var d = 0; d < a.length; d++) { var e = a[d]; if (e.materialIndex !== c) { c = e.materialIndex; void 0 !== f && (f.count = 3 * d - f.start, b.push(f)); var f = { start: 3 * d, materialIndex: c } } } void 0 !== f && (f.count = 3 * d - f.start, b.push(f)); this.groups = b }, fromGeometry: function (a) { var b = a.faces, c = a.vertices, d = a.faceVertexUvs, e = d[0] && 0 < d[0].length, f = d[1] && 0 < d[1].length, g = a.morphTargets, h = g.length; if (0 < h) { var l = []; for (var m = 0; m < h; m++)l[m] = []; this.morphTargets.position = l } var k = a.morphNormals, n = k.length; if (0 < n) { var p = []; for (m = 0; m < n; m++)p[m] = []; this.morphTargets.normal = p } var r = a.skinIndices, q = a.skinWeights, v = r.length === c.length, x = q.length === c.length; for (m = 0; m < b.length; m++) { var y = b[m]; this.vertices.push(c[y.a], c[y.b], c[y.c]); var w = y.vertexNormals; 3 === w.length ? this.normals.push(w[0], w[1], w[2]) : (w = y.normal, this.normals.push(w, w, w)); w = y.vertexColors; 3 === w.length ? this.colors.push(w[0], w[1], w[2]) : (w = y.color, this.colors.push(w, w, w)); !0 === e && (w = d[0][m], void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", m), this.uvs.push(new C, new C, new C))); !0 === f && (w = d[1][m], void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", m), this.uvs2.push(new C, new C, new C))); for (w = 0; w < h; w++) { var B = g[w].vertices; l[w].push(B[y.a], B[y.b], B[y.c]) } for (w = 0; w < n; w++)B = k[w].vertexNormals[m], p[w].push(B.a, B.b, B.c); v && this.skinIndices.push(r[y.a], r[y.b], r[y.c]); x && this.skinWeights.push(q[y.a], q[y.b], q[y.c]) } this.computeGroups(a); this.verticesNeedUpdate = a.verticesNeedUpdate; this.normalsNeedUpdate = a.normalsNeedUpdate; this.colorsNeedUpdate = a.colorsNeedUpdate; this.uvsNeedUpdate = a.uvsNeedUpdate; this.groupsNeedUpdate = a.groupsNeedUpdate; return this } }); var Bf = 1; F.prototype = Object.assign(Object.create(xa.prototype), { constructor: F, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (a) { Array.isArray(a) ? this.index = new (65535 < De(a) ? lb : kb)(a, 1) : this.index = a }, addAttribute: function (a, b, c) { if (b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute) if ("index" === a) console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b); else return this.attributes[a] = b, this; else console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new T(b, c)) }, getAttribute: function (a) { return this.attributes[a] }, removeAttribute: function (a) { delete this.attributes[a]; return this }, addGroup: function (a, b, c) { this.groups.push({ start: a, count: b, materialIndex: void 0 !== c ? c : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (a, b) { this.drawRange.start = a; this.drawRange.count = b }, applyMatrix: function (a) { var b = this.attributes.position; void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0); b = this.attributes.normal; void 0 !== b && ((new sa).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0); null !== this.boundingBox && this.computeBoundingBox(); null !== this.boundingSphere && this.computeBoundingSphere(); return this }, rotateX: function () { var a = new M; return function (b) { a.makeRotationX(b); this.applyMatrix(a); return this } }(), rotateY: function () { var a = new M; return function (b) { a.makeRotationY(b); this.applyMatrix(a); return this } }(), rotateZ: function () { var a = new M; return function (b) { a.makeRotationZ(b); this.applyMatrix(a); return this } }(), translate: function () { var a = new M; return function (b, c, d) { a.makeTranslation(b, c, d); this.applyMatrix(a); return this } }(), scale: function () { var a = new M; return function (b, c, d) { a.makeScale(b, c, d); this.applyMatrix(a); return this } }(), lookAt: function () { var a = new A; return function (b) { a.lookAt(b); a.updateMatrix(); this.applyMatrix(a.matrix) } }(), center: function () { var a = new p; return function () { this.computeBoundingBox(); this.boundingBox.getCenter(a).negate(); this.translate(a.x, a.y, a.z); return this } }(), setFromObject: function (a) { var b = a.geometry; if (a.isPoints || a.isLine) { a = new z(3 * b.vertices.length, 3); var c = new z(3 * b.colors.length, 3); this.addAttribute("position", a.copyVector3sArray(b.vertices)); this.addAttribute("color", c.copyColorsArray(b.colors)); b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new z(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances))); null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()); null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone()) } else a.isMesh && b && b.isGeometry && this.fromGeometry(b); return this }, setFromPoints: function (a) { for (var b = [], c = 0, d = a.length; c < d; c++) { var e = a[c]; b.push(e.x, e.y, e.z || 0) } this.addAttribute("position", new z(b, 3)); return this }, updateFromObject: function (a) { var b = a.geometry; if (a.isMesh) { var c = b.__directGeometry; !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1); if (void 0 === c) return this.fromGeometry(b); c.verticesNeedUpdate = b.verticesNeedUpdate; c.normalsNeedUpdate = b.normalsNeedUpdate; c.colorsNeedUpdate = b.colorsNeedUpdate; c.uvsNeedUpdate = b.uvsNeedUpdate; c.groupsNeedUpdate = b.groupsNeedUpdate; b.verticesNeedUpdate = !1; b.normalsNeedUpdate = !1; b.colorsNeedUpdate = !1; b.uvsNeedUpdate = !1; b.groupsNeedUpdate = !1; b = c } !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1); !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1); !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1); b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1); b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1); b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1); return this }, fromGeometry: function (a) { a.__directGeometry = (new Ce).fromGeometry(a); return this.fromDirectGeometry(a.__directGeometry) }, fromDirectGeometry: function (a) { var b = new Float32Array(3 * a.vertices.length); this.addAttribute("position", (new T(b, 3)).copyVector3sArray(a.vertices)); 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new T(b, 3)).copyVector3sArray(a.normals))); 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new T(b, 3)).copyColorsArray(a.colors))); 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new T(b, 2)).copyVector2sArray(a.uvs))); 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new T(b, 2)).copyVector2sArray(a.uvs2))); this.groups = a.groups; for (var c in a.morphTargets) { b = []; for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) { var g = d[e], h = new z(3 * g.length, 3); b.push(h.copyVector3sArray(g)) } this.morphAttributes[c] = b } 0 < a.skinIndices.length && (c = new z(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))); 0 < a.skinWeights.length && (c = new z(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))); null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()); null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()); return this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Va); var a = this.attributes.position; void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { var a = new Va, b = new p; return function () { null === this.boundingSphere && (this.boundingSphere = new Ea); var c = this.attributes.position; if (c) { var d = this.boundingSphere.center; a.setFromBufferAttribute(c); a.getCenter(d); for (var e = 0, f = 0, g = c.count; f < g; f++)b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b)); this.boundingSphere.radius = Math.sqrt(e); isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } }(), computeFaceNormals: function () { }, computeVertexNormals: function () { var a = this.index, b = this.attributes, c = this.groups; if (b.position) { var d = b.position.array; if (void 0 === b.normal) this.addAttribute("normal", new T(new Float32Array(d.length), 3)); else for (var e = b.normal.array, f = 0, g = e.length; f < g; f++)e[f] = 0; e = b.normal.array; var h = new p, l = new p, m = new p, k = new p, n = new p; if (a) { a = a.array; 0 === c.length && this.addGroup(0, a.length); for (var t = 0, r = c.length; t < r; ++t) { f = c[t]; g = f.start; var q = f.count; f = g; for (g += q; f < g; f += 3) { q = 3 * a[f + 0]; var v = 3 * a[f + 1]; var x = 3 * a[f + 2]; h.fromArray(d, q); l.fromArray(d, v); m.fromArray(d, x); k.subVectors(m, l); n.subVectors(h, l); k.cross(n); e[q] += k.x; e[q + 1] += k.y; e[q + 2] += k.z; e[v] += k.x; e[v + 1] += k.y; e[v + 2] += k.z; e[x] += k.x; e[x + 1] += k.y; e[x + 2] += k.z } } } else for (f = 0, g = d.length; f < g; f += 9)h.fromArray(d, f), l.fromArray(d, f + 3), m.fromArray(d, f + 6), k.subVectors(m, l), n.subVectors(h, l), k.cross(n), e[f] = k.x, e[f + 1] = k.y, e[f + 2] = k.z, e[f + 3] = k.x, e[f + 4] = k.y, e[f + 5] = k.z, e[f + 6] = k.x, e[f + 7] = k.y, e[f + 8] = k.z; this.normalizeNormals(); b.normal.needsUpdate = !0 } }, merge: function (a, b) { if (a && a.isBufferGeometry) { void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var c = this.attributes, d; for (d in c) if (void 0 !== a.attributes[d]) { var e = c[d].array, f = a.attributes[d], g = f.array, h = 0; for (f = f.itemSize * b; h < g.length; h++, f++)e[f] = g[h] } return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a) }, normalizeNormals: function () { var a = new p; return function () { for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z) } }(), toNonIndexed: function () { if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var a = new F, b = this.index.array, c = this.attributes, d; for (d in c) { var e = c[d], f = e.array, g = e.itemSize, h = new f.constructor(b.length * g), l = 0; e = 0; for (var m = b.length; e < m; e++) { var k = b[e] * g; for (var n = 0; n < g; n++)h[l++] = f[k++] } a.addAttribute(d, new T(h, g)) } b = this.groups; e = 0; for (m = b.length; e < m; e++)c = b[e], a.addGroup(c.start, c.count, c.materialIndex); return a }, toJSON: function () { var a = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; a.uuid = this.uuid; a.type = this.type; "" !== this.name && (a.name = this.name); if (void 0 !== this.parameters) { var b = this.parameters; for (e in b) void 0 !== b[e] && (a[e] = b[e]); return a } a.data = { attributes: {} }; var c = this.index; null !== c && (b = Array.prototype.slice.call(c.array), a.data.index = { type: c.array.constructor.name, array: b }); c = this.attributes; for (e in c) { var d = c[e]; b = Array.prototype.slice.call(d.array); a.data.attributes[e] = { itemSize: d.itemSize, type: d.array.constructor.name, array: b, normalized: d.normalized } } var e = this.groups; 0 < e.length && (a.data.groups = JSON.parse(JSON.stringify(e))); e = this.boundingSphere; null !== e && (a.data.boundingSphere = { center: e.center.toArray(), radius: e.radius }); return a }, clone: function () { return (new F).copy(this) }, copy: function (a) { var b; this.index = null; this.attributes = {}; this.morphAttributes = {}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.name = a.name; var c = a.index; null !== c && this.setIndex(c.clone()); c = a.attributes; for (g in c) this.addAttribute(g, c[g].clone()); var d = a.morphAttributes; for (g in d) { var e = [], f = d[g]; c = 0; for (b = f.length; c < b; c++)e.push(f[c].clone()); this.morphAttributes[g] = e } var g = a.groups; c = 0; for (b = g.length; c < b; c++)d = g[c], this.addGroup(d.start, d.count, d.materialIndex); g = a.boundingBox; null !== g && (this.boundingBox = g.clone()); g = a.boundingSphere; null !== g && (this.boundingSphere = g.clone()); this.drawRange.start = a.drawRange.start; this.drawRange.count = a.drawRange.count; return this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); Kb.prototype = Object.create(N.prototype); Kb.prototype.constructor = Kb; mb.prototype = Object.create(F.prototype); mb.prototype.constructor = mb; xc.prototype = Object.create(N.prototype); xc.prototype.constructor = xc; pb.prototype = Object.create(F.prototype); pb.prototype.constructor = pb; var Cf = 0; O.prototype = Object.assign(Object.create(xa.prototype), { constructor: O, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (a) { if (void 0 !== a) for (var b in a) { var c = a[b]; if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 : !1; else { var d = this[b]; void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c } } }, toJSON: function (a) { function b(a) { var b = [], c; for (c in a) { var d = a[c]; delete d.metadata; b.push(d) } return b } var c = void 0 === a || "string" === typeof a; c && (a = { textures: {}, images: {} }); var d = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; d.uuid = this.uuid; d.type = this.type; "" !== this.name && (d.name = this.name); this.color && this.color.isColor && (d.color = this.color.getHex()); void 0 !== this.roughness && (d.roughness = this.roughness); void 0 !== this.metalness && (d.metalness = this.metalness); this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()); 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity); this.specular && this.specular.isColor && (d.specular = this.specular.getHex()); void 0 !== this.shininess && (d.shininess = this.shininess); void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat); void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness); this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid); this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid); this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid); this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale); this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()); this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias); this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid); this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid); this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid); this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid); this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity); this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid); void 0 !== this.size && (d.size = this.size); void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation); 1 !== this.blending && (d.blending = this.blending); !0 === this.flatShading && (d.flatShading = this.flatShading); 0 !== this.side && (d.side = this.side); 0 !== this.vertexColors && (d.vertexColors = this.vertexColors); 1 > this.opacity && (d.opacity = this.opacity); !0 === this.transparent && (d.transparent = this.transparent); d.depthFunc = this.depthFunc; d.depthTest = this.depthTest; d.depthWrite = this.depthWrite; 0 !== this.rotation && (d.rotation = this.rotation); 1 !== this.linewidth && (d.linewidth = this.linewidth); void 0 !== this.dashSize && (d.dashSize = this.dashSize); void 0 !== this.gapSize && (d.gapSize = this.gapSize); void 0 !== this.scale && (d.scale = this.scale); !0 === this.dithering && (d.dithering = !0); 0 < this.alphaTest && (d.alphaTest = this.alphaTest); !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha); !0 === this.wireframe && (d.wireframe = this.wireframe); 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth); "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap); "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin); !0 === this.morphTargets && (d.morphTargets = !0); !0 === this.skinning && (d.skinning = !0); !1 === this.visible && (d.visible = !1); "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData); c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)); return d }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.name = a.name; this.fog = a.fog; this.lights = a.lights; this.blending = a.blending; this.side = a.side; this.flatShading = a.flatShading; this.vertexColors = a.vertexColors; this.opacity = a.opacity; this.transparent = a.transparent; this.blendSrc = a.blendSrc; this.blendDst = a.blendDst; this.blendEquation = a.blendEquation; this.blendSrcAlpha = a.blendSrcAlpha; this.blendDstAlpha = a.blendDstAlpha; this.blendEquationAlpha = a.blendEquationAlpha; this.depthFunc = a.depthFunc; this.depthTest = a.depthTest; this.depthWrite = a.depthWrite; this.colorWrite = a.colorWrite; this.precision = a.precision; this.polygonOffset = a.polygonOffset; this.polygonOffsetFactor = a.polygonOffsetFactor; this.polygonOffsetUnits = a.polygonOffsetUnits; this.dithering = a.dithering; this.alphaTest = a.alphaTest; this.premultipliedAlpha = a.premultipliedAlpha; this.overdraw = a.overdraw; this.visible = a.visible; this.userData = JSON.parse(JSON.stringify(a.userData)); this.clipShadows = a.clipShadows; this.clipIntersection = a.clipIntersection; var b = a.clippingPlanes, c = null; if (null !== b) { var d = b.length; c = Array(d); for (var e = 0; e !== d; ++e)c[e] = b[e].clone() } this.clippingPlanes = c; this.shadowSide = a.shadowSide; return this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); za.prototype = Object.create(O.prototype); za.prototype.constructor = za; za.prototype.isMeshBasicMaterial = !0; za.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; return this }; va.prototype = Object.create(O.prototype); va.prototype.constructor = va; va.prototype.isShaderMaterial = !0; va.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.fragmentShader = a.fragmentShader; this.vertexShader = a.vertexShader; this.uniforms = Da.clone(a.uniforms); this.defines = a.defines; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.lights = a.lights; this.clipping = a.clipping; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; this.extensions = a.extensions; return this }; va.prototype.toJSON = function (a) { a = O.prototype.toJSON.call(this, a); a.uniforms = this.uniforms; a.vertexShader = this.vertexShader; a.fragmentShader = this.fragmentShader; return a }; Object.assign(qb.prototype, { set: function (a, b) { this.origin.copy(a); this.direction.copy(b); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.origin.copy(a.origin); this.direction.copy(a.direction); return this }, at: function (a, b) { void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new p); return b.copy(this.direction).multiplyScalar(a).add(this.origin) }, lookAt: function (a) { this.direction.copy(a).sub(this.origin).normalize(); return this }, recast: function () { var a = new p; return function (b) { this.origin.copy(this.at(b, a)); return this } }(), closestPointToPoint: function (a, b) { void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new p); b.subVectors(a, this.origin); a = b.dot(this.direction); return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin) }, distanceToPoint: function (a) { return Math.sqrt(this.distanceSqToPoint(a)) }, distanceSqToPoint: function () { var a = new p; return function (b) { var c = a.subVectors(b, this.origin).dot(this.direction); if (0 > c) return this.origin.distanceToSquared(b); a.copy(this.direction).multiplyScalar(c).add(this.origin); return a.distanceToSquared(b) } }(), distanceSqToSegment: function () { var a = new p, b = new p, c = new p; return function (d, e, f, g) { a.copy(d).add(e).multiplyScalar(.5); b.copy(e).sub(d).normalize(); c.copy(this.origin).sub(a); var h = .5 * d.distanceTo(e), l = -this.direction.dot(b), m = c.dot(this.direction), k = -c.dot(b), n = c.lengthSq(), p = Math.abs(1 - l * l); if (0 < p) { d = l * k - m; e = l * m - k; var r = h * p; 0 <= d ? e >= -r ? e <= r ? (h = 1 / p, d *= h, e *= h, l = d * (d + l * e + 2 * m) + e * (l * d + e + 2 * k) + n) : (e = h, d = Math.max(0, -(l * e + m)), l = -d * d + e * (e + 2 * k) + n) : (e = -h, d = Math.max(0, -(l * e + m)), l = -d * d + e * (e + 2 * k) + n) : e <= -r ? (d = Math.max(0, -(-l * h + m)), e = 0 < d ? -h : Math.min(Math.max(-h, -k), h), l = -d * d + e * (e + 2 * k) + n) : e <= r ? (d = 0, e = Math.min(Math.max(-h, -k), h), l = e * (e + 2 * k) + n) : (d = Math.max(0, -(l * h + m)), e = 0 < d ? h : Math.min(Math.max(-h, -k), h), l = -d * d + e * (e + 2 * k) + n) } else e = 0 < l ? -h : h, d = Math.max(0, -(l * e + m)), l = -d * d + e * (e + 2 * k) + n; f && f.copy(this.direction).multiplyScalar(d).add(this.origin); g && g.copy(b).multiplyScalar(e).add(a); return l } }(), intersectSphere: function () { var a = new p; return function (b, c) { a.subVectors(b.center, this.origin); var d = a.dot(this.direction), e = a.dot(a) - d * d; b = b.radius * b.radius; if (e > b) return null; b = Math.sqrt(b - e); e = d - b; d += b; return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c) } }(), intersectsSphere: function (a) { return this.distanceToPoint(a.center) <= a.radius }, distanceToPlane: function (a) { var b = a.normal.dot(this.direction); if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null; a = -(this.origin.dot(a.normal) + a.constant) / b; return 0 <= a ? a : null }, intersectPlane: function (a, b) { a = this.distanceToPlane(a); return null === a ? null : this.at(a, b) }, intersectsPlane: function (a) { var b = a.distanceToPoint(this.origin); return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1 }, intersectBox: function (a, b) { var c = 1 / this.direction.x; var d = 1 / this.direction.y; var e = 1 / this.direction.z, f = this.origin; if (0 <= c) { var g = (a.min.x - f.x) * c; c *= a.max.x - f.x } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x; if (0 <= d) { var h = (a.min.y - f.y) * d; d *= a.max.y - f.y } else h = (a.max.y - f.y) * d, d *= a.min.y - f.y; if (g > d || h > c) return null; if (h > g || g !== g) g = h; if (d < c || c !== c) c = d; 0 <= e ? (h = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e); if (g > a || h > c) return null; if (h > g || g !== g) g = h; if (a < c || c !== c) c = a; return 0 > c ? null : this.at(0 <= g ? g : c, b) }, intersectsBox: function () { var a = new p; return function (b) { return null !== this.intersectBox(b, a) } }(), intersectTriangle: function () { var a = new p, b = new p, c = new p, d = new p; return function (e, f, g, h, l) { b.subVectors(f, e); c.subVectors(g, e); d.crossVectors(b, c); f = this.direction.dot(d); if (0 < f) { if (h) return null; h = 1 } else if (0 > f) h = -1, f = -f; else return null; a.subVectors(this.origin, e); e = h * this.direction.dot(c.crossVectors(a, c)); if (0 > e) return null; g = h * this.direction.dot(b.cross(a)); if (0 > g || e + g > f) return null; e = -h * a.dot(d); return 0 > e ? null : this.at(e / f, l) } }(), applyMatrix4: function (a) { this.origin.applyMatrix4(a); this.direction.transformDirection(a); return this }, equals: function (a) { return a.origin.equals(this.origin) && a.direction.equals(this.direction) } }); Object.assign(Lb.prototype, { set: function (a, b) { this.start.copy(a); this.end.copy(b); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.start.copy(a.start); this.end.copy(a.end); return this }, getCenter: function (a) { void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new p); return a.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (a) { void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new p); return a.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (a, b) { void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new p); return this.delta(b).multiplyScalar(a).add(this.start) }, closestPointToPointParameter: function () { var a = new p, b = new p; return function (c, d) { a.subVectors(c, this.start); b.subVectors(this.end, this.start); c = b.dot(b); c = b.dot(a) / c; d && (c = S.clamp(c, 0, 1)); return c } }(), closestPointToPoint: function (a, b, c) { a = this.closestPointToPointParameter(a, b); void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), c = new p); return this.delta(c).multiplyScalar(a).add(this.start) }, applyMatrix4: function (a) { this.start.applyMatrix4(a); this.end.applyMatrix4(a); return this }, equals: function (a) { return a.start.equals(this.start) && a.end.equals(this.end) } }); Object.assign(Aa, { getNormal: function () { var a = new p; return function (b, c, d, e) { void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), e = new p); e.subVectors(d, c); a.subVectors(b, c); e.cross(a); b = e.lengthSq(); return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0) } }(), getBarycoord: function () { var a = new p, b = new p, c = new p; return function (d, e, f, g, h) { a.subVectors(g, e); b.subVectors(f, e); c.subVectors(d, e); d = a.dot(a); e = a.dot(b); f = a.dot(c); var l = b.dot(b); g = b.dot(c); var m = d * l - e * e; void 0 === h && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), h = new p); if (0 === m) return h.set(-2, -1, -1); m = 1 / m; l = (l * f - e * g) * m; d = (d * g - e * f) * m; return h.set(1 - l - d, d, l) } }(), containsPoint: function () { var a = new p; return function (b, c, d, e) { Aa.getBarycoord(b, c, d, e, a); return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y } }() }); Object.assign(Aa.prototype, { set: function (a, b, c) { this.a.copy(a); this.b.copy(b); this.c.copy(c); return this }, setFromPointsAndIndices: function (a, b, c, d) { this.a.copy(a[b]); this.b.copy(a[c]); this.c.copy(a[d]); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.a.copy(a.a); this.b.copy(a.b); this.c.copy(a.c); return this }, getArea: function () { var a = new p, b = new p; return function () { a.subVectors(this.c, this.b); b.subVectors(this.a, this.b); return .5 * a.cross(b).length() } }(), getMidpoint: function (a) { void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new p); return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (a) { return Aa.getNormal(this.a, this.b, this.c, a) }, getPlane: function (a) { void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new p); return a.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (a, b) { return Aa.getBarycoord(a, this.a, this.b, this.c, b) }, containsPoint: function (a) { return Aa.containsPoint(a, this.a, this.b, this.c) }, intersectsBox: function (a) { return a.intersectsTriangle(this) }, closestPointToPoint: function () { var a = new Fa, b = [new Lb, new Lb, new Lb], c = new p, d = new p; return function (e, f) { void 0 === f && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), f = new p); var g = Infinity; a.setFromCoplanarPoints(this.a, this.b, this.c); a.projectPoint(e, c); if (!0 === this.containsPoint(c)) f.copy(c); else for (b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a), e = 0; e < b.length; e++) { b[e].closestPointToPoint(c, !0, d); var h = c.distanceToSquared(d); h < g && (g = h, f.copy(d)) } return f } }(), equals: function (a) { return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c) } }); oa.prototype = Object.assign(Object.create(A.prototype), { constructor: oa, isMesh: !0, setDrawMode: function (a) { this.drawMode = a }, copy: function (a) { A.prototype.copy.call(this, a); this.drawMode = a.drawMode; void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()); void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)); return this }, updateMorphTargets: function () { var a = this.geometry; if (a.isBufferGeometry) { a = a.morphAttributes; var b = Object.keys(a); if (0 < b.length) { var c = a[b[0]]; if (void 0 !== c) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) { var d = c[a].name || String(a); this.morphTargetInfluences.push(0); this.morphTargetDictionary[d] = a } } } else if (c = a.morphTargets, void 0 !== c && 0 < c.length) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++)d = c[a].name || String(a), this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = a }, raycast: function () { function a(a, b, c, d, e, f, g) { Aa.getBarycoord(a, b, c, d, v); e.multiplyScalar(v.x); f.multiplyScalar(v.y); g.multiplyScalar(v.z); e.add(f).add(g); return e.clone() } function b(a, b, c, d, e, f, g, h) { if (null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h))) return null; y.copy(h); y.applyMatrix4(a.matrixWorld); b = c.ray.origin.distanceTo(y); return b < c.near || b > c.far ? null : { distance: b, point: y.clone(), object: a } } function c(c, d, e, f, m, k, n, p) { g.fromBufferAttribute(f, k); h.fromBufferAttribute(f, n); l.fromBufferAttribute(f, p); if (c = b(c, c.material, d, e, g, h, l, x)) m && (t.fromBufferAttribute(m, k), r.fromBufferAttribute(m, n), q.fromBufferAttribute(m, p), c.uv = a(x, g, h, l, t, r, q)), m = new Wa(k, n, p), Aa.getNormal(g, h, l, m.normal), c.face = m, c.faceIndex = k; return c } var d = new M, e = new qb, f = new Ea, g = new p, h = new p, l = new p, m = new p, k = new p, n = new p, t = new C, r = new C, q = new C, v = new p, x = new p, y = new p; return function (p, u) { var v = this.geometry, w = this.material, y = this.matrixWorld; if (void 0 !== w && (null === v.boundingSphere && v.computeBoundingSphere(), f.copy(v.boundingSphere), f.applyMatrix4(y), !1 !== p.ray.intersectsSphere(f) && (d.getInverse(y), e.copy(p.ray).applyMatrix4(d), null === v.boundingBox || !1 !== e.intersectsBox(v.boundingBox)))) { var B; if (v.isBufferGeometry) { w = v.index; var C = v.attributes.position; y = v.attributes.uv; var A; if (null !== w) { var z = 0; for (A = w.count; z < A; z += 3) { v = w.getX(z); var E = w.getX(z + 1); var F = w.getX(z + 2); if (B = c(this, p, e, C, y, v, E, F)) B.faceIndex = Math.floor(z / 3), u.push(B) } } else if (void 0 !== C) for (z = 0, A = C.count; z < A; z += 3)if (v = z, E = z + 1, F = z + 2, B = c(this, p, e, C, y, v, E, F)) B.index = v, u.push(B) } else if (v.isGeometry) { y = Array.isArray(w); z = v.vertices; A = v.faces; E = v.faceVertexUvs[0]; 0 < E.length && (C = E); for (var I = 0, L = A.length; I < L; I++) { var Q = A[I]; B = y ? w[Q.materialIndex] : w; if (void 0 !== B) { E = z[Q.a]; F = z[Q.b]; var N = z[Q.c]; if (!0 === B.morphTargets) { var M = v.morphTargets, O = this.morphTargetInfluences; g.set(0, 0, 0); h.set(0, 0, 0); l.set(0, 0, 0); for (var T = 0, S = M.length; T < S; T++) { var V = O[T]; if (0 !== V) { var X = M[T].vertices; g.addScaledVector(m.subVectors(X[Q.a], E), V); h.addScaledVector(k.subVectors(X[Q.b], F), V); l.addScaledVector(n.subVectors(X[Q.c], N), V) } } g.add(E); h.add(F); l.add(N); E = g; F = h; N = l } if (B = b(this, B, p, e, E, F, N, x)) C && C[I] && (M = C[I], t.copy(M[0]), r.copy(M[1]), q.copy(M[2]), B.uv = a(x, E, F, N, t, r, q)), B.face = Q, B.faceIndex = I, u.push(B) } } } } } }(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) } }); ab.prototype = Object.create(Y.prototype); ab.prototype.constructor = ab; ab.prototype.isCubeTexture = !0; Object.defineProperty(ab.prototype, "images", { get: function () { return this.image }, set: function (a) { this.image = a } }); var Je = new Y, Ke = new ab, Ee = [], Ge = [], Ie = new Float32Array(16), He = new Float32Array(9); Oe.prototype.setValue = function (a, b) { for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) { var f = c[d]; f.setValue(a, b[f.id]) } }; var Ud = /([\w\d_]+)(\])?(\[|\.)?/g; bb.prototype.setValue = function (a, b, c) { b = this.map[b]; void 0 !== b && b.setValue(a, c, this.renderer) }; bb.prototype.setOptional = function (a, b, c) { b = b[c]; void 0 !== b && this.setValue(a, c, b) }; bb.upload = function (a, b, c, d) { for (var e = 0, f = b.length; e !== f; ++e) { var g = b[e], h = c[g.id]; !1 !== h.needsUpdate && g.setValue(a, h.value, d) } }; bb.seqWithValue = function (a, b) { for (var c = [], d = 0, e = a.length; d !== e; ++d) { var f = a[d]; f.id in b && c.push(f) } return c }; var rg = 0, Ag = 0; cb.prototype = Object.create(O.prototype); cb.prototype.constructor = cb; cb.prototype.isMeshDepthMaterial = !0; cb.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.depthPacking = a.depthPacking; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.map = a.map; this.alphaMap = a.alphaMap; this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; return this }; db.prototype = Object.create(O.prototype); db.prototype.constructor = db; db.prototype.isMeshDistanceMaterial = !0; db.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.referencePosition.copy(a.referencePosition); this.nearDistance = a.nearDistance; this.farDistance = a.farDistance; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.map = a.map; this.alphaMap = a.alphaMap; this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; return this }; zc.prototype = Object.create(Y.prototype); zc.prototype.constructor = zc; la.prototype = Object.assign(Object.create(Qa.prototype), { constructor: la, isPerspectiveCamera: !0, copy: function (a, b) { Qa.prototype.copy.call(this, a, b); this.fov = a.fov; this.zoom = a.zoom; this.near = a.near; this.far = a.far; this.focus = a.focus; this.aspect = a.aspect; this.view = null === a.view ? null : Object.assign({}, a.view); this.filmGauge = a.filmGauge; this.filmOffset = a.filmOffset; return this }, setFocalLength: function (a) { a = .5 * this.getFilmHeight() / a; this.fov = 2 * S.RAD2DEG * Math.atan(a); this.updateProjectionMatrix() }, getFocalLength: function () { var a = Math.tan(.5 * S.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / a }, getEffectiveFOV: function () { return 2 * S.RAD2DEG * Math.atan(Math.tan(.5 * S.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (a, b, c, d, e, f) { this.aspect = a / b; null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }); this.view.enabled = !0; this.view.fullWidth = a; this.view.fullHeight = b; this.view.offsetX = c; this.view.offsetY = d; this.view.width = e; this.view.height = f; this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1); this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var a = this.near, b = a * Math.tan(.5 * S.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -.5 * d, f = this.view; if (null !== this.view && this.view.enabled) { var g = f.fullWidth, h = f.fullHeight; e += f.offsetX * d / g; b -= f.offsetY * c / h; d *= f.width / g; c *= f.height / h } f = this.filmOffset; 0 !== f && (e += a * f / this.getFilmWidth()); this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far) }, toJSON: function (a) { a = A.prototype.toJSON.call(this, a); a.object.fov = this.fov; a.object.zoom = this.zoom; a.object.near = this.near; a.object.far = this.far; a.object.focus = this.focus; a.object.aspect = this.aspect; null !== this.view && (a.object.view = Object.assign({}, this.view)); a.object.filmGauge = this.filmGauge; a.object.filmOffset = this.filmOffset; return a } }); qd.prototype = Object.assign(Object.create(la.prototype), { constructor: qd, isArrayCamera: !0 }); Ob.prototype.isFogExp2 = !0; Ob.prototype.clone = function () { return new Ob(this.color.getHex(), this.density) }; Ob.prototype.toJSON = function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } }; Pb.prototype.isFog = !0; Pb.prototype.clone = function () { return new Pb(this.color.getHex(), this.near, this.far) }; Pb.prototype.toJSON = function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }; rd.prototype = Object.assign(Object.create(A.prototype), { constructor: rd, copy: function (a, b) { A.prototype.copy.call(this, a, b); null !== a.background && (this.background = a.background.clone()); null !== a.fog && (this.fog = a.fog.clone()); null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()); this.autoUpdate = a.autoUpdate; this.matrixAutoUpdate = a.matrixAutoUpdate; return this }, toJSON: function (a) { var b = A.prototype.toJSON.call(this, a); null !== this.background && (b.object.background = this.background.toJSON(a)); null !== this.fog && (b.object.fog = this.fog.toJSON()); return b } }); eb.prototype = Object.create(O.prototype); eb.prototype.constructor = eb; eb.prototype.isSpriteMaterial = !0; eb.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.rotation = a.rotation; return this }; Ac.prototype = Object.assign(Object.create(A.prototype), { constructor: Ac, isSprite: !0, raycast: function () { var a = new p, b = new p, c = new p; return function (d, e) { b.setFromMatrixPosition(this.matrixWorld); d.ray.closestPointToPoint(b, a); c.setFromMatrixScale(this.matrixWorld); var f = c.x * c.y / 4; b.distanceToSquared(a) > f || (f = d.ray.origin.distanceTo(a), f < d.near || f > d.far || e.push({ distance: f, point: a.clone(), face: null, object: this })) } }(), clone: function () { return (new this.constructor(this.material)).copy(this) }, copy: function (a) { A.prototype.copy.call(this, a); void 0 !== a.center && this.center.copy(a.center); return this } }); Bc.prototype = Object.assign(Object.create(A.prototype), { constructor: Bc, copy: function (a) { A.prototype.copy.call(this, a, !1); a = a.levels; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; this.addLevel(d.object.clone(), d.distance) } return this }, addLevel: function (a, b) { void 0 === b && (b = 0); b = Math.abs(b); for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++); c.splice(d, 0, { distance: b, object: a }); this.add(a) }, getObjectForDistance: function (a) { for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++); return b[c - 1].object }, raycast: function () { var a = new p; return function (b, c) { a.setFromMatrixPosition(this.matrixWorld); var d = b.ray.origin.distanceTo(a); this.getObjectForDistance(d).raycast(b, c) } }(), update: function () { var a = new p, b = new p; return function (c) { var d = this.levels; if (1 < d.length) { a.setFromMatrixPosition(c.matrixWorld); b.setFromMatrixPosition(this.matrixWorld); c = a.distanceTo(b); d[0].object.visible = !0; for (var e = 1, f = d.length; e < f; e++)if (c >= d[e].distance) d[e - 1].object.visible = !1, d[e].object.visible = !0; else break; for (; e < f; e++)d[e].object.visible = !1 } } }(), toJSON: function (a) { a = A.prototype.toJSON.call(this, a); a.object.levels = []; for (var b = this.levels, c = 0, d = b.length; c < d; c++) { var e = b[c]; a.object.levels.push({ object: e.object.uuid, distance: e.distance }) } return a } }); Object.assign(Cc.prototype, { calculateInverses: function () { this.boneInverses = []; for (var a = 0, b = this.bones.length; a < b; a++) { var c = new M; this.bones[a] && c.getInverse(this.bones[a].matrixWorld); this.boneInverses.push(c) } }, pose: function () { var a, b; var c = 0; for (b = this.bones.length; c < b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]); c = 0; for (b = this.bones.length; c < b; c++)if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale) }, update: function () { var a = new M, b = new M; return function () { for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++)a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 * g); void 0 !== f && (f.needsUpdate = !0) } }(), clone: function () { return new Cc(this.bones, this.boneInverses) }, getBoneByName: function (a) { for (var b = 0, c = this.bones.length; b < c; b++) { var d = this.bones[b]; if (d.name === a) return d } } }); sd.prototype = Object.assign(Object.create(A.prototype), { constructor: sd, isBone: !0 }); td.prototype = Object.assign(Object.create(oa.prototype), { constructor: td, isSkinnedMesh: !0, initBones: function () { var a = [], b; if (this.geometry && void 0 !== this.geometry.bones) { var c = 0; for (b = this.geometry.bones.length; c < b; c++) { var d = this.geometry.bones[c]; var e = new sd; a.push(e); e.name = d.name; e.position.fromArray(d.pos); e.quaternion.fromArray(d.rotq); void 0 !== d.scl && e.scale.fromArray(d.scl) } c = 0; for (b = this.geometry.bones.length; c < b; c++)d = this.geometry.bones[c], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[c]) : this.add(a[c]) } this.updateMatrixWorld(!0); return a }, bind: function (a, b) { this.skeleton = a; void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld); this.bindMatrix.copy(b); this.bindMatrixInverse.getInverse(b) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { var a; if (this.geometry && this.geometry.isGeometry) for (a = 0; a < this.geometry.skinWeights.length; a++) { var b = this.geometry.skinWeights[a]; var c = 1 / b.manhattanLength(); Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0) } else if (this.geometry && this.geometry.isBufferGeometry) { b = new ea; var d = this.geometry.attributes.skinWeight; for (a = 0; a < d.count; a++)b.x = d.getX(a), b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.manhattanLength(), Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w) } }, updateMatrixWorld: function (a) { oa.prototype.updateMatrixWorld.call(this, a); "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) } }); U.prototype = Object.create(O.prototype); U.prototype.constructor = U; U.prototype.isLineBasicMaterial = !0; U.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); this.linewidth = a.linewidth; this.linecap = a.linecap; this.linejoin = a.linejoin; return this }; ua.prototype = Object.assign(Object.create(A.prototype), { constructor: ua, isLine: !0, computeLineDistances: function () { var a = new p, b = new p; return function () { var c = this.geometry; if (c.isBufferGeometry) if (null === c.index) { for (var d = c.attributes.position, e = [0], f = 1, g = d.count; f < g; f++)a.fromBufferAttribute(d, f - 1), b.fromBufferAttribute(d, f), e[f] = e[f - 1], e[f] += a.distanceTo(b); c.addAttribute("lineDistance", new THREE.Float32BufferAttribute(e, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (c.isGeometry) for (d = c.vertices, e = c.lineDistances, e[0] = 0, f = 1, g = d.length; f < g; f++)e[f] = e[f - 1], e[f] += d[f - 1].distanceTo(d[f]); return this } }(), raycast: function () { var a = new M, b = new qb, c = new Ea; return function (d, e) { var f = d.linePrecision; f *= f; var g = this.geometry, h = this.matrixWorld; null === g.boundingSphere && g.computeBoundingSphere(); c.copy(g.boundingSphere); c.applyMatrix4(h); if (!1 !== d.ray.intersectsSphere(c)) { a.getInverse(h); b.copy(d.ray).applyMatrix4(a); var l = new p, m = new p; h = new p; var k = new p, n = this && this.isLineSegments ? 2 : 1; if (g.isBufferGeometry) { var t = g.index, r = g.attributes.position.array; if (null !== t) { t = t.array; g = 0; for (var q = t.length - 1; g < q; g += n) { var v = t[g + 1]; l.fromArray(r, 3 * t[g]); m.fromArray(r, 3 * v); v = b.distanceSqToSegment(l, m, k, h); v > f || (k.applyMatrix4(this.matrixWorld), v = d.ray.origin.distanceTo(k), v < d.near || v > d.far || e.push({ distance: v, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this })) } } else for (g = 0, q = r.length / 3 - 1; g < q; g += n)l.fromArray(r, 3 * g), m.fromArray(r, 3 * g + 3), v = b.distanceSqToSegment(l, m, k, h), v > f || (k.applyMatrix4(this.matrixWorld), v = d.ray.origin.distanceTo(k), v < d.near || v > d.far || e.push({ distance: v, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this })) } else if (g.isGeometry) for (l = g.vertices, m = l.length, g = 0; g < m - 1; g += n)v = b.distanceSqToSegment(l[g], l[g + 1], k, h), v > f || (k.applyMatrix4(this.matrixWorld), v = d.ray.origin.distanceTo(k), v < d.near || v > d.far || e.push({ distance: v, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this })) } } }(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) } }); aa.prototype = Object.assign(Object.create(ua.prototype), { constructor: aa, isLineSegments: !0, computeLineDistances: function () { var a = new p, b = new p; return function () { var c = this.geometry; if (c.isBufferGeometry) if (null === c.index) { for (var d = c.attributes.position, e = [], f = 0, g = d.count; f < g; f += 2)a.fromBufferAttribute(d, f), b.fromBufferAttribute(d, f + 1), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b); c.addAttribute("lineDistance", new THREE.Float32BufferAttribute(e, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (c.isGeometry) for (d = c.vertices, e = c.lineDistances, f = 0, g = d.length; f < g; f += 2)a.copy(d[f]), b.copy(d[f + 1]), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b); return this } }() }); ud.prototype = Object.assign(Object.create(ua.prototype), { constructor: ud, isLineLoop: !0 }); Ha.prototype = Object.create(O.prototype); Ha.prototype.constructor = Ha; Ha.prototype.isPointsMaterial = !0; Ha.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.size = a.size; this.sizeAttenuation = a.sizeAttenuation; return this }; Qb.prototype = Object.assign(Object.create(A.prototype), { constructor: Qb, isPoints: !0, raycast: function () { var a = new M, b = new qb, c = new Ea; return function (d, e) { function f(a, c) { var f = b.distanceSqToPoint(a); f < k && (b.closestPointToPoint(a, n), n.applyMatrix4(l), a = d.ray.origin.distanceTo(n), a < d.near || a > d.far || e.push({ distance: a, distanceToRay: Math.sqrt(f), point: n.clone(), index: c, face: null, object: g })) } var g = this, h = this.geometry, l = this.matrixWorld, m = d.params.Points.threshold; null === h.boundingSphere && h.computeBoundingSphere(); c.copy(h.boundingSphere); c.applyMatrix4(l); c.radius += m; if (!1 !== d.ray.intersectsSphere(c)) { a.getInverse(l); b.copy(d.ray).applyMatrix4(a); m /= (this.scale.x + this.scale.y + this.scale.z) / 3; var k = m * m; m = new p; var n = new p; if (h.isBufferGeometry) { var t = h.index; h = h.attributes.position.array; if (null !== t) { var r = t.array; t = 0; for (var q = r.length; t < q; t++) { var v = r[t]; m.fromArray(h, 3 * v); f(m, v) } } else for (t = 0, r = h.length / 3; t < r; t++)m.fromArray(h, 3 * t), f(m, t) } else for (m = h.vertices, t = 0, r = m.length; t < r; t++)f(m[t], t) } } }(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) } }); vd.prototype = Object.assign(Object.create(A.prototype), { constructor: vd, isGroup: !0 }); Yd.prototype = Object.assign(Object.create(Y.prototype), { constructor: Yd, isVideoTexture: !0, update: function () { var a = this.image; a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }); Rb.prototype = Object.create(Y.prototype); Rb.prototype.constructor = Rb; Rb.prototype.isCompressedTexture = !0; Dc.prototype = Object.create(Y.prototype); Dc.prototype.constructor = Dc; Dc.prototype.isDepthTexture = !0; Sb.prototype = Object.create(F.prototype); Sb.prototype.constructor = Sb; Ec.prototype = Object.create(N.prototype); Ec.prototype.constructor = Ec; Tb.prototype = Object.create(F.prototype); Tb.prototype.constructor = Tb; Fc.prototype = Object.create(N.prototype); Fc.prototype.constructor = Fc; pa.prototype = Object.create(F.prototype); pa.prototype.constructor = pa; Gc.prototype = Object.create(N.prototype); Gc.prototype.constructor = Gc; Ub.prototype = Object.create(pa.prototype); Ub.prototype.constructor = Ub; Hc.prototype = Object.create(N.prototype); Hc.prototype.constructor = Hc; sb.prototype = Object.create(pa.prototype); sb.prototype.constructor = sb; Ic.prototype = Object.create(N.prototype); Ic.prototype.constructor = Ic; Vb.prototype = Object.create(pa.prototype); Vb.prototype.constructor = Vb; Jc.prototype = Object.create(N.prototype); Jc.prototype.constructor = Jc; Wb.prototype = Object.create(pa.prototype); Wb.prototype.constructor = Wb; Kc.prototype = Object.create(N.prototype); Kc.prototype.constructor = Kc; Xb.prototype = Object.create(F.prototype); Xb.prototype.constructor = Xb; Lc.prototype = Object.create(N.prototype); Lc.prototype.constructor = Lc; Yb.prototype = Object.create(F.prototype); Yb.prototype.constructor = Yb; Mc.prototype = Object.create(N.prototype); Mc.prototype.constructor = Mc; Zb.prototype = Object.create(F.prototype); Zb.prototype.constructor = Zb; var Lg = { triangulate: function (a, b, c) { c = c || 2; var d = b && b.length, e = d ? b[0] * c : a.length, f = Xe(a, 0, e, c, !0), g = []; if (!f) return g; var h; if (d) { var l = c; d = []; var m; var k = 0; for (m = b.length; k < m; k++) { var n = b[k] * l; var p = k < m - 1 ? b[k + 1] * l : a.length; n = Xe(a, n, p, l, !1); n === n.next && (n.steiner = !0); d.push(Jg(n)) } d.sort(Hg); for (k = 0; k < d.length; k++) { b = d[k]; l = f; if (l = Ig(b, l)) b = $e(l, b), Oc(b, b.next); f = Oc(f, f.next) } } if (a.length > 80 * c) { var r = h = a[0]; var q = d = a[1]; for (l = c; l < e; l += c)k = a[l], b = a[l + 1], k < r && (r = k), b < q && (q = b), k > h && (h = k), b > d && (d = b); h = Math.max(h - r, d - q); h = 0 !== h ? 1 / h : 0 } Pc(f, g, c, r, q, h); return g } }, Xa = { area: function (a) { for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)c += a[d].x * a[e].y - a[e].x * a[d].y; return .5 * c }, isClockWise: function (a) { return 0 > Xa.area(a) }, triangulateShape: function (a, b) { var c = [], d = [], e = []; af(a); bf(c, a); var f = a.length; b.forEach(af); for (a = 0; a < b.length; a++)d.push(f), f += b[a].length, bf(c, b[a]); b = Lg.triangulate(c, d); for (a = 0; a < b.length; a += 3)e.push(b.slice(a, a + 3)); return e } }; fb.prototype = Object.create(N.prototype); fb.prototype.constructor = fb; Ia.prototype = Object.create(F.prototype); Ia.prototype.constructor = Ia; Ia.prototype.getArrays = function () { var a = this.getAttribute("position"); a = a ? Array.prototype.slice.call(a.array) : []; var b = this.getAttribute("uv"); b = b ? Array.prototype.slice.call(b.array) : []; var c = this.index; c = c ? Array.prototype.slice.call(c.array) : []; return { position: a, uv: b, index: c } }; Ia.prototype.addShapeList = function (a, b) { var c = a.length; b.arrays = this.getArrays(); for (var d = 0; d < c; d++)this.addShape(a[d], b); this.setIndex(b.arrays.index); this.addAttribute("position", new z(b.arrays.position, 3)); this.addAttribute("uv", new z(b.arrays.uv, 2)) }; Ia.prototype.addShape = function (a, b) {
        function c(a, b, c) { b || console.error("THREE.ExtrudeGeometry: vec does not exist"); return b.clone().multiplyScalar(c).add(a) }
        function d(a, b, c) { var d = a.x - b.x; var e = a.y - b.y; var f = c.x - a.x; var g = c.y - a.y, h = d * d + e * e; if (Math.abs(d * g - e * f) > Number.EPSILON) { var l = Math.sqrt(h), m = Math.sqrt(f * f + g * g); h = b.x - e / l; b = b.y + d / l; g = ((c.x - g / m - h) * g - (c.y + f / m - b) * f) / (d * g - e * f); f = h + d * g - a.x; d = b + e * g - a.y; e = f * f + d * d; if (2 >= e) return new C(f, d); e = Math.sqrt(e / 2) } else a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), a ? (f = -e, e = Math.sqrt(h)) : (f = d, d = e, e = Math.sqrt(h / 2)); return new C(f / e, d / e) } function e(a, b) { for (J = a.length; 0 <= --J;) { var c = J; var d = J - 1; 0 > d && (d = a.length - 1); var e, f = B + 2 * x; for (e = 0; e < f; e++) { var g = aa * e, m = aa * (e + 1), n = b + d + g, p = b + d + m; m = b + c + m; h(b + c + g); h(n); h(m); h(n); h(p); h(m); g = k.length / 3; g = E.generateSideWallUV(T, k, g - 6, g - 3, g - 2, g - 1); l(g[0]); l(g[1]); l(g[3]); l(g[1]); l(g[2]); l(g[3]) } } } function f(a, b, c) { r.push(a); r.push(b); r.push(c) } function g(a, b, c) { h(a); h(b); h(c); a = k.length / 3; a = E.generateTopUV(T, k, a - 3, a - 2, a - 1); l(a[0]); l(a[1]); l(a[2]) } function h(a) { n.push(k.length / 3); k.push(r[3 * a]); k.push(r[3 * a + 1]); k.push(r[3 * a + 2]) } function l(a) { t.push(a.x); t.push(a.y) } var m = b.arrays ? b.arrays : this.getArrays(), k = m.position, n = m.index, t = m.uv, r = []; m = void 0 !== b.amount ? b.amount : 100; var q = void 0 !== b.bevelThickness ? b.bevelThickness : 6, v = void 0 !== b.bevelSize ? b.bevelSize : q - 2, x = void 0 !== b.bevelSegments ? b.bevelSegments : 3, y = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, w = void 0 !== b.curveSegments ? b.curveSegments : 12, B = void 0 !== b.steps ? b.steps : 1, G = b.extrudePath, A = !1, E = void 0 !== b.UVGenerator ? b.UVGenerator : fb.WorldUVGenerator; if (G) { var H = G.getSpacedPoints(B); A = !0; y = !1; var F = void 0 !== b.frames ? b.frames : G.computeFrenetFrames(B, !1); var I = new p; var N = new p; var L = new p } y || (v = q = x = 0); var M, T = this; w = a.extractPoints(w); a = w.shape; var O = w.holes; if (!Xa.isClockWise(a)) { a = a.reverse(); var Q = 0; for (M = O.length; Q < M; Q++) { var S = O[Q]; Xa.isClockWise(S) && (O[Q] = S.reverse()) } } var V = Xa.triangulateShape(a, O), X = a; Q = 0; for (M = O.length; Q < M; Q++)S = O[Q], a = a.concat(S); var U, aa = a.length, Y, da = V.length; w = []; var J = 0; var W = X.length; var R = W - 1; for (U = J + 1; J < W; J++, R++, U++)R === W && (R = 0), U === W && (U = 0), w[J] = d(X[J], X[R], X[U]); G = []; var ea = w.concat(); Q = 0; for (M = O.length; Q < M; Q++) { S = O[Q]; var ca = []; J = 0; W = S.length; R = W - 1; for (U = J + 1; J < W; J++, R++, U++)R === W && (R = 0), U === W && (U = 0), ca[J] = d(S[J], S[R], S[U]); G.push(ca); ea = ea.concat(ca) } for (R = 0; R < x; R++) { W = R / x; var fa = q * Math.cos(W * Math.PI / 2); U = v * Math.sin(W * Math.PI / 2); J = 0; for (W = X.length; J < W; J++) { var ha = c(X[J], w[J], U); f(ha.x, ha.y, -fa) } Q = 0; for (M = O.length; Q < M; Q++)for (S = O[Q], ca = G[Q], J = 0, W = S.length; J < W; J++)ha = c(S[J], ca[J], U), f(ha.x, ha.y, -fa) } U = v; for (J = 0; J < aa; J++)ha = y ? c(a[J], ea[J], U) : a[J], A ? (N.copy(F.normals[0]).multiplyScalar(ha.x), I.copy(F.binormals[0]).multiplyScalar(ha.y), L.copy(H[0]).add(N).add(I), f(L.x, L.y, L.z)) : f(ha.x, ha.y, 0); for (W = 1; W <= B; W++)for (J = 0; J < aa; J++)ha = y ? c(a[J], ea[J], U) : a[J], A ? (N.copy(F.normals[W]).multiplyScalar(ha.x), I.copy(F.binormals[W]).multiplyScalar(ha.y), L.copy(H[W]).add(N).add(I), f(L.x, L.y, L.z)) : f(ha.x, ha.y, m / B * W); for (R = x - 1; 0 <= R; R--) { W = R / x; fa = q * Math.cos(W * Math.PI / 2); U = v * Math.sin(W * Math.PI / 2); J = 0; for (W = X.length; J < W; J++)ha = c(X[J], w[J], U), f(ha.x, ha.y, m + fa); Q = 0; for (M = O.length; Q < M; Q++)for (S = O[Q], ca = G[Q], J = 0, W = S.length; J < W; J++)ha = c(S[J], ca[J], U), A ? f(ha.x, ha.y + H[B - 1].y, H[B - 1].x + fa) : f(ha.x, ha.y, m + fa) } (function () { var a = k.length / 3; if (y) { var b = 0 * aa; for (J = 0; J < da; J++)Y = V[J], g(Y[2] + b, Y[1] + b, Y[0] + b); b = aa * (B + 2 * x); for (J = 0; J < da; J++)Y = V[J], g(Y[0] + b, Y[1] + b, Y[2] + b) } else { for (J = 0; J < da; J++)Y = V[J], g(Y[2], Y[1], Y[0]); for (J = 0; J < da; J++)Y = V[J], g(Y[0] + aa * B, Y[1] + aa * B, Y[2] + aa * B) } T.addGroup(a, k.length / 3 - a, 0) })(); (function () { var a = k.length / 3, b = 0; e(X, b); b += X.length; Q = 0; for (M = O.length; Q < M; Q++)S = O[Q], e(S, b), b += S.length; T.addGroup(a, k.length / 3 - a, 1) })(); b.arrays || (this.setIndex(n), this.addAttribute("position", new z(k, 3)), this.addAttribute("uv", new z(t, 2)))
    }; fb.WorldUVGenerator = {
        generateTopUV: function (a, b, c, d, e) { a = b[3 * d]; d = b[3 * d + 1]; var f = b[3 * e]; e = b[3 * e + 1]; return [new C(b[3 * c], b[3 * c + 1]), new C(a, d), new C(f, e)] }, generateSideWallUV: function (a, b, c, d, e, f) {
            a = b[3 * c]; var g = b[3 * c + 1]; c = b[3 * c + 2]; var h = b[3 * d], l = b[3 * d + 1]; d = b[3 * d + 2]; var m = b[3 * e], k = b[3 * e +
                1]; e = b[3 * e + 2]; var n = b[3 * f], p = b[3 * f + 1]; b = b[3 * f + 2]; return .01 > Math.abs(g - l) ? [new C(a, 1 - c), new C(h, 1 - d), new C(m, 1 - e), new C(n, 1 - b)] : [new C(g, 1 - c), new C(l, 1 - d), new C(k, 1 - e), new C(p, 1 - b)]
        }
    }; Rc.prototype = Object.create(N.prototype); Rc.prototype.constructor = Rc; $b.prototype = Object.create(Ia.prototype); $b.prototype.constructor = $b; Sc.prototype = Object.create(N.prototype); Sc.prototype.constructor = Sc; ub.prototype = Object.create(F.prototype); ub.prototype.constructor = ub; Tc.prototype = Object.create(N.prototype); Tc.prototype.constructor = Tc; ac.prototype = Object.create(F.prototype); ac.prototype.constructor = ac; Uc.prototype = Object.create(N.prototype); Uc.prototype.constructor = Uc; bc.prototype = Object.create(F.prototype); bc.prototype.constructor = bc; vb.prototype = Object.create(N.prototype); vb.prototype.constructor = vb; vb.prototype.toJSON = function () { var a = N.prototype.toJSON.call(this); return cf(this.parameters.shapes, a) }; wb.prototype = Object.create(F.prototype); wb.prototype.constructor = wb; wb.prototype.toJSON = function () { var a = F.prototype.toJSON.call(this); return cf(this.parameters.shapes, a) }; cc.prototype = Object.create(F.prototype); cc.prototype.constructor = cc; xb.prototype = Object.create(N.prototype); xb.prototype.constructor = xb; Ya.prototype = Object.create(F.prototype); Ya.prototype.constructor = Ya; Vc.prototype = Object.create(xb.prototype); Vc.prototype.constructor = Vc; Wc.prototype = Object.create(Ya.prototype); Wc.prototype.constructor = Wc; Xc.prototype = Object.create(N.prototype); Xc.prototype.constructor = Xc; dc.prototype = Object.create(F.prototype); dc.prototype.constructor = dc; var Ca = Object.freeze({ WireframeGeometry: Sb, ParametricGeometry: Ec, ParametricBufferGeometry: Tb, TetrahedronGeometry: Gc, TetrahedronBufferGeometry: Ub, OctahedronGeometry: Hc, OctahedronBufferGeometry: sb, IcosahedronGeometry: Ic, IcosahedronBufferGeometry: Vb, DodecahedronGeometry: Jc, DodecahedronBufferGeometry: Wb, PolyhedronGeometry: Fc, PolyhedronBufferGeometry: pa, TubeGeometry: Kc, TubeBufferGeometry: Xb, TorusKnotGeometry: Lc, TorusKnotBufferGeometry: Yb, TorusGeometry: Mc, TorusBufferGeometry: Zb, TextGeometry: Rc, TextBufferGeometry: $b, SphereGeometry: Sc, SphereBufferGeometry: ub, RingGeometry: Tc, RingBufferGeometry: ac, PlaneGeometry: xc, PlaneBufferGeometry: pb, LatheGeometry: Uc, LatheBufferGeometry: bc, ShapeGeometry: vb, ShapeBufferGeometry: wb, ExtrudeGeometry: fb, ExtrudeBufferGeometry: Ia, EdgesGeometry: cc, ConeGeometry: Vc, ConeBufferGeometry: Wc, CylinderGeometry: xb, CylinderBufferGeometry: Ya, CircleGeometry: Xc, CircleBufferGeometry: dc, BoxGeometry: Kb, BoxBufferGeometry: mb }); yb.prototype = Object.create(O.prototype); yb.prototype.constructor = yb; yb.prototype.isShadowMaterial = !0; yb.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); return this }; ec.prototype = Object.create(va.prototype); ec.prototype.constructor = ec; ec.prototype.isRawShaderMaterial = !0; Sa.prototype = Object.create(O.prototype); Sa.prototype.constructor = Sa; Sa.prototype.isMeshStandardMaterial = !0; Sa.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.defines = { STANDARD: "" }; this.color.copy(a.color); this.roughness = a.roughness; this.metalness = a.metalness; this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.roughnessMap = a.roughnessMap; this.metalnessMap = a.metalnessMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.envMapIntensity = a.envMapIntensity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this }; zb.prototype = Object.create(Sa.prototype); zb.prototype.constructor = zb; zb.prototype.isMeshPhysicalMaterial = !0; zb.prototype.copy = function (a) { Sa.prototype.copy.call(this, a); this.defines = { PHYSICAL: "" }; this.reflectivity = a.reflectivity; this.clearCoat = a.clearCoat; this.clearCoatRoughness = a.clearCoatRoughness; return this }; Ja.prototype = Object.create(O.prototype); Ja.prototype.constructor = Ja; Ja.prototype.isMeshPhongMaterial = !0; Ja.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); this.specular.copy(a.specular); this.shininess = a.shininess; this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this }; Ab.prototype = Object.create(Ja.prototype); Ab.prototype.constructor = Ab; Ab.prototype.isMeshToonMaterial = !0; Ab.prototype.copy = function (a) { Ja.prototype.copy.call(this, a); this.gradientMap = a.gradientMap; return this }; Bb.prototype = Object.create(O.prototype); Bb.prototype.constructor = Bb; Bb.prototype.isMeshNormalMaterial = !0; Bb.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this }; Cb.prototype = Object.create(O.prototype); Cb.prototype.constructor = Cb; Cb.prototype.isMeshLambertMaterial = !0; Cb.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this }; Db.prototype = Object.create(U.prototype); Db.prototype.constructor = Db; Db.prototype.isLineDashedMaterial = !0; Db.prototype.copy = function (a) { U.prototype.copy.call(this, a); this.scale = a.scale; this.dashSize = a.dashSize; this.gapSize = a.gapSize; return this }; var Mg = Object.freeze({ ShadowMaterial: yb, SpriteMaterial: eb, RawShaderMaterial: ec, ShaderMaterial: va, PointsMaterial: Ha, MeshPhysicalMaterial: zb, MeshStandardMaterial: Sa, MeshPhongMaterial: Ja, MeshToonMaterial: Ab, MeshNormalMaterial: Bb, MeshLambertMaterial: Cb, MeshDepthMaterial: cb, MeshDistanceMaterial: db, MeshBasicMaterial: za, LineDashedMaterial: Db, LineBasicMaterial: U, Material: O }), Hb = { enabled: !1, files: {}, add: function (a, b) { !1 !== this.enabled && (this.files[a] = b) }, get: function (a) { if (!1 !== this.enabled) return this.files[a] }, remove: function (a) { delete this.files[a] }, clear: function () { this.files = {} } }, ma = new ae, $a = {}; Object.assign(Ka.prototype, { load: function (a, b, c, d) { void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); a = this.manager.resolveURL(a); var e = this, f = Hb.get(a); if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a) }, 0), f; if (void 0 !== $a[a]) $a[a].push({ onLoad: b, onProgress: c, onError: d }); else { var g = a.match(/^data:(.*?)(;base64)?,(.*)$/); if (g) { c = g[1]; var h = !!g[2]; g = g[3]; g = window.decodeURIComponent(g); h && (g = window.atob(g)); try { var l = (this.responseType || "").toLowerCase(); switch (l) { case "arraybuffer": case "blob": var m = new Uint8Array(g.length); for (h = 0; h < g.length; h++)m[h] = g.charCodeAt(h); var k = "blob" === l ? new Blob([m.buffer], { type: c }) : m.buffer; break; case "document": k = (new DOMParser).parseFromString(g, c); break; case "json": k = JSON.parse(g); break; default: k = g }window.setTimeout(function () { b && b(k); e.manager.itemEnd(a) }, 0) } catch (t) { window.setTimeout(function () { d && d(t); e.manager.itemEnd(a); e.manager.itemError(a) }, 0) } } else { $a[a] = []; $a[a].push({ onLoad: b, onProgress: c, onError: d }); var n = new XMLHttpRequest; n.open("GET", a, !0); n.addEventListener("load", function (b) { var c = this.response; Hb.add(a, c); var d = $a[a]; delete $a[a]; if (200 === this.status) { for (var f = 0, g = d.length; f < g; f++) { var h = d[f]; if (h.onLoad) h.onLoad(c) } e.manager.itemEnd(a) } else if (0 === this.status) { console.warn("THREE.FileLoader: HTTP Status 0 received."); f = 0; for (g = d.length; f < g; f++)if (h = d[f], h.onLoad) h.onLoad(c); e.manager.itemEnd(a) } else { f = 0; for (g = d.length; f < g; f++)if (h = d[f], h.onError) h.onError(b); e.manager.itemEnd(a); e.manager.itemError(a) } }, !1); n.addEventListener("progress", function (b) { for (var c = $a[a], d = 0, e = c.length; d < e; d++) { var f = c[d]; if (f.onProgress) f.onProgress(b) } }, !1); n.addEventListener("error", function (b) { var c = $a[a]; delete $a[a]; for (var d = 0, f = c.length; d < f; d++) { var g = c[d]; if (g.onError) g.onError(b) } e.manager.itemEnd(a); e.manager.itemError(a) }, !1); void 0 !== this.responseType && (n.responseType = this.responseType); void 0 !== this.withCredentials && (n.withCredentials = this.withCredentials); n.overrideMimeType && n.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (h in this.requestHeader) n.setRequestHeader(h, this.requestHeader[h]); n.send(null) } e.manager.itemStart(a); return n } }, setPath: function (a) { this.path = a; return this }, setResponseType: function (a) { this.responseType = a; return this }, setWithCredentials: function (a) { this.withCredentials = a; return this }, setMimeType: function (a) { this.mimeType = a; return this }, setRequestHeader: function (a) { this.requestHeader = a; return this } }); Object.assign(df.prototype, { load: function (a, b, c, d) { function e(e) { l.load(a[e], function (a) { a = f._parser(a, !0); g[e] = { width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps }; m += 1; 6 === m && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h)) }, c, d) } var f = this, g = [], h = new Rb; h.image = g; var l = new Ka(this.manager); l.setPath(this.path); l.setResponseType("arraybuffer"); if (Array.isArray(a)) for (var m = 0, k = 0, n = a.length; k < n; ++k)e(k); else l.load(a, function (a) { a = f._parser(a, !0); if (a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) { g[d] = { mipmaps: [] }; for (var e = 0; e < a.mipmapCount; e++)g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps; 1 === a.mipmapCount && (h.minFilter = 1006); h.format = a.format; h.needsUpdate = !0; b && b(h) }, c, d); return h }, setPath: function (a) { this.path = a; return this } }); Object.assign(be.prototype, { load: function (a, b, c, d) { var e = this, f = new ib, g = new Ka(this.manager); g.setResponseType("arraybuffer"); g.load(a, function (a) { if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a) }, c, d); return f } }); Object.assign(Yc.prototype, { crossOrigin: "Anonymous", load: function (a, b, c, d) { void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); a = this.manager.resolveURL(a); var e = this, f = Hb.get(a); if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a) }, 0), f; c = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); c.addEventListener("load", function () { Hb.add(a, this); b && b(this); e.manager.itemEnd(a) }, !1); c.addEventListener("error", function (b) { d && d(b); e.manager.itemEnd(a); e.manager.itemError(a) }, !1); "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin); e.manager.itemStart(a); c.src = a; return c }, setCrossOrigin: function (a) { this.crossOrigin = a; return this }, setPath: function (a) { this.path = a; return this } }); Object.assign(ce.prototype, { crossOrigin: "Anonymous", load: function (a, b, c, d) { function e(c) { g.load(a[c], function (a) { f.images[c] = a; h++; 6 === h && (f.needsUpdate = !0, b && b(f)) }, void 0, d) } var f = new ab, g = new Yc(this.manager); g.setCrossOrigin(this.crossOrigin); g.setPath(this.path); var h = 0; for (c = 0; c < a.length; ++c)e(c); return f }, setCrossOrigin: function (a) { this.crossOrigin = a; return this }, setPath: function (a) { this.path = a; return this } }); Object.assign(xd.prototype, { crossOrigin: "Anonymous", load: function (a, b, c, d) { var e = new Y, f = new Yc(this.manager); f.setCrossOrigin(this.crossOrigin); f.setPath(this.path); f.load(a, function (c) { e.image = c; c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data:image\/jpeg/); e.format = c ? 1022 : 1023; e.needsUpdate = !0; void 0 !== b && b(e) }, c, d); return e }, setCrossOrigin: function (a) { this.crossOrigin = a; return this }, setPath: function (a) { this.path = a; return this } }); Object.assign(E.prototype, { getPoint: function () { console.warn("THREE.Curve: .getPoint() not implemented."); return null }, getPointAt: function (a, b) { a = this.getUtoTmapping(a); return this.getPoint(a, b) }, getPoints: function (a) { void 0 === a && (a = 5); for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a)); return b }, getSpacedPoints: function (a) { void 0 === a && (a = 5); for (var b = [], c = 0; c <= a; c++)b.push(this.getPointAt(c / a)); return b }, getLength: function () { var a = this.getLengths(); return a[a.length - 1] }, getLengths: function (a) { void 0 === a && (a = this.arcLengthDivisions); if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var b = [], c = this.getPoint(0), d, e = 0; b.push(0); for (d = 1; d <= a; d++) { var f = this.getPoint(d / a); e += f.distanceTo(c); b.push(e); c = f } return this.cacheArcLengths = b }, updateArcLengths: function () { this.needsUpdate = !0; this.getLengths() }, getUtoTmapping: function (a, b) { var c = this.getLengths(), d = c.length; b = b ? b : a * c[d - 1]; for (var e = 0, f = d - 1, g; e <= f;)if (a = Math.floor(e + (f - e) / 2), g = c[a] - b, 0 > g) e = a + 1; else if (0 < g) f = a - 1; else { f = a; break } a = f; if (c[a] === b) return a / (d - 1); e = c[a]; return (a + (b - e) / (c[a + 1] - e)) / (d - 1) }, getTangent: function (a) { var b = a - 1E-4; a += 1E-4; 0 > b && (b = 0); 1 < a && (a = 1); b = this.getPoint(b); return this.getPoint(a).clone().sub(b).normalize() }, getTangentAt: function (a) { a = this.getUtoTmapping(a); return this.getTangent(a) }, computeFrenetFrames: function (a, b) { var c = new p, d = [], e = [], f = [], g = new p, h = new M, l; for (l = 0; l <= a; l++) { var m = l / a; d[l] = this.getTangentAt(m); d[l].normalize() } e[0] = new p; f[0] = new p; l = Number.MAX_VALUE; m = Math.abs(d[0].x); var k = Math.abs(d[0].y), n = Math.abs(d[0].z); m <= l && (l = m, c.set(1, 0, 0)); k <= l && (l = k, c.set(0, 1, 0)); n <= l && c.set(0, 0, 1); g.crossVectors(d[0], c).normalize(); e[0].crossVectors(d[0], g); f[0].crossVectors(d[0], e[0]); for (l = 1; l <= a; l++)e[l] = e[l - 1].clone(), f[l] = f[l - 1].clone(), g.crossVectors(d[l - 1], d[l]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(S.clamp(d[l - 1].dot(d[l]), -1, 1)), e[l].applyMatrix4(h.makeRotationAxis(g, c))), f[l].crossVectors(d[l], e[l]); if (!0 === b) for (c = Math.acos(S.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), l = 1; l <= a; l++)e[l].applyMatrix4(h.makeRotationAxis(d[l], c * l)), f[l].crossVectors(d[l], e[l]); return { tangents: d, normals: e, binormals: f } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.arcLengthDivisions = a.arcLengthDivisions; return this }, toJSON: function () { var a = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; a.arcLengthDivisions = this.arcLengthDivisions; a.type = this.type; return a }, fromJSON: function (a) { this.arcLengthDivisions = a.arcLengthDivisions; return this } }); ia.prototype = Object.create(E.prototype); ia.prototype.constructor = ia; ia.prototype.isEllipseCurve = !0; ia.prototype.getPoint = function (a, b) { b = b || new C; for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;)d += c; for (; d > c;)d -= c; d < Number.EPSILON && (d = e ? 0 : c); !0 !== this.aClockwise || e || (d = d === c ? -c : d - c); c = this.aStartAngle + a * d; a = this.aX + this.xRadius * Math.cos(c); var f = this.aY + this.yRadius * Math.sin(c); 0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * c - f * d + this.aX, f = e * d + f * c + this.aY); return b.set(a, f) }; ia.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.aX = a.aX; this.aY = a.aY; this.xRadius = a.xRadius; this.yRadius = a.yRadius; this.aStartAngle = a.aStartAngle; this.aEndAngle = a.aEndAngle; this.aClockwise = a.aClockwise; this.aRotation = a.aRotation; return this }; ia.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.aX = this.aX; a.aY = this.aY; a.xRadius = this.xRadius; a.yRadius = this.yRadius; a.aStartAngle = this.aStartAngle; a.aEndAngle = this.aEndAngle; a.aClockwise = this.aClockwise; a.aRotation = this.aRotation; return a }; ia.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.aX = a.aX; this.aY = a.aY; this.xRadius = a.xRadius; this.yRadius = a.yRadius; this.aStartAngle = a.aStartAngle; this.aEndAngle = a.aEndAngle; this.aClockwise = a.aClockwise; this.aRotation = a.aRotation; return this }; fc.prototype = Object.create(ia.prototype); fc.prototype.constructor = fc; fc.prototype.isArcCurve = !0; var Qd = new p, ye = new de, ze = new de, Ae = new de; X.prototype = Object.create(E.prototype); X.prototype.constructor = X; X.prototype.isCatmullRomCurve3 = !0; X.prototype.getPoint = function (a, b) { b = b || new p; var c = this.points, d = c.length; a *= d - (this.closed ? 0 : 1); var e = Math.floor(a); a -= e; this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / c.length) + 1) * c.length : 0 === a && e === d - 1 && (e = d - 2, a = 1); if (this.closed || 0 < e) var f = c[(e - 1) % d]; else Qd.subVectors(c[0], c[1]).add(c[0]), f = Qd; var g = c[e % d]; var h = c[(e + 1) % d]; this.closed || e + 2 < d ? c = c[(e + 2) % d] : (Qd.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = Qd); if ("centripetal" === this.curveType || "chordal" === this.curveType) { var l = "chordal" === this.curveType ? .5 : .25; d = Math.pow(f.distanceToSquared(g), l); e = Math.pow(g.distanceToSquared(h), l); l = Math.pow(h.distanceToSquared(c), l); 1E-4 > e && (e = 1); 1E-4 > d && (d = e); 1E-4 > l && (l = e); ye.initNonuniformCatmullRom(f.x, g.x, h.x, c.x, d, e, l); ze.initNonuniformCatmullRom(f.y, g.y, h.y, c.y, d, e, l); Ae.initNonuniformCatmullRom(f.z, g.z, h.z, c.z, d, e, l) } else "catmullrom" === this.curveType && (ye.initCatmullRom(f.x, g.x, h.x, c.x, this.tension), ze.initCatmullRom(f.y, g.y, h.y, c.y, this.tension), Ae.initCatmullRom(f.z, g.z, h.z, c.z, this.tension)); b.set(ye.calc(a), ze.calc(a), Ae.calc(a)); return b }; X.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++)this.points.push(a.points[b].clone()); this.closed = a.closed; this.curveType = a.curveType; this.tension = a.tension; return this }; X.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.points = []; for (var b = 0, c = this.points.length; b < c; b++)a.points.push(this.points[b].toArray()); a.closed = this.closed; a.curveType = this.curveType; a.tension = this.tension; return a }; X.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++) { var d = a.points[b]; this.points.push((new p).fromArray(d)) } this.closed = a.closed; this.curveType = a.curveType; this.tension = a.tension; return this }; La.prototype = Object.create(E.prototype); La.prototype.constructor = La; La.prototype.isCubicBezierCurve = !0; La.prototype.getPoint = function (a, b) { b = b || new C; var c = this.v0, d = this.v1, e = this.v2, f = this.v3; b.set($c(a, c.x, d.x, e.x, f.x), $c(a, c.y, d.y, e.y, f.y)); return b }; La.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); this.v3.copy(a.v3); return this }; La.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); a.v3 = this.v3.toArray(); return a }; La.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); this.v3.fromArray(a.v3); return this }; Ta.prototype = Object.create(E.prototype); Ta.prototype.constructor = Ta; Ta.prototype.isCubicBezierCurve3 = !0; Ta.prototype.getPoint = function (a, b) { b = b || new p; var c = this.v0, d = this.v1, e = this.v2, f = this.v3; b.set($c(a, c.x, d.x, e.x, f.x), $c(a, c.y, d.y, e.y, f.y), $c(a, c.z, d.z, e.z, f.z)); return b }; Ta.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); this.v3.copy(a.v3); return this }; Ta.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); a.v3 = this.v3.toArray(); return a }; Ta.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); this.v3.fromArray(a.v3); return this }; wa.prototype = Object.create(E.prototype); wa.prototype.constructor = wa; wa.prototype.isLineCurve = !0; wa.prototype.getPoint = function (a, b) { b = b || new C; 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)); return b }; wa.prototype.getPointAt = function (a, b) { return this.getPoint(a, b) }; wa.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize() }; wa.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; wa.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a }; wa.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this }; Ma.prototype = Object.create(E.prototype); Ma.prototype.constructor = Ma; Ma.prototype.isLineCurve3 = !0; Ma.prototype.getPoint = function (a, b) { b = b || new p; 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)); return b }; Ma.prototype.getPointAt = function (a, b) { return this.getPoint(a, b) }; Ma.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; Ma.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a }; Ma.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this }; Na.prototype = Object.create(E.prototype); Na.prototype.constructor = Na; Na.prototype.isQuadraticBezierCurve = !0; Na.prototype.getPoint = function (a, b) { b = b || new C; var c = this.v0, d = this.v1, e = this.v2; b.set(Zc(a, c.x, d.x, e.x), Zc(a, c.y, d.y, e.y)); return b }; Na.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; Na.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a }; Na.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this }; Ua.prototype = Object.create(E.prototype); Ua.prototype.constructor = Ua; Ua.prototype.isQuadraticBezierCurve3 = !0; Ua.prototype.getPoint = function (a, b) { b = b || new p; var c = this.v0, d = this.v1, e = this.v2; b.set(Zc(a, c.x, d.x, e.x), Zc(a, c.y, d.y, e.y), Zc(a, c.z, d.z, e.z)); return b }; Ua.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; Ua.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a }; Ua.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this }; Oa.prototype = Object.create(E.prototype); Oa.prototype.constructor = Oa; Oa.prototype.isSplineCurve = !0; Oa.prototype.getPoint = function (a, b) { b = b || new C; var c = this.points, d = (c.length - 1) * a; a = Math.floor(d); d -= a; var e = c[0 === a ? a : a - 1], f = c[a], g = c[a > c.length - 2 ? c.length - 1 : a + 1]; c = c[a > c.length - 3 ? c.length - 1 : a + 2]; b.set(ef(d, e.x, f.x, g.x, c.x), ef(d, e.y, f.y, g.y, c.y)); return b }; Oa.prototype.copy = function (a) { E.prototype.copy.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++)this.points.push(a.points[b].clone()); return this }; Oa.prototype.toJSON = function () { var a = E.prototype.toJSON.call(this); a.points = []; for (var b = 0, c = this.points.length; b < c; b++)a.points.push(this.points[b].toArray()); return a }; Oa.prototype.fromJSON = function (a) { E.prototype.fromJSON.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++) { var d = a.points[b]; this.points.push((new C).fromArray(d)) } return this }; var Ng = Object.freeze({ ArcCurve: fc, CatmullRomCurve3: X, CubicBezierCurve: La, CubicBezierCurve3: Ta, EllipseCurve: ia, LineCurve: wa, LineCurve3: Ma, QuadraticBezierCurve: Na, QuadraticBezierCurve3: Ua, SplineCurve: Oa }); Za.prototype = Object.assign(Object.create(E.prototype), { constructor: Za, add: function (a) { this.curves.push(a) }, closePath: function () { var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1); a.equals(b) || this.curves.push(new wa(b, a)) }, getPoint: function (a) { var b = a * this.getLength(), c = this.getCurveLengths(); for (a = 0; a < c.length;) { if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c); a++ } return null }, getLength: function () { var a = this.getCurveLengths(); return a[a.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0; this.cacheLengths = null; this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)b += this.curves[c].getLength(), a.push(b); return this.cacheLengths = a }, getSpacedPoints: function (a) { void 0 === a && (a = 40); for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a)); this.autoClose && b.push(b[0]); return b }, getPoints: function (a) { a = a || 12; for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) { var f = e[d]; f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a); for (var g = 0; g < f.length; g++) { var h = f[g]; c && c.equals(h) || (b.push(h), c = h) } } this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]); return b }, copy: function (a) { E.prototype.copy.call(this, a); this.curves = []; for (var b = 0, c = a.curves.length; b < c; b++)this.curves.push(a.curves[b].clone()); this.autoClose = a.autoClose; return this }, toJSON: function () { var a = E.prototype.toJSON.call(this); a.autoClose = this.autoClose; a.curves = []; for (var b = 0, c = this.curves.length; b < c; b++)a.curves.push(this.curves[b].toJSON()); return a }, fromJSON: function (a) { E.prototype.fromJSON.call(this, a); this.autoClose = a.autoClose; this.curves = []; for (var b = 0, c = a.curves.length; b < c; b++) { var d = a.curves[b]; this.curves.push((new Ng[d.type]).fromJSON(d)) } return this } }); Pa.prototype = Object.assign(Object.create(Za.prototype), { constructor: Pa, setFromPoints: function (a) { this.moveTo(a[0].x, a[0].y); for (var b = 1, c = a.length; b < c; b++)this.lineTo(a[b].x, a[b].y) }, moveTo: function (a, b) { this.currentPoint.set(a, b) }, lineTo: function (a, b) { var c = new wa(this.currentPoint.clone(), new C(a, b)); this.curves.push(c); this.currentPoint.set(a, b) }, quadraticCurveTo: function (a, b, c, d) { a = new Na(this.currentPoint.clone(), new C(a, b), new C(c, d)); this.curves.push(a); this.currentPoint.set(c, d) }, bezierCurveTo: function (a, b, c, d, e, f) { a = new La(this.currentPoint.clone(), new C(a, b), new C(c, d), new C(e, f)); this.curves.push(a); this.currentPoint.set(e, f) }, splineThru: function (a) { var b = [this.currentPoint.clone()].concat(a); b = new Oa(b); this.curves.push(b); this.currentPoint.copy(a[a.length - 1]) }, arc: function (a, b, c, d, e, f) { this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f) }, absarc: function (a, b, c, d, e, f) { this.absellipse(a, b, c, c, d, e, f) }, ellipse: function (a, b, c, d, e, f, g, h) { this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h) }, absellipse: function (a, b, c, d, e, f, g, h) { a = new ia(a, b, c, d, e, f, g, h); 0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y)); this.curves.push(a); a = a.getPoint(1); this.currentPoint.copy(a) }, copy: function (a) { Za.prototype.copy.call(this, a); this.currentPoint.copy(a.currentPoint); return this }, toJSON: function () { var a = Za.prototype.toJSON.call(this); a.currentPoint = this.currentPoint.toArray(); return a }, fromJSON: function (a) { Za.prototype.fromJSON.call(this, a); this.currentPoint.fromArray(a.currentPoint); return this } }); gb.prototype = Object.assign(Object.create(Pa.prototype), { constructor: gb, getPointsHoles: function (a) { for (var b = [], c = 0, d = this.holes.length; c < d; c++)b[c] = this.holes[c].getPoints(a); return b }, extractPoints: function (a) { return { shape: this.getPoints(a), holes: this.getPointsHoles(a) } }, copy: function (a) { Pa.prototype.copy.call(this, a); this.holes = []; for (var b = 0, c = a.holes.length; b < c; b++)this.holes.push(a.holes[b].clone()); return this }, toJSON: function () { var a = Pa.prototype.toJSON.call(this); a.uuid = this.uuid; a.holes = []; for (var b = 0, c = this.holes.length; b < c; b++)a.holes.push(this.holes[b].toJSON()); return a }, fromJSON: function (a) { Pa.prototype.fromJSON.call(this, a); this.uuid = a.uuid; this.holes = []; for (var b = 0, c = a.holes.length; b < c; b++) { var d = a.holes[b]; this.holes.push((new Pa).fromJSON(d)) } return this } }); ca.prototype = Object.assign(Object.create(A.prototype), { constructor: ca, isLight: !0, copy: function (a) { A.prototype.copy.call(this, a); this.color.copy(a.color); this.intensity = a.intensity; return this }, toJSON: function (a) { a = A.prototype.toJSON.call(this, a); a.object.color = this.color.getHex(); a.object.intensity = this.intensity; void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()); void 0 !== this.distance && (a.object.distance = this.distance); void 0 !== this.angle && (a.object.angle = this.angle); void 0 !== this.decay && (a.object.decay = this.decay); void 0 !== this.penumbra && (a.object.penumbra = this.penumbra); void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()); return a } }); yd.prototype = Object.assign(Object.create(ca.prototype), { constructor: yd, isHemisphereLight: !0, copy: function (a) { ca.prototype.copy.call(this, a); this.groundColor.copy(a.groundColor); return this } }); Object.assign(Eb.prototype, { copy: function (a) { this.camera = a.camera.clone(); this.bias = a.bias; this.radius = a.radius; this.mapSize.copy(a.mapSize); return this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var a = {}; 0 !== this.bias && (a.bias = this.bias); 1 !== this.radius && (a.radius = this.radius); if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray(); a.camera = this.camera.toJSON(!1).object; delete a.camera.matrix; return a } }); zd.prototype = Object.assign(Object.create(Eb.prototype), { constructor: zd, isSpotLightShadow: !0, update: function (a) { var b = this.camera, c = 2 * S.RAD2DEG * a.angle, d = this.mapSize.width / this.mapSize.height; a = a.distance || b.far; if (c !== b.fov || d !== b.aspect || a !== b.far) b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix() } }); Ad.prototype = Object.assign(Object.create(ca.prototype), { constructor: Ad, isSpotLight: !0, copy: function (a) { ca.prototype.copy.call(this, a); this.distance = a.distance; this.angle = a.angle; this.penumbra = a.penumbra; this.decay = a.decay; this.target = a.target.clone(); this.shadow = a.shadow.clone(); return this } }); Bd.prototype = Object.assign(Object.create(ca.prototype), { constructor: Bd, isPointLight: !0, copy: function (a) { ca.prototype.copy.call(this, a); this.distance = a.distance; this.decay = a.decay; this.shadow = a.shadow.clone(); return this } }); Cd.prototype = Object.assign(Object.create(Eb.prototype), { constructor: Cd }); Dd.prototype = Object.assign(Object.create(ca.prototype), { constructor: Dd, isDirectionalLight: !0, copy: function (a) { ca.prototype.copy.call(this, a); this.target = a.target.clone(); this.shadow = a.shadow.clone(); return this } }); Ed.prototype = Object.assign(Object.create(ca.prototype), { constructor: Ed, isAmbientLight: !0 }); Fd.prototype = Object.assign(Object.create(ca.prototype), { constructor: Fd, isRectAreaLight: !0, copy: function (a) { ca.prototype.copy.call(this, a); this.width = a.width; this.height = a.height; return this }, toJSON: function (a) { a = ca.prototype.toJSON.call(this, a); a.object.width = this.width; a.object.height = this.height; return a } }); Gd.prototype = Object.assign(Object.create(da.prototype), { constructor: Gd, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }); Hd.prototype = Object.assign(Object.create(da.prototype), { constructor: Hd, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }); Object.assign(na.prototype, { evaluate: function (a) { var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1]; a: { b: { c: { d: if (!(a < d)) { for (var f = c + 2; ;) { if (void 0 === d) { if (a < e) break d; this._cachedIndex = c = b.length; return this.afterEnd_(c - 1, a, e) } if (c === f) break; e = d; d = b[++c]; if (a < d) break b } d = b.length; break c } if (a >= e) break a; else { f = b[1]; a < f && (c = 2, e = f); for (f = c - 2; ;) { if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d); if (c === f) break; d = e; e = b[--c - 1]; if (a >= e) break b } d = c; c = 0 } } for (; c < d;)e = c + d >>> 1, a < b[e] ? d = e : c = e + 1; d = b[c]; e = b[c - 1]; if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d); if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a) } this._cachedIndex = c; this.intervalChanged_(c, e, d) } return this.interpolate_(c, e, a, d) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (a) { var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize; a *= d; for (var e = 0; e !== d; ++e)b[e] = c[a + e]; return b }, interpolate_: function () { throw Error("call to abstract method"); }, intervalChanged_: function () { } }); Object.assign(na.prototype, { beforeStart_: na.prototype.copySampleValue_, afterEnd_: na.prototype.copySampleValue_ }); Id.prototype = Object.assign(Object.create(na.prototype), { constructor: Id, interpolate_: function (a, b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; b = (c - b) / (d - b); for (c = a + g; a !== c; a += 4)ja.slerpFlat(e, 0, f, a - g, f, a, b); return e } }); ad.prototype = Object.assign(Object.create(da.prototype), { constructor: ad, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (a) { return new Id(this.times, this.values, this.getValueSize(), a) }, InterpolantFactoryMethodSmooth: void 0 }); Jd.prototype = Object.assign(Object.create(da.prototype), { constructor: Jd, ValueTypeName: "color" }); gc.prototype = Object.assign(Object.create(da.prototype), { constructor: gc, ValueTypeName: "number" }); Kd.prototype = Object.assign(Object.create(na.prototype), { constructor: Kd, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (a, b, c) { var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], h = d[f]; if (void 0 === g) switch (this.getSettings_().endingStart) { case 2401: e = a; g = 2 * b - c; break; case 2402: e = d.length - 2; g = b + d[e] - d[e + 1]; break; default: e = a, g = c }if (void 0 === h) switch (this.getSettings_().endingEnd) { case 2401: f = a; h = 2 * c - b; break; case 2402: f = 1; h = c + d[1] - d[0]; break; default: f = a - 1, h = b }a = .5 * (c - b); d = this.valueSize; this._weightPrev = a / (b - g); this._weightNext = a / (h - c); this._offsetPrev = e * d; this._offsetNext = f * d }, interpolate_: function (a, b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; var h = a - g, l = this._offsetPrev, m = this._offsetNext, k = this._weightPrev, n = this._weightNext, p = (c - b) / (d - b); c = p * p; d = c * p; b = -k * d + 2 * k * c - k * p; k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * p + 1; p = (-1 - n) * d + (1.5 + n) * c + .5 * p; n = n * d - n * c; for (c = 0; c !== g; ++c)e[c] = b * f[l + c] + k * f[h + c] + p * f[a + c] + n * f[m + c]; return e } }); bd.prototype = Object.assign(Object.create(na.prototype), { constructor: bd, interpolate_: function (a, b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; var h = a - g; b = (c - b) / (d - b); c = 1 - b; for (d = 0; d !== g; ++d)e[d] = f[h + d] * c + f[a + d] * b; return e } }); Ld.prototype = Object.assign(Object.create(na.prototype), { constructor: Ld, interpolate_: function (a) { return this.copySampleValue_(a - 1) } }); var fa = { arraySlice: function (a, b, c) { return fa.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c) }, convertArray: function (a, b, c) { return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a) }, isTypedArray: function (a) { return ArrayBuffer.isView(a) && !(a instanceof DataView) }, getKeyframeOrder: function (a) { for (var b = a.length, c = Array(b), d = 0; d !== b; ++d)c[d] = d; c.sort(function (b, c) { return a[b] - a[c] }); return c }, sortedArray: function (a, b, c) { for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)for (var h = c[f] * b, l = 0; l !== b; ++l)e[g++] = a[h + l]; return e }, flattenJSON: function (a, b, c, d) { for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];)f = a[e++]; if (void 0 !== f) { var g = f[d]; if (void 0 !== g) if (Array.isArray(g)) { do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f) } else if (void 0 !== g.toArray) { do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f) } else { do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f) } } } }; Object.assign(da, { parse: function (a) { if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse"); var b = da._getTrackTypeForValueTypeName(a.type); if (void 0 === a.times) { var c = [], d = []; fa.flattenJSON(a.keys, c, d, "value"); a.times = c; a.values = d } return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation) }, toJSON: function (a) { var b = a.constructor; if (void 0 !== b.toJSON) b = b.toJSON(a); else { b = { name: a.name, times: fa.convertArray(a.times, Array), values: fa.convertArray(a.values, Array) }; var c = a.getInterpolation(); c !== a.DefaultInterpolation && (b.interpolation = c) } b.type = a.ValueTypeName; return b }, _getTrackTypeForValueTypeName: function (a) { switch (a.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return gc; case "vector": case "vector2": case "vector3": case "vector4": return hc; case "color": return Jd; case "quaternion": return ad; case "bool": case "boolean": return Hd; case "string": return Gd }throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a); } }); Object.assign(da.prototype, { constructor: da, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (a) { return new Ld(this.times, this.values, this.getValueSize(), a) }, InterpolantFactoryMethodLinear: function (a) { return new bd(this.times, this.values, this.getValueSize(), a) }, InterpolantFactoryMethodSmooth: function (a) { return new Kd(this.times, this.values, this.getValueSize(), a) }, setInterpolation: function (a) { switch (a) { case 2300: var b = this.InterpolantFactoryMethodDiscrete; break; case 2301: b = this.InterpolantFactoryMethodLinear; break; case 2302: b = this.InterpolantFactoryMethodSmooth }if (void 0 === b) { b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw Error(b); console.warn("THREE.KeyframeTrack:", b) } else this.createInterpolant = b }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (a) { if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] += a; return this }, scale: function (a) { if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] *= a; return this }, trim: function (a, b) { for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;)++e; for (; -1 !== f && c[f] > b;)--f; ++f; if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = fa.arraySlice(c, e, f), this.values = fa.arraySlice(this.values, e * a, f * a); return this }, validate: function () { var a = !0, b = this.getValueSize(); 0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1); var c = this.times; b = this.values; var d = c.length; 0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1); for (var e = null, f = 0; f !== d; f++) { var g = c[f]; if ("number" === typeof g && isNaN(g)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g); a = !1; break } if (null !== e && e > g) { console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e); a = !1; break } e = g } if (void 0 !== b && fa.isTypedArray(b)) for (f = 0, c = b.length; f !== c; ++f)if (d = b[f], isNaN(d)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d); a = !1; break } return a }, optimize: function () { for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) { var h = !1, l = a[g]; if (l !== a[g + 1] && (1 !== g || l !== l[0])) if (d) h = !0; else { var k = g * c, p = k - c, n = k + c; for (l = 0; l !== c; ++l) { var t = b[k + l]; if (t !== b[p + l] || t !== b[n + l]) { h = !0; break } } } if (h) { if (g !== e) for (a[e] = a[g], h = g * c, k = e * c, l = 0; l !== c; ++l)b[k + l] = b[h + l]; ++e } } if (0 < f) { a[e] = a[f]; h = f * c; k = e * c; for (l = 0; l !== c; ++l)b[k + l] = b[h + l]; ++e } e !== a.length && (this.times = fa.arraySlice(a, 0, e), this.values = fa.arraySlice(b, 0, e * c)); return this } }); hc.prototype = Object.assign(Object.create(da.prototype), { constructor: hc, ValueTypeName: "vector" }); Object.assign(Ba, { parse: function (a) { for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e)b.push(da.parse(c[e]).scale(d)); return new Ba(a.name, a.duration, b) }, toJSON: function (a) { var b = [], c = a.tracks; a = { name: a.name, duration: a.duration, tracks: b }; for (var d = 0, e = c.length; d !== e; ++d)b.push(da.toJSON(c[d])); return a }, CreateFromMorphTargetSequence: function (a, b, c, d) { for (var e = b.length, f = [], g = 0; g < e; g++) { var h = [], l = []; h.push((g + e - 1) % e, g, (g + 1) % e); l.push(0, 1, 0); var k = fa.getKeyframeOrder(h); h = fa.sortedArray(h, 1, k); l = fa.sortedArray(l, 1, k); d || 0 !== h[0] || (h.push(e), l.push(l[0])); f.push((new gc(".morphTargetInfluences[" + b[g].name + "]", h, l)).scale(1 / c)) } return new Ba(a, -1, f) }, findByName: function (a, b) { var c = a; Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations); for (a = 0; a < c.length; a++)if (c[a].name === b) return c[a]; return null }, CreateClipsFromMorphTargetSequences: function (a, b, c) { for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) { var h = a[f], l = h.name.match(e); if (l && 1 < l.length) { var k = l[1]; (l = d[k]) || (d[k] = l = []); l.push(h) } } a = []; for (k in d) a.push(Ba.CreateFromMorphTargetSequence(k, d[k], b, c)); return a }, parseAnimation: function (a, b) { if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; var c = function (a, b, c, d, e) { if (0 !== c.length) { var f = [], g = []; fa.flattenJSON(c, f, g, d); 0 !== f.length && e.push(new a(b, f, g)) } }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30; a = a.hierarchy || []; for (var h = 0; h < a.length; h++) { var l = a[h].keys; if (l && 0 !== l.length) if (l[0].morphTargets) { f = {}; for (var k = 0; k < l.length; k++)if (l[k].morphTargets) for (var p = 0; p < l[k].morphTargets.length; p++)f[l[k].morphTargets[p]] = -1; for (var n in f) { var t = [], r = []; for (p = 0; p !== l[k].morphTargets.length; ++p) { var q = l[k]; t.push(q.time); r.push(q.morphTarget === n ? 1 : 0) } d.push(new gc(".morphTargetInfluence[" + n + "]", t, r)) } f = f.length * (g || 1) } else k = ".bones[" + b[h].name + "]", c(hc, k + ".position", l, "pos", d), c(ad, k + ".quaternion", l, "rot", d), c(hc, k + ".scale", l, "scl", d) } return 0 === d.length ? null : new Ba(e, f, d) } }); Object.assign(Ba.prototype, { resetDuration: function () { for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) { var d = this.tracks[b]; a = Math.max(a, d.times[d.times.length - 1]) } this.duration = a }, trim: function () { for (var a = 0; a < this.tracks.length; a++)this.tracks[a].trim(0, this.duration); return this }, optimize: function () { for (var a = 0; a < this.tracks.length; a++)this.tracks[a].optimize(); return this } }); Object.assign(Md.prototype, { load: function (a, b, c, d) { var e = this; (new Ka(e.manager)).load(a, function (a) { b(e.parse(JSON.parse(a))) }, c, d) }, setTextures: function (a) { this.textures = a }, parse: function (a) { function b(a) { void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a); return c[a] } var c = this.textures, d = new Mg[a.type]; void 0 !== a.uuid && (d.uuid = a.uuid); void 0 !== a.name && (d.name = a.name); void 0 !== a.color && d.color.setHex(a.color); void 0 !== a.roughness && (d.roughness = a.roughness); void 0 !== a.metalness && (d.metalness = a.metalness); void 0 !== a.emissive && d.emissive.setHex(a.emissive); void 0 !== a.specular && d.specular.setHex(a.specular); void 0 !== a.shininess && (d.shininess = a.shininess); void 0 !== a.clearCoat && (d.clearCoat = a.clearCoat); void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness); void 0 !== a.uniforms && (d.uniforms = a.uniforms); void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader); void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader); void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors); void 0 !== a.fog && (d.fog = a.fog); void 0 !== a.flatShading && (d.flatShading = a.flatShading); void 0 !== a.blending && (d.blending = a.blending); void 0 !== a.side && (d.side = a.side); void 0 !== a.opacity && (d.opacity = a.opacity); void 0 !== a.transparent && (d.transparent = a.transparent); void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest); void 0 !== a.depthTest && (d.depthTest = a.depthTest); void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite); void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite); void 0 !== a.wireframe && (d.wireframe = a.wireframe); void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth); void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap); void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin); void 0 !== a.rotation && (d.rotation = a.rotation); 1 !== a.linewidth && (d.linewidth = a.linewidth); void 0 !== a.dashSize && (d.dashSize = a.dashSize); void 0 !== a.gapSize && (d.gapSize = a.gapSize); void 0 !== a.scale && (d.scale = a.scale); void 0 !== a.polygonOffset && (d.polygonOffset = a.polygonOffset); void 0 !== a.polygonOffsetFactor && (d.polygonOffsetFactor = a.polygonOffsetFactor); void 0 !== a.polygonOffsetUnits && (d.polygonOffsetUnits = a.polygonOffsetUnits); void 0 !== a.skinning && (d.skinning = a.skinning); void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets); void 0 !== a.dithering && (d.dithering = a.dithering); void 0 !== a.visible && (d.visible = a.visible); void 0 !== a.userData && (d.userData = a.userData); void 0 !== a.shading && (d.flatShading = 1 === a.shading); void 0 !== a.size && (d.size = a.size); void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation); void 0 !== a.map && (d.map = b(a.map)); void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0); void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap)); void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale); void 0 !== a.normalMap && (d.normalMap = b(a.normalMap)); if (void 0 !== a.normalScale) { var e = a.normalScale; !1 === Array.isArray(e) && (e = [e, e]); d.normalScale = (new C).fromArray(e) } void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap)); void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale); void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias); void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap)); void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap)); void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap)); void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity); void 0 !== a.specularMap && (d.specularMap = b(a.specularMap)); void 0 !== a.envMap && (d.envMap = b(a.envMap)); void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity); void 0 !== a.lightMap && (d.lightMap = b(a.lightMap)); void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity); void 0 !== a.aoMap && (d.aoMap = b(a.aoMap)); void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity); void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap)); return d } }); Object.assign(ee.prototype, { load: function (a, b, c, d) { var e = this; (new Ka(e.manager)).load(a, function (a) { b(e.parse(JSON.parse(a))) }, c, d) }, parse: function (a) { var b = new F, c = a.data.index; void 0 !== c && (c = new uf[c.type](c.array), b.setIndex(new T(c, 1))); var d = a.data.attributes; for (f in d) { var e = d[f]; c = new uf[e.type](e.array); b.addAttribute(f, new T(c, e.itemSize, e.normalized)) } var f = a.data.groups || a.data.drawcalls || a.data.offsets; if (void 0 !== f) for (c = 0, d = f.length; c !== d; ++c)e = f[c], b.addGroup(e.start, e.count, e.materialIndex); a = a.data.boundingSphere; void 0 !== a && (f = new p, void 0 !== a.center && f.fromArray(a.center), b.boundingSphere = new Ea(f, a.radius)); return b } }); var uf = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; ic.Handlers = { handlers: [], add: function (a, b) { this.handlers.push(a, b) }, get: function (a) { for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) { var e = b[c + 1]; if (b[c].test(a)) return e } return null } }; Object.assign(ic.prototype, { crossOrigin: void 0, onLoadStart: function () { }, onLoadProgress: function () { }, onLoadComplete: function () { }, initMaterials: function (a, b, c) { for (var d = [], e = 0; e < a.length; ++e)d[e] = this.createMaterial(a[e], b, c); return d }, createMaterial: function () { var a = { NoBlending: 0, NormalBlending: 1, AdditiveBlending: 2, SubtractiveBlending: 3, MultiplyBlending: 4, CustomBlending: 5 }, b = new I, c = new xd, d = new Md; return function (e, f, g) { function h(a, b, d, e, h) { a = f + a; var k = ic.Handlers.get(a); null !== k ? a = k.load(a) : (c.setCrossOrigin(g), a = c.load(a)); void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1E3), 1 !== b[1] && (a.wrapT = 1E3)); void 0 !== d && a.offset.fromArray(d); void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1E3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1E3), "mirror" === e[1] && (a.wrapT = 1002)); void 0 !== h && (a.anisotropy = h); b = S.generateUUID(); l[b] = a; return b } var l = {}, k = { uuid: S.generateUUID(), type: "MeshLambertMaterial" }, p; for (p in e) { var n = e[p]; switch (p) { case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": break; case "DbgName": k.name = n; break; case "blending": k.blending = a[n]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", p, "is no longer supported."); break; case "colorDiffuse": k.color = b.fromArray(n).getHex(); break; case "colorSpecular": k.specular = b.fromArray(n).getHex(); break; case "colorEmissive": k.emissive = b.fromArray(n).getHex(); break; case "specularCoef": k.shininess = n; break; case "shading": "basic" === n.toLowerCase() && (k.type = "MeshBasicMaterial"); "phong" === n.toLowerCase() && (k.type = "MeshPhongMaterial"); "standard" === n.toLowerCase() && (k.type = "MeshStandardMaterial"); break; case "mapDiffuse": k.map = h(n, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy); break; case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": break; case "mapEmissive": k.emissiveMap = h(n, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy); break; case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": break; case "mapLight": k.lightMap = h(n, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy); break; case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": break; case "mapAO": k.aoMap = h(n, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy); break; case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": break; case "mapBump": k.bumpMap = h(n, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy); break; case "mapBumpScale": k.bumpScale = n; break; case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": break; case "mapNormal": k.normalMap = h(n, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy); break; case "mapNormalFactor": k.normalScale = n; break; case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": break; case "mapSpecular": k.specularMap = h(n, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy); break; case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": break; case "mapMetalness": k.metalnessMap = h(n, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy); break; case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": break; case "mapRoughness": k.roughnessMap = h(n, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy); break; case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": break; case "mapAlpha": k.alphaMap = h(n, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy); break; case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "flipSided": k.side = 1; break; case "doubleSided": k.side = 2; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"); k.opacity = n; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": k[p] = n; break; case "vertexColors": !0 === n && (k.vertexColors = 2); "face" === n && (k.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", p, n) } } "MeshBasicMaterial" === k.type && delete k.emissive; "MeshPhongMaterial" !== k.type && delete k.specular; 1 > k.opacity && (k.transparent = !0); d.setTextures(l); return d.parse(k) } }() }); var Be = { decodeText: function (a) { if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(a); for (var b = "", c = 0, d = a.length; c < d; c++)b += String.fromCharCode(a[c]); return decodeURIComponent(escape(b)) }, extractUrlBase: function (a) { a = a.split("/"); if (1 === a.length) return "./"; a.pop(); return a.join("/") + "/" } }; Object.assign(fe.prototype, { load: function (a, b, c, d) { var e = this, f = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : Be.extractUrlBase(a), g = new Ka(this.manager); g.setWithCredentials(this.withCredentials); g.load(a, function (c) { c = JSON.parse(c); var d = c.metadata; if (void 0 !== d && (d = d.type, void 0 !== d && "object" === d.toLowerCase())) { console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead."); return } c = e.parse(c, f); b(c.geometry, c.materials) }, c, d) }, setTexturePath: function (a) { this.texturePath = a }, parse: function () { return function (a, b) { void 0 !== a.data && (a = a.data); a.scale = void 0 !== a.scale ? 1 / a.scale : 1; var c = new N, d = a, e, f, g, h = d.faces; var l = d.vertices; var k = d.normals, u = d.colors; var n = d.scale; var t = 0; if (void 0 !== d.uvs) { for (e = 0; e < d.uvs.length; e++)d.uvs[e].length && t++; for (e = 0; e < t; e++)c.faceVertexUvs[e] = [] } var r = 0; for (g = l.length; r < g;)e = new p, e.x = l[r++] * n, e.y = l[r++] * n, e.z = l[r++] * n, c.vertices.push(e); r = 0; for (g = h.length; r < g;) { l = h[r++]; var q = l & 1; var v = l & 2; e = l & 8; var x = l & 16; var y = l & 32; n = l & 64; l &= 128; if (q) { q = new Wa; q.a = h[r]; q.b = h[r + 1]; q.c = h[r + 3]; var w = new Wa; w.a = h[r + 1]; w.b = h[r + 2]; w.c = h[r + 3]; r += 4; v && (v = h[r++], q.materialIndex = v, w.materialIndex = v); v = c.faces.length; if (e) for (e = 0; e < t; e++) { var B = d.uvs[e]; c.faceVertexUvs[e][v] = []; c.faceVertexUvs[e][v + 1] = []; for (f = 0; 4 > f; f++) { var z = h[r++]; var A = B[2 * z]; z = B[2 * z + 1]; A = new C(A, z); 2 !== f && c.faceVertexUvs[e][v].push(A); 0 !== f && c.faceVertexUvs[e][v + 1].push(A) } } x && (x = 3 * h[r++], q.normal.set(k[x++], k[x++], k[x]), w.normal.copy(q.normal)); if (y) for (e = 0; 4 > e; e++)x = 3 * h[r++], y = new p(k[x++], k[x++], k[x]), 2 !== e && q.vertexNormals.push(y), 0 !== e && w.vertexNormals.push(y); n && (n = h[r++], n = u[n], q.color.setHex(n), w.color.setHex(n)); if (l) for (e = 0; 4 > e; e++)n = h[r++], n = u[n], 2 !== e && q.vertexColors.push(new I(n)), 0 !== e && w.vertexColors.push(new I(n)); c.faces.push(q); c.faces.push(w) } else { q = new Wa; q.a = h[r++]; q.b = h[r++]; q.c = h[r++]; v && (v = h[r++], q.materialIndex = v); v = c.faces.length; if (e) for (e = 0; e < t; e++)for (B = d.uvs[e], c.faceVertexUvs[e][v] = [], f = 0; 3 > f; f++)z = h[r++], A = B[2 * z], z = B[2 * z + 1], A = new C(A, z), c.faceVertexUvs[e][v].push(A); x && (x = 3 * h[r++], q.normal.set(k[x++], k[x++], k[x])); if (y) for (e = 0; 3 > e; e++)x = 3 * h[r++], y = new p(k[x++], k[x++], k[x]), q.vertexNormals.push(y); n && (n = h[r++], q.color.setHex(u[n])); if (l) for (e = 0; 3 > e; e++)n = h[r++], q.vertexColors.push(new I(u[n])); c.faces.push(q) } } d = a; r = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2; if (d.skinWeights) for (g = 0, h = d.skinWeights.length; g < h; g += r)c.skinWeights.push(new ea(d.skinWeights[g], 1 < r ? d.skinWeights[g + 1] : 0, 2 < r ? d.skinWeights[g + 2] : 0, 3 < r ? d.skinWeights[g + 3] : 0)); if (d.skinIndices) for (g = 0, h = d.skinIndices.length; g < h; g += r)c.skinIndices.push(new ea(d.skinIndices[g], 1 < r ? d.skinIndices[g + 1] : 0, 2 < r ? d.skinIndices[g + 2] : 0, 3 < r ? d.skinIndices[g + 3] : 0)); c.bones = d.bones; c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match."); g = a; h = g.scale; if (void 0 !== g.morphTargets) for (d = 0, r = g.morphTargets.length; d < r; d++)for (c.morphTargets[d] = {}, c.morphTargets[d].name = g.morphTargets[d].name, c.morphTargets[d].vertices = [], k = c.morphTargets[d].vertices, u = g.morphTargets[d].vertices, t = 0, l = u.length; t < l; t += 3)n = new p, n.x = u[t] * h, n.y = u[t + 1] * h, n.z = u[t + 2] * h, k.push(n); if (void 0 !== g.morphColors && 0 < g.morphColors.length) for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), h = c.faces, g = g.morphColors[0].colors, d = 0, r = h.length; d < r; d++)h[d].color.fromArray(g, 3 * d); g = a; d = []; r = []; void 0 !== g.animation && r.push(g.animation); void 0 !== g.animations && (g.animations.length ? r = r.concat(g.animations) : r.push(g.animations)); for (g = 0; g < r.length; g++)(h = Ba.parseAnimation(r[g], c.bones)) && d.push(h); c.morphTargets && (r = Ba.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), d = d.concat(r)); 0 < d.length && (c.animations = d); c.computeFaceNormals(); c.computeBoundingSphere(); if (void 0 === a.materials || 0 === a.materials.length) return { geometry: c }; a = ic.prototype.initMaterials(a.materials, b, this.crossOrigin); return { geometry: c, materials: a } } }() }); Object.assign(ff.prototype, { load: function (a, b, c, d) { "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1)); var e = this; (new Ka(e.manager)).load(a, function (c) { var f = null; try { f = JSON.parse(c) } catch (h) { void 0 !== d && d(h); console.error("THREE:ObjectLoader: Can't parse " + a + ".", h.message); return } c = f.metadata; void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(f, b) }, c, d) }, setTexturePath: function (a) { this.texturePath = a }, setCrossOrigin: function (a) { this.crossOrigin = a }, parse: function (a, b) { var c = this.parseShape(a.shapes); c = this.parseGeometries(a.geometries, c); var d = this.parseImages(a.images, function () { void 0 !== b && b(e) }); d = this.parseTextures(a.textures, d); d = this.parseMaterials(a.materials, d); var e = this.parseObject(a.object, c, d); a.animations && (e.animations = this.parseAnimations(a.animations)); void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e); return e }, parseShape: function (a) { var b = {}; if (void 0 !== a) for (var c = 0, d = a.length; c < d; c++) { var e = (new gb).fromJSON(a[c]); b[e.uuid] = e } return b }, parseGeometries: function (a, b) { var c = {}; if (void 0 !== a) for (var d = new fe, e = new ee, f = 0, g = a.length; f < g; f++) { var h = a[f]; switch (h.type) { case "PlaneGeometry": case "PlaneBufferGeometry": var l = new Ca[h.type](h.width, h.height, h.widthSegments, h.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": l = new Ca[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": l = new Ca[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": l = new Ca[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": l = new Ca[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": l = new Ca[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": l = new Ca[h.type](h.radius, h.detail); break; case "RingGeometry": case "RingBufferGeometry": l = new Ca[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": l = new Ca[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": l = new Ca[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q); break; case "LatheGeometry": case "LatheBufferGeometry": l = new Ca[h.type](h.points, h.segments, h.phiStart, h.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": l = new Ca[h.type](h.vertices, h.indices, h.radius, h.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": l = []; f = 0; for (g = h.shapes.length; f < g; f++)l.push(b[h.shapes[f]]); l = new Ca[h.type](l, h.curveSegments); break; case "BufferGeometry": l = e.parse(h); break; case "Geometry": l = d.parse(h, this.texturePath).geometry; break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"'); continue }l.uuid = h.uuid; void 0 !== h.name && (l.name = h.name); c[h.uuid] = l } return c }, parseMaterials: function (a, b) { var c = {}; if (void 0 !== a) { var d = new Md; d.setTextures(b); b = 0; for (var e = a.length; b < e; b++) { var f = a[b]; if ("MultiMaterial" === f.type) { for (var g = [], h = 0; h < f.materials.length; h++)g.push(d.parse(f.materials[h])); c[f.uuid] = g } else c[f.uuid] = d.parse(f) } } return c }, parseAnimations: function (a) { for (var b = [], c = 0; c < a.length; c++) { var d = Ba.parse(a[c]); b.push(d) } return b }, parseImages: function (a, b) { function c(a) { d.manager.itemStart(a); return f.load(a, function () { d.manager.itemEnd(a) }, void 0, function () { d.manager.itemEnd(a); d.manager.itemError(a) }) } var d = this, e = {}; if (void 0 !== a && 0 < a.length) { b = new ae(b); var f = new Yc(b); f.setCrossOrigin(this.crossOrigin); b = 0; for (var g = a.length; b < g; b++) { var h = a[b], l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : d.texturePath + h.url; e[h.uuid] = c(l) } } return e }, parseTextures: function (a, b) { function c(a, b) { if ("number" === typeof a) return a; console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a); return b[a] } var d = {}; if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) { var g = a[e]; void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid); void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image); var h = new Y(b[g.image]); h.needsUpdate = !0; h.uuid = g.uuid; void 0 !== g.name && (h.name = g.name); void 0 !== g.mapping && (h.mapping = c(g.mapping, Og)); void 0 !== g.offset && h.offset.fromArray(g.offset); void 0 !== g.repeat && h.repeat.fromArray(g.repeat); void 0 !== g.center && h.center.fromArray(g.center); void 0 !== g.rotation && (h.rotation = g.rotation); void 0 !== g.wrap && (h.wrapS = c(g.wrap[0], vf), h.wrapT = c(g.wrap[1], vf)); void 0 !== g.format && (h.format = g.format); void 0 !== g.minFilter && (h.minFilter = c(g.minFilter, wf)); void 0 !== g.magFilter && (h.magFilter = c(g.magFilter, wf)); void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy); void 0 !== g.flipY && (h.flipY = g.flipY); d[g.uuid] = h } return d }, parseObject: function (a, b, c) { function d(a) { void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a); return b[a] } function e(a) { if (void 0 !== a) { if (Array.isArray(a)) { for (var b = [], d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f); b.push(c[f]) } return b } void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a); return c[a] } } switch (a.type) { case "Scene": var f = new rd; void 0 !== a.background && Number.isInteger(a.background) && (f.background = new I(a.background)); void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new Pb(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new Ob(a.fog.color, a.fog.density))); break; case "PerspectiveCamera": f = new la(a.fov, a.aspect, a.near, a.far); void 0 !== a.focus && (f.focus = a.focus); void 0 !== a.zoom && (f.zoom = a.zoom); void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge); void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset); void 0 !== a.view && (f.view = Object.assign({}, a.view)); break; case "OrthographicCamera": f = new Jb(a.left, a.right, a.top, a.bottom, a.near, a.far); void 0 !== a.zoom && (f.zoom = a.zoom); void 0 !== a.view && (f.view = Object.assign({}, a.view)); break; case "AmbientLight": f = new Ed(a.color, a.intensity); break; case "DirectionalLight": f = new Dd(a.color, a.intensity); break; case "PointLight": f = new Bd(a.color, a.intensity, a.distance, a.decay); break; case "RectAreaLight": f = new Fd(a.color, a.intensity, a.width, a.height); break; case "SpotLight": f = new Ad(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay); break; case "HemisphereLight": f = new yd(a.color, a.groundColor, a.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": f = d(a.geometry); var g = e(a.material); f = f.bones && 0 < f.bones.length ? new td(f, g) : new oa(f, g); break; case "LOD": f = new Bc; break; case "Line": f = new ua(d(a.geometry), e(a.material), a.mode); break; case "LineLoop": f = new ud(d(a.geometry), e(a.material)); break; case "LineSegments": f = new aa(d(a.geometry), e(a.material)); break; case "PointCloud": case "Points": f = new Qb(d(a.geometry), e(a.material)); break; case "Sprite": f = new Ac(e(a.material)); break; case "Group": f = new vd; break; default: f = new A }f.uuid = a.uuid; void 0 !== a.name && (f.name = a.name); void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale)); void 0 !== a.castShadow && (f.castShadow = a.castShadow); void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow); a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera))); void 0 !== a.visible && (f.visible = a.visible); void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled); void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder); void 0 !== a.userData && (f.userData = a.userData); if (void 0 !== a.children) { g = a.children; for (var h = 0; h < g.length; h++)f.add(this.parseObject(g[h], b, c)) } if ("LOD" === a.type) for (a = a.levels, g = 0; g < a.length; g++) { h = a[g]; var l = f.getObjectByProperty("uuid", h.object); void 0 !== l && f.addLevel(l, h.distance) } return f } }); var Og = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }, vf = { RepeatWrapping: 1E3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, wf = { NearestFilter: 1003, NearestMipMapNearestFilter: 1004, NearestMipMapLinearFilter: 1005, LinearFilter: 1006, LinearMipMapNearestFilter: 1007, LinearMipMapLinearFilter: 1008 }; ge.prototype = { constructor: ge, setOptions: function (a) { this.options = a; return this }, load: function (a, b, c, d) { void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); var e = this, f = Hb.get(a); if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a) }, 0), f; fetch(a).then(function (a) { return a.blob() }).then(function (a) { return createImageBitmap(a, e.options) }).then(function (c) { Hb.add(a, c); b && b(c); e.manager.itemEnd(a) }).catch(function (b) { d && d(b); e.manager.itemEnd(a); e.manager.itemError(a) }) }, setCrossOrigin: function () { return this }, setPath: function (a) { this.path = a; return this } }; Object.assign(he.prototype, { moveTo: function (a, b) { this.currentPath = new Pa; this.subPaths.push(this.currentPath); this.currentPath.moveTo(a, b) }, lineTo: function (a, b) { this.currentPath.lineTo(a, b) }, quadraticCurveTo: function (a, b, c, d) { this.currentPath.quadraticCurveTo(a, b, c, d) }, bezierCurveTo: function (a, b, c, d, e, f) { this.currentPath.bezierCurveTo(a, b, c, d, e, f) }, splineThru: function (a) { this.currentPath.splineThru(a) }, toShapes: function (a, b) { function c(a) { for (var b = [], c = 0, d = a.length; c < d; c++) { var e = a[c], f = new gb; f.curves = e.curves; b.push(f) } return b } function d(a, b) { for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) { var g = b[e], h = b[f], l = h.x - g.x, k = h.y - g.y; if (Math.abs(k) > Number.EPSILON) { if (0 > k && (g = b[f], l = -l, h = b[e], k = -k), !(a.y < g.y || a.y > h.y)) if (a.y === g.y) { if (a.x === g.x) return !0 } else { e = k * (a.x - g.x) - l * (a.y - g.y); if (0 === e) return !0; 0 > e || (d = !d) } } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0 } return d } var e = Xa.isClockWise, f = this.subPaths; if (0 === f.length) return []; if (!0 === b) return c(f); b = []; if (1 === f.length) { var g = f[0]; var h = new gb; h.curves = g.curves; b.push(h); return b } var l = !e(f[0].getPoints()); l = a ? !l : l; h = []; var k = [], p = [], n = 0; k[n] = void 0; p[n] = []; for (var t = 0, r = f.length; t < r; t++) { g = f[t]; var q = g.getPoints(); var v = e(q); (v = a ? !v : v) ? (!l && k[n] && n++, k[n] = { s: new gb, p: q }, k[n].s.curves = g.curves, l && n++, p[n] = []) : p[n].push({ h: g, p: q[0] }) } if (!k[0]) return c(f); if (1 < k.length) { t = !1; a = []; e = 0; for (f = k.length; e < f; e++)h[e] = []; e = 0; for (f = k.length; e < f; e++)for (g = p[e], v = 0; v < g.length; v++) { l = g[v]; n = !0; for (q = 0; q < k.length; q++)d(l.p, k[q].p) && (e !== q && a.push({ froms: e, tos: q, hole: v }), n ? (n = !1, h[q].push(l)) : t = !0); n && h[e].push(l) } 0 < a.length && (t || (p = h)) } t = 0; for (e = k.length; t < e; t++)for (h = k[t].s, b.push(h), a = p[t], f = 0, g = a.length; f < g; f++)h.holes.push(a[f].h); return b } }); Object.assign(ie.prototype, { isFont: !0, generateShapes: function (a, b, c) { void 0 === b && (b = 100); c = []; var d = b; b = this.data; var e = String(a).split(""); d /= b.resolution; var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d; a = []; for (var g = 0, h = 0, l = 0; l < e.length; l++) { var k = e[l]; if ("\n" === k) g = 0, h -= f; else { var p = d; var n = g, t = h; if (k = b.glyphs[k] || b.glyphs["?"]) { var r = new he; if (k.o) for (var q = k._cachedOutline || (k._cachedOutline = k.o.split(" ")), v = 0, x = q.length; v < x;)switch (q[v++]) { case "m": var y = q[v++] * p + n; var w = q[v++] * p + t; r.moveTo(y, w); break; case "l": y = q[v++] * p + n; w = q[v++] * p + t; r.lineTo(y, w); break; case "q": var z = q[v++] * p + n; var A = q[v++] * p + t; var C = q[v++] * p + n; var E = q[v++] * p + t; r.quadraticCurveTo(C, E, z, A); break; case "b": z = q[v++] * p + n, A = q[v++] * p + t, C = q[v++] * p + n, E = q[v++] * p + t, y = q[v++] * p + n, w = q[v++] * p + t, r.bezierCurveTo(C, E, y, w, z, A) }p = { offsetX: k.ha * p, path: r } } else p = void 0; g += p.offsetX; a.push(p.path) } } b = 0; for (e = a.length; b < e; b++)Array.prototype.push.apply(c, a[b].toShapes()); return c } }); Object.assign(gf.prototype, { load: function (a, b, c, d) { var e = this, f = new Ka(this.manager); f.setPath(this.path); f.load(a, function (a) { try { var c = JSON.parse(a) } catch (l) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2)) } a = e.parse(c); b && b(a) }, c, d) }, parse: function (a) { return new ie(a) }, setPath: function (a) { this.path = a; return this } }); var Rd, le = { getContext: function () { void 0 === Rd && (Rd = new (window.AudioContext || window.webkitAudioContext)); return Rd }, setContext: function (a) { Rd = a } }; Object.assign(je.prototype, { load: function (a, b, c, d) { var e = new Ka(this.manager); e.setResponseType("arraybuffer"); e.load(a, function (a) { le.getContext().decodeAudioData(a, function (a) { b(a) }) }, c, d) } }); Object.assign(hf.prototype, { update: function () { var a, b, c, d, e, f, g, h, l = new M, k = new M; return function (m) { if (a !== this || b !== m.focus || c !== m.fov || d !== m.aspect * this.aspect || e !== m.near || f !== m.far || g !== m.zoom || h !== this.eyeSep) { a = this; b = m.focus; c = m.fov; d = m.aspect * this.aspect; e = m.near; f = m.far; g = m.zoom; var n = m.projectionMatrix.clone(); h = this.eyeSep / 2; var p = h * e / b, r = e * Math.tan(S.DEG2RAD * c * .5) / g; k.elements[12] = -h; l.elements[12] = h; var q = -r * d + p; var u = r * d + p; n.elements[0] = 2 * e / (u - q); n.elements[8] = (u + q) / (u - q); this.cameraL.projectionMatrix.copy(n); q = -r * d - p; u = r * d - p; n.elements[0] = 2 * e / (u - q); n.elements[8] = (u + q) / (u - q); this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(k); this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(l) } }() }); cd.prototype = Object.create(A.prototype); cd.prototype.constructor = cd; ke.prototype = Object.assign(Object.create(A.prototype), { constructor: ke, getInput: function () { return this.gain }, removeFilter: function () { null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null) }, getFilter: function () { return this.filter }, setFilter: function (a) { null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination); this.filter = a; this.gain.connect(this.filter); this.filter.connect(this.context.destination) }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (a) { this.gain.gain.value = a }, updateMatrixWorld: function () { var a = new p, b = new ja, c = new p, d = new p; return function (e) { A.prototype.updateMatrixWorld.call(this, e); e = this.context.listener; var f = this.up; this.matrixWorld.decompose(a, b, c); d.set(0, 0, -1).applyQuaternion(b); e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z)) } }() }); jc.prototype = Object.assign(Object.create(A.prototype), { constructor: jc, getOutput: function () { return this.gain }, setNodeSource: function (a) { this.hasPlaybackControl = !1; this.sourceType = "audioNode"; this.source = a; this.connect(); return this }, setBuffer: function (a) { this.buffer = a; this.sourceType = "buffer"; this.autoplay && this.play(); return this }, play: function () { if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else { var a = this.context.createBufferSource(); a.buffer = this.buffer; a.loop = this.loop; a.onended = this.onEnded.bind(this); a.playbackRate.setValueAtTime(this.playbackRate, this.startTime); this.startTime = this.context.currentTime; a.start(this.startTime, this.offset); this.isPlaying = !0; this.source = a; return this.connect() } }, pause: function () { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this }, stop: function () { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.source.stop(), this.offset = 0, this.isPlaying = !1, this }, connect: function () { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].connect(this.filters[a]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].disconnect(this.filters[a]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (a) { a || (a = []); !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a; return this }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (a) { return this.setFilters(a ? [a] : []) }, setPlaybackRate: function (a) { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (a) { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this }, getVolume: function () { return this.gain.gain.value }, setVolume: function (a) { this.gain.gain.value = a; return this } }); me.prototype = Object.assign(Object.create(jc.prototype), { constructor: me, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (a) { this.panner.refDistance = a }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (a) { this.panner.rolloffFactor = a }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (a) { this.panner.distanceModel = a }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (a) { this.panner.maxDistance = a }, updateMatrixWorld: function () { var a = new p; return function (b) { A.prototype.updateMatrixWorld.call(this, b); a.setFromMatrixPosition(this.matrixWorld); this.panner.setPosition(a.x, a.y, a.z) } }() }); Object.assign(ne.prototype, { getFrequencyData: function () { this.analyser.getByteFrequencyData(this.data); return this.data }, getAverageFrequency: function () { for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++)a += b[c]; return a / b.length } }); Object.assign(oe.prototype, { accumulate: function (a, b) { var c = this.buffer, d = this.valueSize; a = a * d + d; var e = this.cumulativeWeight; if (0 === e) { for (e = 0; e !== d; ++e)c[a + e] = c[e]; e = b } else e += b, this._mixBufferRegion(c, a, 0, b / e, d); this.cumulativeWeight = e }, apply: function (a) { var b = this.valueSize, c = this.buffer; a = a * b + b; var d = this.cumulativeWeight, e = this.binding; this.cumulativeWeight = 0; 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b); d = b; for (var f = b + b; d !== f; ++d)if (c[d] !== c[d + b]) { e.setValue(c, a); break } }, saveOriginalState: function () { var a = this.buffer, b = this.valueSize, c = 3 * b; this.binding.getValue(a, c); for (var d = b; d !== c; ++d)a[d] = a[c + d % b]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { this.binding.setValue(this.buffer, 3 * this.valueSize) }, _select: function (a, b, c, d, e) { if (.5 <= d) for (d = 0; d !== e; ++d)a[b + d] = a[c + d] }, _slerp: function (a, b, c, d) { ja.slerpFlat(a, b, a, b, a, c, d) }, _lerp: function (a, b, c, d, e) { for (var f = 1 - d, g = 0; g !== e; ++g) { var h = b + g; a[h] = a[h] * f + a[c + g] * d } } }); Object.assign(jf.prototype, { getValue: function (a, b) { this.bind(); var c = this._bindings[this._targetGroup.nCachedObjects_]; void 0 !== c && c.getValue(a, b) }, setValue: function (a, b) { for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d)c[d].setValue(a, b) }, bind: function () { for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].bind() }, unbind: function () { for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].unbind() } }); Object.assign(qa, {
        Composite: jf, create: function (a, b, c) { return a && a.isAnimationObjectGroup ? new qa.Composite(a, b, c) : new qa(a, b, c) }, sanitizeNodeName: function () { var a = /[\[\]\.:\/]/g; return function (b) { return b.replace(/\s/g, "_").replace(a, "") } }(), parseTrackName: function () {
            var a = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", b = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"); a = /(WCOD+)?/.source.replace("WCOD", a); var c = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), d = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), e = new RegExp("^" + b + a + c + d + "$"), f = ["material", "materials", "bones"]; return function (a) {
                var b = e.exec(a); if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a); b = { nodeName: b[2], objectName: b[3], objectIndex: b[4], propertyName: b[5], propertyIndex: b[6] }; var c = b.nodeName && b.nodeName.lastIndexOf("."); if (void 0 !== c && -1 !== c) { var d = b.nodeName.substring(c + 1); -1 !== f.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = d) } if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " +
                    a); return b
            }
        }(), findNode: function (a, b) { if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a; if (a.skeleton) { var c = a.skeleton.getBoneByName(b); if (void 0 !== c) return c } if (a.children) { var d = function (a) { for (var c = 0; c < a.length; c++) { var e = a[c]; if (e.name === b || e.uuid === b || (e = d(e.children))) return e } return null }; if (a = d(a.children)) return a } return null }
    }); Object.assign(qa.prototype, {
        _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (a, b) { a[b] = this.node[this.propertyName] }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)a[b++] = c[d] }, function (a, b) { a[b] = this.resolvedProperty[this.propertyIndex] }, function (a, b) { this.resolvedProperty.toArray(a, b) }], SetterByBindingTypeAndVersioning: [[function (a, b) { this.targetObject[this.propertyName] = a[b] }, function (a, b) { this.targetObject[this.propertyName] = a[b]; this.targetObject.needsUpdate = !0 }, function (a, b) { this.targetObject[this.propertyName] = a[b]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++] }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; this.targetObject.needsUpdate = !0 }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b] }, function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b]; this.targetObject.needsUpdate = !0 }, function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (a, b) { this.resolvedProperty.fromArray(a, b) }, function (a, b) { this.resolvedProperty.fromArray(a, b); this.targetObject.needsUpdate = !0 }, function (a, b) { this.resolvedProperty.fromArray(a, b); this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (a, b) { this.bind(); this.getValue(a, b) }, setValue: function (a, b) { this.bind(); this.setValue(a, b) }, bind: function () {
            var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex; a || (this.node = a = qa.findNode(this.rootNode, b.nodeName) || this.rootNode); this.getValue = this._getValue_unavailable; this.setValue = this._setValue_unavailable; if (a) { if (c) { var f = b.objectIndex; switch (c) { case "materials": if (!a.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!a.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } a = a.material.materials; break; case "bones": if (!a.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } a = a.skeleton.bones; for (c = 0; c < a.length; c++)if (a[c].name === f) { f = c; break } break; default: if (void 0 === a[c]) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } a = a[c] }if (void 0 !== f) { if (void 0 === a[f]) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a); return } a = a[f] } } f = a[d]; if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a); else { b = this.Versioning.None; void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a); c = this.BindingType.Direct; if (void 0 !== e) { if ("morphTargetInfluences" === d) { if (!a.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (a.geometry.isBufferGeometry) { if (!a.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)if (a.geometry.morphAttributes.position[c].name === e) { e = c; break } } else { if (!a.geometry.morphTargets) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); return } for (c = 0; c < this.node.geometry.morphTargets.length; c++)if (a.geometry.morphTargets[c].name === e) { e = c; break } } } c = this.BindingType.ArrayElement; this.resolvedProperty = f; this.propertyIndex = e } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d; this.getValue = this.GetterByBindingType[c]; this.setValue = this.SetterByBindingTypeAndVersioning[c][b] } } else console.error("THREE.PropertyBinding: Trying to update node for track: " +
                this.path + " but it wasn't found.")
        }, unbind: function () { this.node = null; this.getValue = this._getValue_unbound; this.setValue = this._setValue_unbound }
    }); Object.assign(qa.prototype, { _getValue_unbound: qa.prototype.getValue, _setValue_unbound: qa.prototype.setValue }); Object.assign(kf.prototype, { isAnimationObjectGroup: !0, add: function () { for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, k = void 0, m = 0, p = arguments.length; m !== p; ++m) { var n = arguments[m], t = n.uuid, r = d[t]; if (void 0 === r) { r = b++; d[t] = r; a.push(n); t = 0; for (var q = h; t !== q; ++t)g[t].push(new qa(n, e[t], f[t])) } else if (r < c) { k = a[r]; var v = --c; q = a[v]; d[q.uuid] = r; a[r] = q; d[t] = v; a[v] = n; t = 0; for (q = h; t !== q; ++t) { var x = g[t], y = x[r]; x[r] = x[v]; void 0 === y && (y = new qa(n, e[t], f[t])); x[v] = y } } else a[r] !== k && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c }, remove: function () { for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) { var h = arguments[f], k = h.uuid, m = c[k]; if (void 0 !== m && m >= b) { var p = b++, n = a[p]; c[n.uuid] = m; a[m] = n; c[k] = p; a[p] = h; h = 0; for (k = e; h !== k; ++h) { n = d[h]; var t = n[m]; n[m] = n[p]; n[p] = t } } } this.nCachedObjects_ = b }, uncache: function () { for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) { var k = arguments[g].uuid, m = d[k]; if (void 0 !== m) if (delete d[k], m < c) { k = --c; var p = a[k], n = --b, t = a[n]; d[p.uuid] = m; a[m] = p; d[t.uuid] = k; a[k] = t; a.pop(); p = 0; for (t = f; p !== t; ++p) { var r = e[p], q = r[n]; r[m] = r[k]; r[k] = q; r.pop() } } else for (n = --b, t = a[n], d[t.uuid] = m, a[m] = t, a.pop(), p = 0, t = f; p !== t; ++p)r = e[p], r[m] = r[n], r.pop() } this.nCachedObjects_ = c }, subscribe_: function (a, b) { var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings; if (void 0 !== d) return e[d]; var f = this._paths, g = this._parsedPaths, h = this._objects, k = this.nCachedObjects_, m = Array(h.length); d = e.length; c[a] = d; f.push(a); g.push(b); e.push(m); c = k; for (d = h.length; c !== d; ++c)m[c] = new qa(h[c], a, b); return m }, unsubscribe_: function (a) { var b = this._bindingsIndicesByPath, c = b[a]; if (void 0 !== c) { var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h = f[g]; b[a[g]] = c; f[c] = h; f.pop(); e[c] = e[g]; e.pop(); d[c] = d[g]; d.pop() } } }); Object.assign(lf.prototype, { play: function () { this._mixer._activateAction(this); return this }, stop: function () { this._mixer._deactivateAction(this); return this.reset() }, reset: function () { this.paused = !1; this.enabled = !0; this.time = 0; this._loopCount = -1; this._startTime = null; return this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (a) { this._startTime = a; return this }, setLoop: function (a, b) { this.loop = a; this.repetitions = b; return this }, setEffectiveWeight: function (a) { this.weight = a; this._effectiveWeight = this.enabled ? a : 0; return this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (a) { return this._scheduleFading(a, 0, 1) }, fadeOut: function (a) { return this._scheduleFading(a, 1, 0) }, crossFadeFrom: function (a, b, c) { a.fadeOut(b); this.fadeIn(b); if (c) { c = this._clip.duration; var d = a._clip.duration, e = c / d; a.warp(1, d / c, b); this.warp(e, 1, b) } return this }, crossFadeTo: function (a, b, c) { return a.crossFadeFrom(this, b, c) }, stopFading: function () { var a = this._weightInterpolant; null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)); return this }, setEffectiveTimeScale: function (a) { this.timeScale = a; this._effectiveTimeScale = this.paused ? 0 : a; return this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (a) { this.timeScale = this._clip.duration / a; return this.stopWarping() }, syncWith: function (a) { this.time = a.time; this.timeScale = a.timeScale; return this.stopWarping() }, halt: function (a) { return this.warp(this._effectiveTimeScale, 0, a) }, warp: function (a, b, c) { var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale; null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()); d = f.parameterPositions; f = f.sampleValues; d[0] = e; d[1] = e + c; f[0] = a / g; f[1] = b / g; return this }, stopWarping: function () { var a = this._timeScaleInterpolant; null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)); return this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (a, b, c, d) { if (this.enabled) { var e = this._startTime; if (null !== e) { b = (a - e) * c; if (0 > b || 0 === c) return; this._startTime = null; b *= c } b *= this._updateTimeScale(a); c = this._updateTime(b); a = this._updateWeight(a); if (0 < a) { b = this._interpolants; e = this._propertyBindings; for (var f = 0, g = b.length; f !== g; ++f)b[f].evaluate(c), e[f].accumulate(d, a) } } else this._updateWeight(a) }, _updateWeight: function (a) { var b = 0; if (this.enabled) { b = this.weight; var c = this._weightInterpolant; if (null !== c) { var d = c.evaluate(a)[0]; b *= d; a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1)) } } return this._effectiveWeight = b }, _updateTimeScale: function (a) { var b = 0; if (!this.paused) { b = this.timeScale; var c = this._timeScaleInterpolant; if (null !== c) { var d = c.evaluate(a)[0]; b *= d; a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b) } } return this._effectiveTimeScale = b }, _updateTime: function (a) { var b = this.time + a; if (0 === a) return b; var c = this._clip.duration, d = this.loop, e = this._loopCount; if (2200 === d) a: { if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c; else if (0 > b) b = 0; else break a; this.clampWhenFinished ? this.paused = !0 : this.enabled = !1; this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 > a ? -1 : 1 }) } else { d = 2202 === d; -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d)); if (b >= c || 0 > b) { var f = Math.floor(b / c); b -= c * f; e += Math.abs(f); var g = this.repetitions - e; 0 >= g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < a ? 1 : -1 })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: f })) } if (d && 1 === (e & 1)) return this.time = b, c - b } return this.time = b }, _setEndings: function (a, b, c) { var d = this._interpolantSettings; c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) }, _scheduleFading: function (a, b, c) { var d = this._mixer, e = d.time, f = this._weightInterpolant; null === f && (this._weightInterpolant = f = d._lendControlInterpolant()); d = f.parameterPositions; f = f.sampleValues; d[0] = e; f[0] = b; d[1] = e + a; f[1] = c; return this } }); pe.prototype = Object.assign(Object.create(xa.prototype), { constructor: pe, _bindAction: function (a, b) { var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings; a = a._interpolants; var g = c.uuid, h = this._bindingsByRootAndName, k = h[g]; void 0 === k && (k = {}, h[g] = k); for (h = 0; h !== e; ++h) { var m = d[h], p = m.name, n = k[p]; if (void 0 === n) { n = f[h]; if (void 0 !== n) { null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, g, p)); continue } n = new oe(qa.create(c, p, b && b._propertyBindings[h].binding.parsedPath), m.ValueTypeName, m.getValueSize()); ++n.referenceCount; this._addInactiveBinding(n, g, p) } f[h] = n; a[h].resultBuffer = n.buffer } }, _activateAction: function (a) { if (!this._isActiveAction(a)) { if (null === a._cacheIndex) { var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, d = this._actionsByClip[c]; this._bindAction(a, d && d.knownActions[0]); this._addInactiveAction(a, c, b) } b = a._propertyBindings; c = 0; for (d = b.length; c !== d; ++c) { var e = b[c]; 0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState()) } this._lendAction(a) } }, _deactivateAction: function (a) { if (this._isActiveAction(a)) { for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) { var e = b[c]; 0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e)) } this._takeBackAction(a) } }, _initMemoryManager: function () { this._actions = []; this._nActiveActions = 0; this._actionsByClip = {}; this._bindings = []; this._nActiveBindings = 0; this._bindingsByRootAndName = {}; this._controlInterpolants = []; this._nActiveControlInterpolants = 0; var a = this; this.stats = { actions: { get total() { return a._actions.length }, get inUse() { return a._nActiveActions } }, bindings: { get total() { return a._bindings.length }, get inUse() { return a._nActiveBindings } }, controlInterpolants: { get total() { return a._controlInterpolants.length }, get inUse() { return a._nActiveControlInterpolants } } } }, _isActiveAction: function (a) { a = a._cacheIndex; return null !== a && a < this._nActiveActions }, _addInactiveAction: function (a, b, c) { var d = this._actions, e = this._actionsByClip, f = e[b]; void 0 === f ? (f = { knownActions: [a], actionByRoot: {} }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a)); a._cacheIndex = d.length; d.push(a); f.actionByRoot[c] = a }, _removeInactiveAction: function (a) { var b = this._actions, c = b[b.length - 1], d = a._cacheIndex; c._cacheIndex = d; b[d] = c; b.pop(); a._cacheIndex = null; b = a._clip.uuid; c = this._actionsByClip; d = c[b]; var e = d.knownActions, f = e[e.length - 1], g = a._byClipCacheIndex; f._byClipCacheIndex = g; e[g] = f; e.pop(); a._byClipCacheIndex = null; delete d.actionByRoot[(a._localRoot || this._root).uuid]; 0 === e.length && delete c[b]; this._removeInactiveBindingsForAction(a) }, _removeInactiveBindingsForAction: function (a) { a = a._propertyBindings; for (var b = 0, c = a.length; b !== c; ++b) { var d = a[b]; 0 === --d.referenceCount && this._removeInactiveBinding(d) } }, _lendAction: function (a) { var b = this._actions, c = a._cacheIndex, d = this._nActiveActions++, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _takeBackAction: function (a) { var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _addInactiveBinding: function (a, b, c) { var d = this._bindingsByRootAndName, e = d[b], f = this._bindings; void 0 === e && (e = {}, d[b] = e); e[c] = a; a._cacheIndex = f.length; f.push(a) }, _removeInactiveBinding: function (a) { var b = this._bindings, c = a.binding, d = c.rootNode.uuid; c = c.path; var e = this._bindingsByRootAndName, f = e[d], g = b[b.length - 1]; a = a._cacheIndex; g._cacheIndex = a; b[a] = g; b.pop(); delete f[c]; a: { for (var h in f) break a; delete e[d] } }, _lendBinding: function (a) { var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _takeBackBinding: function (a) { var b = this._bindings, c = a._cacheIndex, d = --this._nActiveBindings, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _lendControlInterpolant: function () { var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b]; void 0 === c && (c = new bd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c); return c }, _takeBackControlInterpolant: function (a) { var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d]; a.__cacheIndex = d; b[d] = a; e.__cacheIndex = c; b[c] = e }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (a, b) { var c = b || this._root, d = c.uuid; c = "string" === typeof a ? Ba.findByName(c, a) : a; a = null !== c ? c.uuid : a; var e = this._actionsByClip[a], f = null; if (void 0 !== e) { f = e.actionByRoot[d]; if (void 0 !== f) return f; f = e.knownActions[0]; null === c && (c = f._clip) } if (null === c) return null; b = new lf(this, c, b); this._bindAction(b, f); this._addInactiveAction(b, a, d); return b }, existingAction: function (a, b) { var c = b || this._root; b = c.uuid; c = "string" === typeof a ? Ba.findByName(c, a) : a; a = this._actionsByClip[c ? c.uuid : a]; return void 0 !== a ? a.actionByRoot[b] || null : null }, stopAllAction: function () { for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e)a[e].reset(); for (e = 0; e !== d; ++e)c[e].useCount = 0; return this }, update: function (a) { a *= this.timeScale; for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g)b[g]._update(d, a, e, f); a = this._bindings; b = this._nActiveBindings; for (g = 0; g !== b; ++g)a[g].apply(f); return this }, getRoot: function () { return this._root }, uncacheClip: function (a) { var b = this._actions; a = a.uuid; var c = this._actionsByClip, d = c[a]; if (void 0 !== d) { d = d.knownActions; for (var e = 0, f = d.length; e !== f; ++e) { var g = d[e]; this._deactivateAction(g); var h = g._cacheIndex, k = b[b.length - 1]; g._cacheIndex = null; g._byClipCacheIndex = null; k._cacheIndex = h; b[h] = k; b.pop(); this._removeInactiveBindingsForAction(g) } delete c[a] } }, uncacheRoot: function (a) { a = a.uuid; var b = this._actionsByClip; for (d in b) { var c = b[d].actionByRoot[a]; void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c)) } var d = this._bindingsByRootAndName[a]; if (void 0 !== d) for (var e in d) a = d[e], a.restoreOriginalState(), this._removeInactiveBinding(a) }, uncacheAction: function (a, b) { a = this.existingAction(a, b); null !== a && (this._deactivateAction(a), this._removeInactiveAction(a)) } }); Nd.prototype.clone = function () { return new Nd(void 0 === this.value.clone ? this.value : this.value.clone()) }; qe.prototype = Object.assign(Object.create(F.prototype), { constructor: qe, isInstancedBufferGeometry: !0, copy: function (a) { F.prototype.copy.call(this, a); this.maxInstancedCount = a.maxInstancedCount; return this }, clone: function () { return (new this.constructor).copy(this) } }); Object.defineProperties(re.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } } }); Object.assign(re.prototype, {
        isInterleavedBufferAttribute: !0, setX: function (a, b) { this.data.array[a * this.data.stride + this.offset] = b; return this }, setY: function (a, b) { this.data.array[a * this.data.stride + this.offset + 1] = b; return this }, setZ: function (a, b) { this.data.array[a * this.data.stride + this.offset + 2] = b; return this }, setW: function (a, b) {
            this.data.array[a * this.data.stride + this.offset +
                3] = b; return this
        }, getX: function (a) { return this.data.array[a * this.data.stride + this.offset] }, getY: function (a) { return this.data.array[a * this.data.stride + this.offset + 1] }, getZ: function (a) { return this.data.array[a * this.data.stride + this.offset + 2] }, getW: function (a) { return this.data.array[a * this.data.stride + this.offset + 3] }, setXY: function (a, b, c) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; return this }, setXYZ: function (a, b, c, d) {
            a = a * this.data.stride + this.offset; this.data.array[a +
                0] = b; this.data.array[a + 1] = c; this.data.array[a + 2] = d; return this
        }, setXYZW: function (a, b, c, d, e) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; this.data.array[a + 2] = d; this.data.array[a + 3] = e; return this }
    }); Object.defineProperty(kc.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++ } }); Object.assign(kc.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setArray: function (a) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.count = void 0 !== a ? a.length / this.stride : 0; this.array = a }, setDynamic: function (a) { this.dynamic = a; return this }, copy: function (a) { this.array = new a.array.constructor(a.array); this.count = a.count; this.stride = a.stride; this.dynamic = a.dynamic; return this }, copyAt: function (a, b, c) { a *= this.stride; c *= b.stride; for (var d = 0, e = this.stride; d < e; d++)this.array[a + d] = b.array[c + d]; return this }, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this }, clone: function () { return (new this.constructor).copy(this) }, onUpload: function (a) { this.onUploadCallback = a; return this } }); se.prototype = Object.assign(Object.create(kc.prototype), { constructor: se, isInstancedInterleavedBuffer: !0, copy: function (a) { kc.prototype.copy.call(this, a); this.meshPerAttribute = a.meshPerAttribute; return this } }); te.prototype = Object.assign(Object.create(T.prototype), { constructor: te, isInstancedBufferAttribute: !0, copy: function (a) { T.prototype.copy.call(this, a); this.meshPerAttribute = a.meshPerAttribute; return this } }); Object.assign(mf.prototype, { linePrecision: 1, set: function (a, b) { this.ray.set(a, b) }, setFromCamera: function (a, b) { b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (a, b, c) { c = c || []; ue(a, this, c, b); c.sort(nf); return c }, intersectObjects: function (a, b, c) { c = c || []; if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c; for (var d = 0, e = a.length; d < e; d++)ue(a[d], this, c, b); c.sort(nf); return c } }); Object.assign(of.prototype, { start: function () { this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now(); this.elapsedTime = 0; this.running = !0 }, stop: function () { this.getElapsedTime(); this.autoStart = this.running = !1 }, getElapsedTime: function () { this.getDelta(); return this.elapsedTime }, getDelta: function () { var a = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var b = ("undefined" === typeof performance ? Date : performance).now(); a = (b - this.oldTime) / 1E3; this.oldTime = b; this.elapsedTime += a } return a } }); Object.assign(pf.prototype, {
        set: function (a, b, c) { this.radius = a; this.phi = b; this.theta = c; return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.radius = a.radius; this.phi = a.phi; this.theta = a.theta; return this }, makeSafe: function () {
            this.phi = Math.max(1E-6, Math.min(Math.PI -
                1E-6, this.phi)); return this
        }, setFromVector3: function (a) { this.radius = a.length(); 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(S.clamp(a.y / this.radius, -1, 1))); return this }
    }); Object.assign(qf.prototype, { set: function (a, b, c) { this.radius = a; this.theta = b; this.y = c; return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.radius = a.radius; this.theta = a.theta; this.y = a.y; return this }, setFromVector3: function (a) { this.radius = Math.sqrt(a.x * a.x + a.z * a.z); this.theta = Math.atan2(a.x, a.z); this.y = a.y; return this } }); Object.assign(ve.prototype, { set: function (a, b) { this.min.copy(a); this.max.copy(b); return this }, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]); return this }, setFromCenterAndSize: function () { var a = new C; return function (b, c) { c = a.copy(c).multiplyScalar(.5); this.min.copy(b).sub(c); this.max.copy(b).add(c); return this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this }, makeEmpty: function () { this.min.x = this.min.y = Infinity; this.max.x = this.max.y = -Infinity; return this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (a) { void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new C); return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (a) { void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new C); return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min) }, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this }, expandByScalar: function (a) { this.min.addScalar(-a); this.max.addScalar(a); return this }, containsPoint: function (a) { return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0 }, containsBox: function (a) { return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y }, getParameter: function (a, b) { void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new C); return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (a) { return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0 }, clampPoint: function (a, b) { void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new C); return b.copy(a).clamp(this.min, this.max) }, distanceToPoint: function () { var a = new C; return function (b) { return a.copy(b).clamp(this.min, this.max).sub(b).length() } }(), intersect: function (a) { this.min.max(a.min); this.max.min(a.max); return this }, union: function (a) { this.min.min(a.min); this.max.max(a.max); return this }, translate: function (a) { this.min.add(a); this.max.add(a); return this }, equals: function (a) { return a.min.equals(this.min) && a.max.equals(this.max) } }); dd.prototype = Object.create(A.prototype); dd.prototype.constructor = dd; dd.prototype.isImmediateRenderObject = !0; ed.prototype = Object.create(aa.prototype); ed.prototype.constructor = ed; ed.prototype.update = function () { var a = new p, b = new p, c = new sa; return function () { var d = ["a", "b", "c"]; this.object.updateMatrixWorld(!0); c.getNormalMatrix(this.object.matrixWorld); var e = this.object.matrixWorld, f = this.geometry.attributes.position, g = this.object.geometry; if (g && g.isGeometry) for (var h = g.vertices, k = g.faces, m = g = 0, p = k.length; m < p; m++)for (var n = k[m], t = 0, r = n.vertexNormals.length; t < r; t++) { var q = n.vertexNormals[t]; a.copy(h[n[d[t]]]).applyMatrix4(e); b.copy(q).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a); f.setXYZ(g, a.x, a.y, a.z); g += 1; f.setXYZ(g, b.x, b.y, b.z); g += 1 } else if (g && g.isBufferGeometry) for (d = g.attributes.position, h = g.attributes.normal, t = g = 0, r = d.count; t < r; t++)a.set(d.getX(t), d.getY(t), d.getZ(t)).applyMatrix4(e), b.set(h.getX(t), h.getY(t), h.getZ(t)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1; f.needsUpdate = !0 } }(); lc.prototype = Object.create(A.prototype); lc.prototype.constructor = lc; lc.prototype.dispose = function () { this.cone.geometry.dispose(); this.cone.material.dispose() }; lc.prototype.update = function () { var a = new p, b = new p; return function () { this.light.updateMatrixWorld(); var c = this.light.distance ? this.light.distance : 1E3, d = c * Math.tan(this.light.angle); this.cone.scale.set(d, d, c); a.setFromMatrixPosition(this.light.matrixWorld); b.setFromMatrixPosition(this.light.target.matrixWorld); this.cone.lookAt(b.sub(a)); void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }(); mc.prototype = Object.create(aa.prototype); mc.prototype.constructor = mc; mc.prototype.updateMatrixWorld = function () { var a = new p, b = new M, c = new M; return function (d) { var e = this.bones, f = this.geometry, g = f.getAttribute("position"); c.getInverse(this.root.matrixWorld); for (var h = 0, k = 0; h < e.length; h++) { var m = e[h]; m.parent && m.parent.isBone && (b.multiplyMatrices(c, m.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k, a.x, a.y, a.z), b.multiplyMatrices(c, m.parent.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k + 1, a.x, a.y, a.z), k += 2) } f.getAttribute("position").needsUpdate = !0; A.prototype.updateMatrixWorld.call(this, d) } }(); nc.prototype = Object.create(oa.prototype); nc.prototype.constructor = nc; nc.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose() }; nc.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }; oc.prototype = Object.create(A.prototype); oc.prototype.constructor = oc; oc.prototype.dispose = function () { this.children[0].geometry.dispose(); this.children[0].material.dispose() }; oc.prototype.update = function () { var a = .5 * this.light.width, b = .5 * this.light.height, c = this.line.geometry.attributes.position, d = c.array; d[0] = a; d[1] = -b; d[2] = 0; d[3] = a; d[4] = b; d[5] = 0; d[6] = -a; d[7] = b; d[8] = 0; d[9] = -a; d[10] = -b; d[11] = 0; d[12] = a; d[13] = -b; d[14] = 0; c.needsUpdate = !0; void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color) }; pc.prototype = Object.create(A.prototype); pc.prototype.constructor = pc; pc.prototype.dispose = function () { this.children[0].geometry.dispose(); this.children[0].material.dispose() }; pc.prototype.update = function () { var a = new p, b = new I, c = new I; return function () { var d = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { var e = d.geometry.getAttribute("color"); b.copy(this.light.color); c.copy(this.light.groundColor); for (var f = 0, g = e.count; f < g; f++) { var h = f < g / 2 ? b : c; e.setXYZ(f, h.r, h.g, h.b) } e.needsUpdate = !0 } d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()) } }(); fd.prototype = Object.create(aa.prototype); fd.prototype.constructor = fd; Od.prototype = Object.create(aa.prototype); Od.prototype.constructor = Od; gd.prototype = Object.create(aa.prototype); gd.prototype.constructor = gd; gd.prototype.update = function () { var a = new p, b = new p, c = new sa; return function () { this.object.updateMatrixWorld(!0); c.getNormalMatrix(this.object.matrixWorld); var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices; f = f.faces; for (var h = 0, k = 0, m = f.length; k < m; k++) { var p = f[k], n = p.normal; a.copy(g[p.a]).add(g[p.b]).add(g[p.c]).divideScalar(3).applyMatrix4(d); b.copy(n).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a); e.setXYZ(h, a.x, a.y, a.z); h += 1; e.setXYZ(h, b.x, b.y, b.z); h += 1 } e.needsUpdate = !0 } }(); qc.prototype = Object.create(A.prototype); qc.prototype.constructor = qc; qc.prototype.dispose = function () { this.lightPlane.geometry.dispose(); this.lightPlane.material.dispose(); this.targetLine.geometry.dispose(); this.targetLine.material.dispose() }; qc.prototype.update = function () { var a = new p, b = new p, c = new p; return function () { a.setFromMatrixPosition(this.light.matrixWorld); b.setFromMatrixPosition(this.light.target.matrixWorld); c.subVectors(b, a); this.lightPlane.lookAt(c); void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)); this.targetLine.lookAt(c); this.targetLine.scale.z = c.length() } }(); hd.prototype = Object.create(aa.prototype); hd.prototype.constructor = hd; hd.prototype.update = function () { function a(a, g, h, k) { d.set(g, h, k).unproject(e); a = c[a]; if (void 0 !== a) for (g = b.getAttribute("position"), h = 0, k = a.length; h < k; h++)g.setXYZ(a[h], d.x, d.y, d.z) } var b, c, d = new p, e = new Qa; return function () { b = this.geometry; c = this.pointMap; e.projectionMatrix.copy(this.camera.projectionMatrix); a("c", 0, 0, -1); a("t", 0, 0, 1); a("n1", -1, -1, -1); a("n2", 1, -1, -1); a("n3", -1, 1, -1); a("n4", 1, 1, -1); a("f1", -1, -1, 1); a("f2", 1, -1, 1); a("f3", -1, 1, 1); a("f4", 1, 1, 1); a("u1", .7, 1.1, -1); a("u2", -.7, 1.1, -1); a("u3", 0, 2, -1); a("cf1", -1, 0, 1); a("cf2", 1, 0, 1); a("cf3", 0, -1, 1); a("cf4", 0, 1, 1); a("cn1", -1, 0, -1); a("cn2", 1, 0, -1); a("cn3", 0, -1, -1); a("cn4", 0, 1, -1); b.getAttribute("position").needsUpdate = !0 } }(); Fb.prototype = Object.create(aa.prototype); Fb.prototype.constructor = Fb; Fb.prototype.update = function () { var a = new Va; return function (b) { void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments."); void 0 !== this.object && a.setFromObject(this.object); if (!a.isEmpty()) { b = a.min; var c = a.max, d = this.geometry.attributes.position, e = d.array; e[0] = c.x; e[1] = c.y; e[2] = c.z; e[3] = b.x; e[4] = c.y; e[5] = c.z; e[6] = b.x; e[7] = b.y; e[8] = c.z; e[9] = c.x; e[10] = b.y; e[11] = c.z; e[12] = c.x; e[13] = c.y; e[14] = b.z; e[15] = b.x; e[16] = c.y; e[17] = b.z; e[18] = b.x; e[19] = b.y; e[20] = b.z; e[21] = c.x; e[22] = b.y; e[23] = b.z; d.needsUpdate = !0; this.geometry.computeBoundingSphere() } } }(); Fb.prototype.setFromObject = function (a) { this.object = a; this.update(); return this }; id.prototype = Object.create(aa.prototype); id.prototype.constructor = id; id.prototype.updateMatrixWorld = function (a) { var b = this.box; b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), A.prototype.updateMatrixWorld.call(this, a)) }; jd.prototype = Object.create(ua.prototype); jd.prototype.constructor = jd; jd.prototype.updateMatrixWorld = function (a) { var b = -this.plane.constant; 1E-8 > Math.abs(b) && (b = 1E-8); this.scale.set(.5 * this.size, .5 * this.size, b); this.lookAt(this.plane.normal); A.prototype.updateMatrixWorld.call(this, a) }; var Pd, we; Gb.prototype = Object.create(A.prototype); Gb.prototype.constructor = Gb; Gb.prototype.setDirection = function () { var a = new p, b; return function (c) { .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b)) } }(); Gb.prototype.setLength = function (a, b, c) { void 0 === b && (b = .2 * a); void 0 === c && (c = .2 * b); this.line.scale.set(1, Math.max(0, a - b), 1); this.line.updateMatrix(); this.cone.scale.set(c, b, c); this.cone.position.y = a; this.cone.updateMatrix() }; Gb.prototype.setColor = function (a) { this.line.material.color.copy(a); this.cone.material.color.copy(a) }; kd.prototype = Object.create(aa.prototype); kd.prototype.constructor = kd; E.create = function (a, b) { console.log("THREE.Curve.create() has been deprecated"); a.prototype = Object.create(E.prototype); a.prototype.constructor = a; a.prototype.getPoint = b; return a }; Object.assign(Za.prototype, { createPointsGeometry: function (a) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); a = this.getPoints(a); return this.createGeometry(a) }, createSpacedPointsGeometry: function (a) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); a = this.getSpacedPoints(a); return this.createGeometry(a) }, createGeometry: function (a) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var b = new N, c = 0, d = a.length; c < d; c++) { var e = a[c]; b.vertices.push(new p(e.x, e.y, e.z || 0)) } return b } }); Object.assign(Pa.prototype, { fromPoints: function (a) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."); this.setFromPoints(a) } }); sf.prototype = Object.create(X.prototype); tf.prototype = Object.create(X.prototype); xe.prototype = Object.create(X.prototype); Object.assign(xe.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }); fd.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }; mc.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }; Object.assign(ic.prototype, { extractUrlBase: function (a) { console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."); return Be.extractUrlBase(a) } }); Object.assign(ve.prototype, { center: function (a) { console.warn("THREE.Box2: .center() has been renamed to .getCenter()."); return this.getCenter(a) }, empty: function () { console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."); return this.isEmpty() }, isIntersectionBox: function (a) { console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a) }, size: function (a) { console.warn("THREE.Box2: .size() has been renamed to .getSize()."); return this.getSize(a) } }); Object.assign(Va.prototype, { center: function (a) { console.warn("THREE.Box3: .center() has been renamed to .getCenter()."); return this.getCenter(a) }, empty: function () { console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."); return this.isEmpty() }, isIntersectionBox: function (a) { console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a) }, isIntersectionSphere: function (a) { console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."); return this.intersectsSphere(a) }, size: function (a) { console.warn("THREE.Box3: .size() has been renamed to .getSize()."); return this.getSize(a) } }); Lb.prototype.center = function (a) { console.warn("THREE.Line3: .center() has been renamed to .getCenter()."); return this.getCenter(a) }; Object.assign(S, { random16: function () { console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."); return Math.random() }, nearestPowerOfTwo: function (a) { console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."); return S.floorPowerOfTwo(a) }, nextPowerOfTwo: function (a) { console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."); return S.ceilPowerOfTwo(a) } }); Object.assign(sa.prototype, { flattenToArrayOffset: function (a, b) { console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."); return this.toArray(a, b) }, multiplyVector3: function (a) { console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."); return a.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function (a) { console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."); return this.applyToBufferAttribute(a) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }); Object.assign(M.prototype, { extractPosition: function (a) { console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."); return this.copyPosition(a) }, flattenToArrayOffset: function (a, b) { console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."); return this.toArray(a, b) }, getPosition: function () { var a; return function () { void 0 === a && (a = new p); console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."); return a.setFromMatrixColumn(this, 3) } }(), setRotationFromQuaternion: function (a) { console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."); return this.makeRotationFromQuaternion(a) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (a) { console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this) }, multiplyVector4: function (a) { console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (a) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."); a.transformDirection(this) }, crossVector: function (a) { console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function (a) { console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."); return this.applyToBufferAttribute(a) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (a, b, c, d, e, f) { console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."); return this.makePerspective(a, b, d, c, e, f) } }); Fa.prototype.isIntersectionLine = function (a) { console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."); return this.intersectsLine(a) }; ja.prototype.multiplyVector3 = function (a) { console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."); return a.applyQuaternion(this) }; Object.assign(qb.prototype, { isIntersectionBox: function (a) { console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a) }, isIntersectionPlane: function (a) { console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."); return this.intersectsPlane(a) }, isIntersectionSphere: function (a) { console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."); return this.intersectsSphere(a) } }); Object.assign(Aa.prototype, { area: function () { console.warn("THREE.Triangle: .area() has been renamed to .getArea()."); return this.getArea() }, barycoordFromPoint: function (a, b) { console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."); return this.getBarycoord(a, b) }, midpoint: function (a) { console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."); return this.getMidpoint(a) }, normal: function (a) { console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."); return this.getNormal(a) }, plane: function (a) { console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."); return this.getPlane(a) } }); Object.assign(Aa, { barycoordFromPoint: function (a, b, c, d, e) { console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."); return Aa.getBarycoord(a, b, c, d, e) }, normal: function (a, b, c, d) { console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."); return Aa.getNormal(a, b, c, d) } }); Object.assign(gb.prototype, { extractAllPoints: function (a) { console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."); return this.extractPoints(a) }, extrude: function (a) { console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."); return new fb(this, a) }, makeGeometry: function (a) { console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."); return new vb(this, a) } }); Object.assign(C.prototype, { fromAttribute: function (a, b, c) { console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c) }, distanceToManhattan: function (a) { console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."); return this.manhattanDistanceTo(a) }, lengthManhattan: function () { console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength() } }); Object.assign(p.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (a) { console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."); return this.setFromMatrixPosition(a) }, getScaleFromMatrix: function (a) { console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."); return this.setFromMatrixScale(a) }, getColumnFromMatrix: function (a, b) { console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."); return this.setFromMatrixColumn(b, a) }, applyProjection: function (a) { console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."); return this.applyMatrix4(a) }, fromAttribute: function (a, b, c) { console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c) }, distanceToManhattan: function (a) { console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."); return this.manhattanDistanceTo(a) }, lengthManhattan: function () { console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength() } }); Object.assign(ea.prototype, { fromAttribute: function (a, b, c) { console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c) }, lengthManhattan: function () { console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength() } }); Object.assign(N.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }); Object.assign(A.prototype, { getChildByName: function (a) { console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."); return this.getObjectByName(a) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (a, b) { console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."); return this.translateOnAxis(b, a) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }); Object.defineProperties(A.prototype, { eulerOrder: { get: function () { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."); return this.rotation.order }, set: function (a) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."); this.rotation.order = a } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }); Object.defineProperties(Bc.prototype, { objects: { get: function () { console.warn("THREE.LOD: .objects has been renamed to .levels."); return this.levels } } }); Object.defineProperty(Cc.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }); Object.defineProperty(E.prototype, "__arcLengthDivisions", { get: function () { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."); return this.arcLengthDivisions }, set: function (a) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."); this.arcLengthDivisions = a } }); la.prototype.setLens = function (a, b) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."); void 0 !== b && (this.filmGauge = b); this.setFocalLength(a) }; Object.defineProperties(ca.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (a) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."); this.shadow.camera.fov = a } }, shadowCameraLeft: { set: function (a) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."); this.shadow.camera.left = a } }, shadowCameraRight: { set: function (a) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."); this.shadow.camera.right = a } }, shadowCameraTop: { set: function (a) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."); this.shadow.camera.top = a } }, shadowCameraBottom: { set: function (a) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."); this.shadow.camera.bottom = a } }, shadowCameraNear: { set: function (a) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."); this.shadow.camera.near = a } }, shadowCameraFar: { set: function (a) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."); this.shadow.camera.far = a } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (a) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."); this.shadow.bias = a } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (a) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."); this.shadow.mapSize.width = a } }, shadowMapHeight: { set: function (a) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."); this.shadow.mapSize.height = a } } }); Object.defineProperties(T.prototype, { length: { get: function () { console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."); return this.array.length } }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") } }); Object.assign(F.prototype, { addIndex: function (a) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."); this.setIndex(a) }, addDrawCall: function (a, b, c) { void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."); console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."); this.addGroup(a, b) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."); this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }); Object.defineProperties(F.prototype, { drawcalls: { get: function () { console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."); return this.groups } }, offsets: { get: function () { console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."); return this.groups } } }); Object.defineProperties(Nd.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."); return this } } }); Object.defineProperties(O.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, wrapRGB: { get: function () { console.warn("THREE.Material: .wrapRGB has been removed."); return new I } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (a) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."); this.flatShading = 1 === a } } }); Object.defineProperties(Ja.prototype, { metal: { get: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."); return !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }); Object.defineProperties(va.prototype, { derivatives: { get: function () { console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."); return this.extensions.derivatives }, set: function (a) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."); this.extensions.derivatives = a } } }); Object.assign(Xd.prototype, { getCurrentRenderTarget: function () { console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."); return this.getRenderTarget() }, getMaxAnisotropy: function () { console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."); return this.capabilities.getMaxAnisotropy() }, getPrecision: function () { console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."); return this.capabilities.precision }, resetGLState: function () { console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."); return this.state.reset() }, supportsFloatTextures: function () { console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."); return this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."); return this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."); return this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."); return this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."); return this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."); return this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."); return this.capabilities.vertexTextures }, supportsInstancedArrays: function () { console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."); return this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (a) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."); this.setScissorTest(a) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") } }); Object.defineProperties(Xd.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (a) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."); this.shadowMap.enabled = a } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (a) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."); this.shadowMap.type = a } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } } }); Object.defineProperties(Ue.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }); Object.defineProperties(hb.prototype, { wrapS: { get: function () { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."); return this.texture.wrapS }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."); this.texture.wrapS = a } }, wrapT: { get: function () { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."); return this.texture.wrapT }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."); this.texture.wrapT = a } }, magFilter: { get: function () { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."); return this.texture.magFilter }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."); this.texture.magFilter = a } }, minFilter: { get: function () { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."); return this.texture.minFilter }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."); this.texture.minFilter = a } }, anisotropy: { get: function () { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."); return this.texture.anisotropy }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."); this.texture.anisotropy = a } }, offset: { get: function () { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."); return this.texture.offset }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."); this.texture.offset = a } }, repeat: { get: function () { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."); return this.texture.repeat }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."); this.texture.repeat = a } }, format: { get: function () { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."); return this.texture.format }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."); this.texture.format = a } }, type: { get: function () { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."); return this.texture.type }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."); this.texture.type = a } }, generateMipmaps: { get: function () { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."); return this.texture.generateMipmaps }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."); this.texture.generateMipmaps = a } } }); Object.defineProperties(We.prototype, { standing: { set: function () { console.warn("THREE.WebVRManager: .standing has been removed.") } } }); jc.prototype.load = function (a) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var b = this; (new je).load(a, function (a) { b.setBuffer(a) }); return this }; ne.prototype.getData = function () { console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."); return this.getFrequencyData() }; cd.prototype.updateCubeMap = function (a, b) { console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."); return this.update(a, b) }; k.WebGLRenderTargetCube = Ib; k.WebGLRenderTarget = hb; k.WebGLRenderer = Xd; k.ShaderLib = rb; k.UniformsLib = L; k.UniformsUtils = Da; k.ShaderChunk = V; k.FogExp2 = Ob; k.Fog = Pb; k.Scene = rd; k.Sprite = Ac; k.LOD = Bc; k.SkinnedMesh = td; k.Skeleton = Cc; k.Bone = sd; k.Mesh = oa; k.LineSegments = aa; k.LineLoop = ud; k.Line = ua; k.Points = Qb; k.Group = vd; k.VideoTexture = Yd; k.DataTexture = ib; k.CompressedTexture = Rb; k.CubeTexture = ab; k.CanvasTexture = zc; k.DepthTexture = Dc; k.Texture = Y; k.CompressedTextureLoader = df; k.DataTextureLoader = be; k.CubeTextureLoader = ce; k.TextureLoader = xd; k.ObjectLoader = ff; k.MaterialLoader = Md; k.BufferGeometryLoader = ee; k.DefaultLoadingManager = ma; k.LoadingManager = ae; k.JSONLoader = fe; k.ImageLoader = Yc; k.ImageBitmapLoader = ge; k.FontLoader = gf; k.FileLoader = Ka; k.Loader = ic; k.LoaderUtils = Be; k.Cache = Hb; k.AudioLoader = je; k.SpotLightShadow = zd; k.SpotLight = Ad; k.PointLight = Bd; k.RectAreaLight = Fd; k.HemisphereLight = yd; k.DirectionalLightShadow = Cd; k.DirectionalLight = Dd; k.AmbientLight = Ed; k.LightShadow = Eb; k.Light = ca; k.StereoCamera = hf; k.PerspectiveCamera = la; k.OrthographicCamera = Jb; k.CubeCamera = cd; k.ArrayCamera = qd; k.Camera = Qa; k.AudioListener = ke; k.PositionalAudio = me; k.AudioContext = le; k.AudioAnalyser = ne; k.Audio = jc; k.VectorKeyframeTrack = hc; k.StringKeyframeTrack = Gd; k.QuaternionKeyframeTrack = ad; k.NumberKeyframeTrack = gc; k.ColorKeyframeTrack = Jd; k.BooleanKeyframeTrack = Hd; k.PropertyMixer = oe; k.PropertyBinding = qa; k.KeyframeTrack = da; k.AnimationUtils = fa; k.AnimationObjectGroup = kf; k.AnimationMixer = pe; k.AnimationClip = Ba; k.Uniform = Nd; k.InstancedBufferGeometry = qe; k.BufferGeometry = F; k.Geometry = N; k.InterleavedBufferAttribute = re; k.InstancedInterleavedBuffer = se; k.InterleavedBuffer = kc; k.InstancedBufferAttribute = te; k.Face3 = Wa; k.Object3D = A; k.Raycaster = mf; k.Layers = Sd; k.EventDispatcher = xa; k.Clock = of; k.QuaternionLinearInterpolant = Id; k.LinearInterpolant = bd; k.DiscreteInterpolant = Ld; k.CubicInterpolant = Kd; k.Interpolant = na; k.Triangle = Aa; k.Math = S; k.Spherical = pf; k.Cylindrical = qf; k.Plane = Fa; k.Frustum = ld; k.Sphere = Ea; k.Ray = qb; k.Matrix4 = M; k.Matrix3 = sa; k.Box3 = Va; k.Box2 = ve; k.Line3 = Lb; k.Euler = jb; k.Vector4 = ea; k.Vector3 = p; k.Vector2 = C; k.Quaternion = ja; k.Color = I; k.ImmediateRenderObject = dd; k.VertexNormalsHelper = ed; k.SpotLightHelper = lc; k.SkeletonHelper = mc; k.PointLightHelper = nc; k.RectAreaLightHelper = oc; k.HemisphereLightHelper = pc; k.GridHelper = fd; k.PolarGridHelper = Od; k.FaceNormalsHelper = gd; k.DirectionalLightHelper = qc; k.CameraHelper = hd; k.BoxHelper = Fb; k.Box3Helper = id; k.PlaneHelper = jd; k.ArrowHelper = Gb; k.AxesHelper = kd; k.Shape = gb; k.Path = Pa; k.ShapePath = he; k.Font = ie; k.CurvePath = Za; k.Curve = E; k.ShapeUtils = Xa; k.WebGLUtils = Ve; k.WireframeGeometry = Sb; k.ParametricGeometry = Ec; k.ParametricBufferGeometry = Tb; k.TetrahedronGeometry = Gc; k.TetrahedronBufferGeometry = Ub; k.OctahedronGeometry = Hc; k.OctahedronBufferGeometry = sb; k.IcosahedronGeometry = Ic; k.IcosahedronBufferGeometry = Vb; k.DodecahedronGeometry = Jc; k.DodecahedronBufferGeometry = Wb; k.PolyhedronGeometry = Fc; k.PolyhedronBufferGeometry = pa; k.TubeGeometry = Kc; k.TubeBufferGeometry = Xb; k.TorusKnotGeometry = Lc; k.TorusKnotBufferGeometry = Yb; k.TorusGeometry = Mc; k.TorusBufferGeometry = Zb; k.TextGeometry = Rc; k.TextBufferGeometry = $b; k.SphereGeometry = Sc; k.SphereBufferGeometry = ub; k.RingGeometry = Tc; k.RingBufferGeometry = ac; k.PlaneGeometry = xc; k.PlaneBufferGeometry = pb; k.LatheGeometry = Uc; k.LatheBufferGeometry = bc; k.ShapeGeometry = vb; k.ShapeBufferGeometry = wb; k.ExtrudeGeometry = fb; k.ExtrudeBufferGeometry = Ia; k.EdgesGeometry = cc; k.ConeGeometry = Vc; k.ConeBufferGeometry = Wc; k.CylinderGeometry = xb; k.CylinderBufferGeometry = Ya; k.CircleGeometry = Xc; k.CircleBufferGeometry = dc; k.BoxGeometry = Kb; k.BoxBufferGeometry = mb; k.ShadowMaterial = yb; k.SpriteMaterial = eb; k.RawShaderMaterial = ec; k.ShaderMaterial = va; k.PointsMaterial = Ha; k.MeshPhysicalMaterial = zb; k.MeshStandardMaterial = Sa; k.MeshPhongMaterial = Ja; k.MeshToonMaterial = Ab; k.MeshNormalMaterial = Bb; k.MeshLambertMaterial = Cb; k.MeshDepthMaterial = cb; k.MeshDistanceMaterial = db; k.MeshBasicMaterial = za; k.LineDashedMaterial = Db; k.LineBasicMaterial = U; k.Material = O; k.Float64BufferAttribute = wc; k.Float32BufferAttribute = z; k.Uint32BufferAttribute = lb; k.Int32BufferAttribute = vc; k.Uint16BufferAttribute = kb; k.Int16BufferAttribute = uc; k.Uint8ClampedBufferAttribute = tc; k.Uint8BufferAttribute = sc; k.Int8BufferAttribute = rc; k.BufferAttribute = T; k.ArcCurve = fc; k.CatmullRomCurve3 = X; k.CubicBezierCurve = La; k.CubicBezierCurve3 = Ta; k.EllipseCurve = ia; k.LineCurve = wa; k.LineCurve3 = Ma; k.QuadraticBezierCurve = Na; k.QuadraticBezierCurve3 = Ua; k.SplineCurve = Oa; k.REVISION = "91"; k.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; k.CullFaceNone = 0; k.CullFaceBack = 1; k.CullFaceFront = 2; k.CullFaceFrontBack = 3; k.FrontFaceDirectionCW = 0; k.FrontFaceDirectionCCW = 1; k.BasicShadowMap = 0; k.PCFShadowMap = 1; k.PCFSoftShadowMap = 2; k.FrontSide = 0; k.BackSide = 1; k.DoubleSide = 2; k.FlatShading = 1; k.SmoothShading = 2; k.NoColors = 0; k.FaceColors = 1; k.VertexColors = 2; k.NoBlending = 0; k.NormalBlending = 1; k.AdditiveBlending = 2; k.SubtractiveBlending = 3; k.MultiplyBlending = 4; k.CustomBlending = 5; k.AddEquation = 100; k.SubtractEquation = 101; k.ReverseSubtractEquation = 102; k.MinEquation = 103; k.MaxEquation = 104; k.ZeroFactor = 200; k.OneFactor = 201; k.SrcColorFactor = 202; k.OneMinusSrcColorFactor = 203; k.SrcAlphaFactor = 204; k.OneMinusSrcAlphaFactor = 205; k.DstAlphaFactor = 206; k.OneMinusDstAlphaFactor = 207; k.DstColorFactor = 208; k.OneMinusDstColorFactor = 209; k.SrcAlphaSaturateFactor = 210; k.NeverDepth = 0; k.AlwaysDepth = 1; k.LessDepth = 2; k.LessEqualDepth = 3; k.EqualDepth = 4; k.GreaterEqualDepth = 5; k.GreaterDepth = 6; k.NotEqualDepth = 7; k.MultiplyOperation = 0; k.MixOperation = 1; k.AddOperation = 2; k.NoToneMapping = 0; k.LinearToneMapping = 1; k.ReinhardToneMapping = 2; k.Uncharted2ToneMapping = 3; k.CineonToneMapping = 4; k.UVMapping = 300; k.CubeReflectionMapping = 301; k.CubeRefractionMapping = 302; k.EquirectangularReflectionMapping = 303; k.EquirectangularRefractionMapping = 304; k.SphericalReflectionMapping = 305; k.CubeUVReflectionMapping = 306; k.CubeUVRefractionMapping = 307; k.RepeatWrapping = 1E3; k.ClampToEdgeWrapping = 1001; k.MirroredRepeatWrapping = 1002; k.NearestFilter = 1003; k.NearestMipMapNearestFilter = 1004; k.NearestMipMapLinearFilter = 1005; k.LinearFilter = 1006; k.LinearMipMapNearestFilter = 1007; k.LinearMipMapLinearFilter = 1008; k.UnsignedByteType = 1009; k.ByteType = 1010; k.ShortType = 1011; k.UnsignedShortType = 1012; k.IntType = 1013; k.UnsignedIntType = 1014; k.FloatType = 1015; k.HalfFloatType = 1016; k.UnsignedShort4444Type = 1017; k.UnsignedShort5551Type = 1018; k.UnsignedShort565Type = 1019; k.UnsignedInt248Type = 1020; k.AlphaFormat = 1021; k.RGBFormat = 1022; k.RGBAFormat = 1023; k.LuminanceFormat = 1024; k.LuminanceAlphaFormat = 1025; k.RGBEFormat = 1023; k.DepthFormat = 1026; k.DepthStencilFormat = 1027; k.RGB_S3TC_DXT1_Format = 33776; k.RGBA_S3TC_DXT1_Format = 33777; k.RGBA_S3TC_DXT3_Format = 33778; k.RGBA_S3TC_DXT5_Format = 33779; k.RGB_PVRTC_4BPPV1_Format = 35840; k.RGB_PVRTC_2BPPV1_Format = 35841; k.RGBA_PVRTC_4BPPV1_Format = 35842; k.RGBA_PVRTC_2BPPV1_Format = 35843; k.RGB_ETC1_Format = 36196; k.RGBA_ASTC_4x4_Format = 37808; k.RGBA_ASTC_5x4_Format = 37809; k.RGBA_ASTC_5x5_Format = 37810; k.RGBA_ASTC_6x5_Format = 37811; k.RGBA_ASTC_6x6_Format = 37812; k.RGBA_ASTC_8x5_Format = 37813; k.RGBA_ASTC_8x6_Format = 37814; k.RGBA_ASTC_8x8_Format = 37815; k.RGBA_ASTC_10x5_Format = 37816; k.RGBA_ASTC_10x6_Format = 37817; k.RGBA_ASTC_10x8_Format = 37818; k.RGBA_ASTC_10x10_Format = 37819; k.RGBA_ASTC_12x10_Format = 37820; k.RGBA_ASTC_12x12_Format = 37821; k.LoopOnce = 2200; k.LoopRepeat = 2201; k.LoopPingPong = 2202; k.InterpolateDiscrete = 2300; k.InterpolateLinear = 2301; k.InterpolateSmooth = 2302; k.ZeroCurvatureEnding = 2400; k.ZeroSlopeEnding = 2401; k.WrapAroundEnding = 2402; k.TrianglesDrawMode = 0; k.TriangleStripDrawMode = 1; k.TriangleFanDrawMode = 2; k.LinearEncoding = 3E3; k.sRGBEncoding = 3001; k.GammaEncoding = 3007; k.RGBEEncoding = 3002; k.LogLuvEncoding = 3003; k.RGBM7Encoding = 3004; k.RGBM16Encoding = 3005; k.RGBDEncoding = 3006; k.BasicDepthPacking = 3200; k.RGBADepthPacking = 3201; k.CubeGeometry = Kb; k.Face4 = function (a, b, c, d, e, f, g) { console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."); return new Wa(a, b, c, e, f, g) }; k.LineStrip = 0; k.LinePieces = 1; k.MeshFaceMaterial = function (a) { console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."); return a }; k.MultiMaterial = function (a) { void 0 === a && (a = []); console.warn("THREE.MultiMaterial has been removed. Use an Array instead."); a.isMultiMaterial = !0; a.materials = a; a.clone = function () { return a.slice() }; return a }; k.PointCloud = function (a, b) { console.warn("THREE.PointCloud has been renamed to THREE.Points."); return new Qb(a, b) }; k.Particle = function (a) { console.warn("THREE.Particle has been renamed to THREE.Sprite."); return new Ac(a) }; k.ParticleSystem = function (a, b) { console.warn("THREE.ParticleSystem has been renamed to THREE.Points."); return new Qb(a, b) }; k.PointCloudMaterial = function (a) { console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."); return new Ha(a) }; k.ParticleBasicMaterial = function (a) { console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."); return new Ha(a) }; k.ParticleSystemMaterial = function (a) { console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."); return new Ha(a) }; k.Vertex = function (a, b, c) { console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."); return new p(a, b, c) }; k.DynamicBufferAttribute = function (a, b) { console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."); return (new T(a, b)).setDynamic(!0) }; k.Int8Attribute = function (a, b) { console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."); return new rc(a, b) }; k.Uint8Attribute = function (a, b) { console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."); return new sc(a, b) }; k.Uint8ClampedAttribute = function (a, b) { console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."); return new tc(a, b) }; k.Int16Attribute = function (a, b) { console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."); return new uc(a, b) }; k.Uint16Attribute = function (a, b) { console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."); return new kb(a, b) }; k.Int32Attribute = function (a, b) { console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."); return new vc(a, b) }; k.Uint32Attribute = function (a, b) { console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."); return new lb(a, b) }; k.Float32Attribute = function (a, b) { console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."); return new z(a, b) }; k.Float64Attribute = function (a, b) { console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."); return new wc(a, b) }; k.ClosedSplineCurve3 = sf; k.SplineCurve3 = tf; k.Spline = xe; k.AxisHelper = function (a) { console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."); return new kd(a) }; k.BoundingBoxHelper = function (a, b) { console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."); return new Fb(a, b) }; k.EdgesHelper = function (a, b) { console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."); return new aa(new cc(a.geometry), new U({ color: void 0 !== b ? b : 16777215 })) }; k.WireframeHelper = function (a, b) { console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."); return new aa(new Sb(a.geometry), new U({ color: void 0 !== b ? b : 16777215 })) }; k.XHRLoader = function (a) { console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."); return new Ka(a) }; k.BinaryTextureLoader = function (a) { console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."); return new be(a) }; k.GeometryUtils = { merge: function (a, b, c) { console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."); if (b.isMesh) { b.matrixAutoUpdate && b.updateMatrix(); var d = b.matrix; b = b.geometry } a.merge(b, d, c) }, center: function (a) { console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."); return a.center() } }; k.ImageUtils = { crossOrigin: void 0, loadTexture: function (a, b, c, d) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var e = new xd; e.setCrossOrigin(this.crossOrigin); a = e.load(a, c, void 0, d); b && (a.mapping = b); return a }, loadTextureCube: function (a, b, c, d) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var e = new ce; e.setCrossOrigin(this.crossOrigin); a = e.load(a, c, void 0, d); b && (a.mapping = b); return a }, loadCompressedTexture: function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, loadCompressedTextureCube: function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") } }; k.Projector = function () { console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."); this.projectVector = function (a, b) { console.warn("THREE.Projector: .projectVector() is now vector.project()."); a.project(b) }; this.unprojectVector = function (a, b) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."); a.unproject(b) }; this.pickingRay = function () { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") } }; k.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"); this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); this.clear = function () { }; this.render = function () { }; this.setClearColor = function () { }; this.setSize = function () { } }; k.SceneUtils = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") } }; k.LensFlare = function () { console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js") }; Object.defineProperty(k, "__esModule", { value: !0 })
});/*!
* VERSION: 1.20.4
* DATE: 2018-02-15
* UPDATES AND DOCS AT: http://greensock.com
*
* Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
*
* @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
* This work is subject to the terms at http://greensock.com/standard-license or for
* Club GreenSock members, the software agreement that was issued with your membership.
*
* @author: Jack Doyle, jack@greensock.com
**/var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window; (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () { "use strict"; _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (a, b, c) { var d = function (a) { var b, c = [], d = a.length; for (b = 0; b !== d; c.push(a[b++])); return c }, e = function (a, b, c) { var d, e, f = a.cycle; for (d in f) e = f[d], a[d] = "function" == typeof e ? e(c, b[c]) : e[c % e.length]; delete a.cycle }, f = function (a, b, d) { c.call(this, a, b, d), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = f.prototype.render }, g = 1e-10, h = c._internals, i = h.isSelector, j = h.isArray, k = f.prototype = c.to({}, .1, {}), l = []; f.version = "1.20.4", k.constructor = f, k.kill()._gc = !1, f.killTweensOf = f.killDelayedCallsTo = c.killTweensOf, f.getTweensOf = c.getTweensOf, f.lagSmoothing = c.lagSmoothing, f.ticker = c.ticker, f.render = c.render, k.invalidate = function () { return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), c.prototype.invalidate.call(this) }, k.updateTo = function (a, b) { var d, e = this.ratio, f = this.vars.immediateRender || a.immediateRender; b && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)); for (d in a) this.vars[d] = a[d]; if (this._initted || f) if (b) this._initted = !1, f && this.render(0, !0, !0); else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && c._onPluginEvent("_onDisable", this), this._time / this._duration > .998) { var g = this._totalTime; this.render(0, !0, !1), this._initted = !1, this.render(g, !0, !1) } else if (this._initted = !1, this._init(), this._time > 0 || f) for (var h, i = 1 / (1 - e), j = this._firstPT; j;)h = j.s + j.c, j.c *= i, j.s = h - j.c, j = j._next; return this }, k.render = function (a, b, d) { this._initted || 0 === this._duration && this.vars.repeat && this.invalidate(); var e, f, i, j, k, l, m, n, o, p = this._dirty ? this.totalDuration() : this._totalDuration, q = this._time, r = this._totalTime, s = this._cycle, t = this._duration, u = this._rawPrevTime; if (a >= p - 1e-7 && a >= 0 ? (this._totalTime = p, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = t, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (e = !0, f = "onComplete", d = d || this._timeline.autoRemoveChildren), 0 === t && (this._initted || !this.vars.lazy || d) && (this._startTime === this._timeline._duration && (a = 0), (0 > u || 0 >= a && a >= -1e-7 || u === g && "isPause" !== this.data) && u !== a && (d = !0, u > g && (f = "onReverseComplete")), this._rawPrevTime = n = !b || a || u === a ? a : g)) : 1e-7 > a ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== r || 0 === t && u > 0) && (f = "onReverseComplete", e = this._reversed), 0 > a && (this._active = !1, 0 === t && (this._initted || !this.vars.lazy || d) && (u >= 0 && (d = !0), this._rawPrevTime = n = !b || a || u === a ? a : g)), this._initted || (d = !0)) : (this._totalTime = this._time = a, 0 !== this._repeat && (j = t + this._repeatDelay, this._cycle = this._totalTime / j >> 0, 0 !== this._cycle && this._cycle === this._totalTime / j && a >= r && this._cycle--, this._time = this._totalTime - this._cycle * j, this._yoyo && 0 !== (1 & this._cycle) && (this._time = t - this._time, o = this._yoyoEase || this.vars.yoyoEase, o && (this._yoyoEase || (o !== !0 || this._initted ? this._yoyoEase = o = o === !0 ? this._ease : o instanceof Ease ? o : Ease.map[o] : (o = this.vars.ease, this._yoyoEase = o = o ? o instanceof Ease ? o : "function" == typeof o ? new Ease(o, this.vars.easeParams) : Ease.map[o] || c.defaultEase : c.defaultEase)), this.ratio = o ? 1 - o.getRatio((t - this._time) / t) : 0)), this._time > t ? this._time = t : this._time < 0 && (this._time = 0)), this._easeType && !o ? (k = this._time / t, l = this._easeType, m = this._easePower, (1 === l || 3 === l && k >= .5) && (k = 1 - k), 3 === l && (k *= 2), 1 === m ? k *= k : 2 === m ? k *= k * k : 3 === m ? k *= k * k * k : 4 === m && (k *= k * k * k * k), 1 === l ? this.ratio = 1 - k : 2 === l ? this.ratio = k : this._time / t < .5 ? this.ratio = k / 2 : this.ratio = 1 - k / 2) : o || (this.ratio = this._ease.getRatio(this._time / t))), q === this._time && !d && s === this._cycle) return void (r !== this._totalTime && this._onUpdate && (b || this._callback("onUpdate"))); if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!d && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = q, this._totalTime = r, this._rawPrevTime = u, this._cycle = s, h.lazyTweens.push(this), void (this._lazy = [a, b]); !this._time || e || o ? e && this._ease._calcEnd && !o && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / t) } for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== q && a >= 0 && (this._active = !0), 0 === r && (2 === this._initted && a > 0 && this._init(), this._startAt && (a >= 0 ? this._startAt.render(a, !0, d) : f || (f = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === t) && (b || this._callback("onStart"))), i = this._firstPT; i;)i.f ? i.t[i.p](i.c * this.ratio + i.s) : i.t[i.p] = i.c * this.ratio + i.s, i = i._next; this._onUpdate && (0 > a && this._startAt && this._startTime && this._startAt.render(a, !0, d), b || (this._totalTime !== r || f) && this._callback("onUpdate")), this._cycle !== s && (b || this._gc || this.vars.onRepeat && this._callback("onRepeat")), f && (!this._gc || d) && (0 > a && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(a, !0, d), e && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[f] && this._callback(f), 0 === t && this._rawPrevTime === g && n !== g && (this._rawPrevTime = 0)) }, f.to = function (a, b, c) { return new f(a, b, c) }, f.from = function (a, b, c) { return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, new f(a, b, c) }, f.fromTo = function (a, b, c, d) { return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, new f(a, b, d) }, f.staggerTo = f.allTo = function (a, b, g, h, k, m, n) { h = h || 0; var o, p, q, r, s = 0, t = [], u = function () { g.onComplete && g.onComplete.apply(g.onCompleteScope || this, arguments), k.apply(n || g.callbackScope || this, m || l) }, v = g.cycle, w = g.startAt && g.startAt.cycle; for (j(a) || ("string" == typeof a && (a = c.selector(a) || a), i(a) && (a = d(a))), a = a || [], 0 > h && (a = d(a), a.reverse(), h *= -1), o = a.length - 1, q = 0; o >= q; q++) { p = {}; for (r in g) p[r] = g[r]; if (v && (e(p, a, q), null != p.duration && (b = p.duration, delete p.duration)), w) { w = p.startAt = {}; for (r in g.startAt) w[r] = g.startAt[r]; e(p.startAt, a, q) } p.delay = s + (p.delay || 0), q === o && k && (p.onComplete = u), t[q] = new f(a[q], b, p), s += h } return t }, f.staggerFrom = f.allFrom = function (a, b, c, d, e, g, h) { return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, f.staggerTo(a, b, c, d, e, g, h) }, f.staggerFromTo = f.allFromTo = function (a, b, c, d, e, g, h, i) { return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, f.staggerTo(a, b, d, e, g, h, i) }, f.delayedCall = function (a, b, c, d, e) { return new f(b, 0, { delay: a, onComplete: b, onCompleteParams: c, callbackScope: d, onReverseComplete: b, onReverseCompleteParams: c, immediateRender: !1, useFrames: e, overwrite: 0 }) }, f.set = function (a, b) { return new f(a, 0, b) }, f.isTweening = function (a) { return c.getTweensOf(a, !0).length > 0 }; var m = function (a, b) { for (var d = [], e = 0, f = a._first; f;)f instanceof c ? d[e++] = f : (b && (d[e++] = f), d = d.concat(m(f, b)), e = d.length), f = f._next; return d }, n = f.getAllTweens = function (b) { return m(a._rootTimeline, b).concat(m(a._rootFramesTimeline, b)) }; f.killAll = function (a, c, d, e) { null == c && (c = !0), null == d && (d = !0); var f, g, h, i = n(0 != e), j = i.length, k = c && d && e; for (h = 0; j > h; h++)g = i[h], (k || g instanceof b || (f = g.target === g.vars.onComplete) && d || c && !f) && (a ? g.totalTime(g._reversed ? 0 : g.totalDuration()) : g._enabled(!1, !1)) }, f.killChildTweensOf = function (a, b) { if (null != a) { var e, g, k, l, m, n = h.tweenLookup; if ("string" == typeof a && (a = c.selector(a) || a), i(a) && (a = d(a)), j(a)) for (l = a.length; --l > -1;)f.killChildTweensOf(a[l], b); else { e = []; for (k in n) for (g = n[k].target.parentNode; g;)g === a && (e = e.concat(n[k].tweens)), g = g.parentNode; for (m = e.length, l = 0; m > l; l++)b && e[l].totalTime(e[l].totalDuration()), e[l]._enabled(!1, !1) } } }; var o = function (a, c, d, e) { c = c !== !1, d = d !== !1, e = e !== !1; for (var f, g, h = n(e), i = c && d && e, j = h.length; --j > -1;)g = h[j], (i || g instanceof b || (f = g.target === g.vars.onComplete) && d || c && !f) && g.paused(a) }; return f.pauseAll = function (a, b, c) { o(!0, a, b, c) }, f.resumeAll = function (a, b, c) { o(!1, a, b, c) }, f.globalTimeScale = function (b) { var d = a._rootTimeline, e = c.ticker.time; return arguments.length ? (b = b || g, d._startTime = e - (e - d._startTime) * d._timeScale / b, d = a._rootFramesTimeline, e = c.ticker.frame, d._startTime = e - (e - d._startTime) * d._timeScale / b, d._timeScale = a._rootTimeline._timeScale = b, b) : d._timeScale }, k.progress = function (a, b) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - a : a) + this._cycle * (this._duration + this._repeatDelay), b) : this._time / this.duration() }, k.totalProgress = function (a, b) { return arguments.length ? this.totalTime(this.totalDuration() * a, b) : this._totalTime / this.totalDuration() }, k.time = function (a, b) { return arguments.length ? (this._dirty && this.totalDuration(), a > this._duration && (a = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? a = this._duration - a + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (a += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(a, b)) : this._time }, k.duration = function (b) { return arguments.length ? a.prototype.duration.call(this, b) : this._duration }, k.totalDuration = function (a) { return arguments.length ? -1 === this._repeat ? this : this.duration((a - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, k.repeat = function (a) { return arguments.length ? (this._repeat = a, this._uncache(!0)) : this._repeat }, k.repeatDelay = function (a) { return arguments.length ? (this._repeatDelay = a, this._uncache(!0)) : this._repeatDelay }, k.yoyo = function (a) { return arguments.length ? (this._yoyo = a, this) : this._yoyo }, f }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (a, b, c) { var d = function (a) { b.call(this, a), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate; var c, d, e = this.vars; for (d in e) c = e[d], i(c) && -1 !== c.join("").indexOf("{self}") && (e[d] = this._swapSelfInParams(c)); i(e.tweens) && this.add(e.tweens, 0, e.align, e.stagger) }, e = 1e-10, f = c._internals, g = d._internals = {}, h = f.isSelector, i = f.isArray, j = f.lazyTweens, k = f.lazyRender, l = _gsScope._gsDefine.globals, m = function (a) { var b, c = {}; for (b in a) c[b] = a[b]; return c }, n = function (a, b, c) { var d, e, f = a.cycle; for (d in f) e = f[d], a[d] = "function" == typeof e ? e(c, b[c]) : e[c % e.length]; delete a.cycle }, o = g.pauseCallback = function () { }, p = function (a) { var b, c = [], d = a.length; for (b = 0; b !== d; c.push(a[b++])); return c }, q = d.prototype = new b; return d.version = "1.20.4", q.constructor = d, q.kill()._gc = q._forcingPlayhead = q._hasPause = !1, q.to = function (a, b, d, e) { var f = d.repeat && l.TweenMax || c; return b ? this.add(new f(a, b, d), e) : this.set(a, d, e) }, q.from = function (a, b, d, e) { return this.add((d.repeat && l.TweenMax || c).from(a, b, d), e) }, q.fromTo = function (a, b, d, e, f) { var g = e.repeat && l.TweenMax || c; return b ? this.add(g.fromTo(a, b, d, e), f) : this.set(a, e, f) }, q.staggerTo = function (a, b, e, f, g, i, j, k) { var l, o, q = new d({ onComplete: i, onCompleteParams: j, callbackScope: k, smoothChildTiming: this.smoothChildTiming }), r = e.cycle; for ("string" == typeof a && (a = c.selector(a) || a), a = a || [], h(a) && (a = p(a)), f = f || 0, 0 > f && (a = p(a), a.reverse(), f *= -1), o = 0; o < a.length; o++)l = m(e), l.startAt && (l.startAt = m(l.startAt), l.startAt.cycle && n(l.startAt, a, o)), r && (n(l, a, o), null != l.duration && (b = l.duration, delete l.duration)), q.to(a[o], b, l, o * f); return this.add(q, g) }, q.staggerFrom = function (a, b, c, d, e, f, g, h) { return c.immediateRender = 0 != c.immediateRender, c.runBackwards = !0, this.staggerTo(a, b, c, d, e, f, g, h) }, q.staggerFromTo = function (a, b, c, d, e, f, g, h, i) { return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, this.staggerTo(a, b, d, e, f, g, h, i) }, q.call = function (a, b, d, e) { return this.add(c.delayedCall(0, a, b, d), e) }, q.set = function (a, b, d) { return d = this._parseTimeOrLabel(d, 0, !0), null == b.immediateRender && (b.immediateRender = d === this._time && !this._paused), this.add(new c(a, 0, b), d) }, d.exportRoot = function (a, b) { a = a || {}, null == a.smoothChildTiming && (a.smoothChildTiming = !0); var e, f, g, h, i = new d(a), j = i._timeline; for (null == b && (b = !0), j._remove(i, !0), i._startTime = 0, i._rawPrevTime = i._time = i._totalTime = j._time, g = j._first; g;)h = g._next, b && g instanceof c && g.target === g.vars.onComplete || (f = g._startTime - g._delay, 0 > f && (e = 1), i.add(g, f)), g = h; return j.add(i, 0), e && i.totalDuration(), i }, q.add = function (e, f, g, h) { var j, k, l, m, n, o; if ("number" != typeof f && (f = this._parseTimeOrLabel(f, 0, !0, e)), !(e instanceof a)) { if (e instanceof Array || e && e.push && i(e)) { for (g = g || "normal", h = h || 0, j = f, k = e.length, l = 0; k > l; l++)i(m = e[l]) && (m = new d({ tweens: m })), this.add(m, j), "string" != typeof m && "function" != typeof m && ("sequence" === g ? j = m._startTime + m.totalDuration() / m._timeScale : "start" === g && (m._startTime -= m.delay())), j += h; return this._uncache(!0) } if ("string" == typeof e) return this.addLabel(e, f); if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string."; e = c.delayedCall(0, e) } if (b.prototype.add.call(this, e, f), e._time && e.render((this.rawTime() - e._startTime) * e._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (n = this, o = n.rawTime() > e._startTime; n._timeline;)o && n._timeline.smoothChildTiming ? n.totalTime(n._totalTime, !0) : n._gc && n._enabled(!0, !1), n = n._timeline; return this }, q.remove = function (b) { if (b instanceof a) { this._remove(b, !1); var c = b._timeline = b.vars.useFrames ? a._rootFramesTimeline : a._rootTimeline; return b._startTime = (b._paused ? b._pauseTime : c._time) - (b._reversed ? b.totalDuration() - b._totalTime : b._totalTime) / b._timeScale, this } if (b instanceof Array || b && b.push && i(b)) { for (var d = b.length; --d > -1;)this.remove(b[d]); return this } return "string" == typeof b ? this.removeLabel(b) : this.kill(null, b) }, q._remove = function (a, c) { b.prototype._remove.call(this, a, c); var d = this._last; return d ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, q.append = function (a, b) { return this.add(a, this._parseTimeOrLabel(null, b, !0, a)) }, q.insert = q.insertMultiple = function (a, b, c, d) { return this.add(a, b || 0, c, d) }, q.appendMultiple = function (a, b, c, d) { return this.add(a, this._parseTimeOrLabel(null, b, !0, a), c, d) }, q.addLabel = function (a, b) { return this._labels[a] = this._parseTimeOrLabel(b), this }, q.addPause = function (a, b, d, e) { var f = c.delayedCall(0, o, d, e || this); return f.vars.onComplete = f.vars.onReverseComplete = b, f.data = "isPause", this._hasPause = !0, this.add(f, a) }, q.removeLabel = function (a) { return delete this._labels[a], this }, q.getLabelTime = function (a) { return null != this._labels[a] ? this._labels[a] : -1 }, q._parseTimeOrLabel = function (b, c, d, e) { var f, g; if (e instanceof a && e.timeline === this) this.remove(e); else if (e && (e instanceof Array || e.push && i(e))) for (g = e.length; --g > -1;)e[g] instanceof a && e[g].timeline === this && this.remove(e[g]); if (f = "number" != typeof b || c ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof c) return this._parseTimeOrLabel(c, d && "number" == typeof b && null == this._labels[c] ? b - f : 0, d); if (c = c || 0, "string" != typeof b || !isNaN(b) && null == this._labels[b]) null == b && (b = f); else { if (g = b.indexOf("="), -1 === g) return null == this._labels[b] ? d ? this._labels[b] = f + c : c : this._labels[b] + c; c = parseInt(b.charAt(g - 1) + "1", 10) * Number(b.substr(g + 1)), b = g > 1 ? this._parseTimeOrLabel(b.substr(0, g - 1), 0, d) : f } return Number(b) + c }, q.seek = function (a, b) { return this.totalTime("number" == typeof a ? a : this._parseTimeOrLabel(a), b !== !1) }, q.stop = function () { return this.paused(!0) }, q.gotoAndPlay = function (a, b) { return this.play(a, b) }, q.gotoAndStop = function (a, b) { return this.pause(a, b) }, q.render = function (a, b, c) { this._gc && this._enabled(!0, !1); var d, f, g, h, i, l, m, n = this._time, o = this._dirty ? this.totalDuration() : this._totalDuration, p = this._startTime, q = this._timeScale, r = this._paused; if (n !== this._time && (a += this._time - n), a >= o - 1e-7 && a >= 0) this._totalTime = this._time = o, this._reversed || this._hasPausedChild() || (f = !0, h = "onComplete", i = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= a && a >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === e) && this._rawPrevTime !== a && this._first && (i = !0, this._rawPrevTime > e && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e, a = o + 1e-4; else if (1e-7 > a) if (this._totalTime = this._time = 0, (0 !== n || 0 === this._duration && this._rawPrevTime !== e && (this._rawPrevTime > 0 || 0 > a && this._rawPrevTime >= 0)) && (h = "onReverseComplete", f = this._reversed), 0 > a) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (i = f = !0, h = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (i = !0), this._rawPrevTime = a; else { if (this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e, 0 === a && f) for (d = this._first; d && 0 === d._startTime;)d._duration || (f = !1), d = d._next; a = 0, this._initted || (i = !0) } else { if (this._hasPause && !this._forcingPlayhead && !b) { if (a >= n) for (d = this._first; d && d._startTime <= a && !l;)d._duration || "isPause" !== d.data || d.ratio || 0 === d._startTime && 0 === this._rawPrevTime || (l = d), d = d._next; else for (d = this._last; d && d._startTime >= a && !l;)d._duration || "isPause" === d.data && d._rawPrevTime > 0 && (l = d), d = d._prev; l && (this._time = a = l._startTime, this._totalTime = a + this._cycle * (this._totalDuration + this._repeatDelay)) } this._totalTime = this._time = this._rawPrevTime = a } if (this._time !== n && this._first || c || i || l) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== n && a > 0 && (this._active = !0), 0 === n && this.vars.onStart && (0 === this._time && this._duration || b || this._callback("onStart")), m = this._time, m >= n) for (d = this._first; d && (g = d._next, m === this._time && (!this._paused || r));)(d._active || d._startTime <= m && !d._paused && !d._gc) && (l === d && this.pause(), d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)), d = g; else for (d = this._last; d && (g = d._prev, m === this._time && (!this._paused || r));) { if (d._active || d._startTime <= n && !d._paused && !d._gc) { if (l === d) { for (l = d._prev; l && l.endTime() > this._time;)l.render(l._reversed ? l.totalDuration() - (a - l._startTime) * l._timeScale : (a - l._startTime) * l._timeScale, b, c), l = l._prev; l = null, this.pause() } d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c) } d = g } this._onUpdate && (b || (j.length && k(), this._callback("onUpdate"))), h && (this._gc || (p === this._startTime || q !== this._timeScale) && (0 === this._time || o >= this.totalDuration()) && (f && (j.length && k(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[h] && this._callback(h))) } }, q._hasPausedChild = function () { for (var a = this._first; a;) { if (a._paused || a instanceof d && a._hasPausedChild()) return !0; a = a._next } return !1 }, q.getChildren = function (a, b, d, e) { e = e || -9999999999; for (var f = [], g = this._first, h = 0; g;)g._startTime < e || (g instanceof c ? b !== !1 && (f[h++] = g) : (d !== !1 && (f[h++] = g), a !== !1 && (f = f.concat(g.getChildren(!0, b, d)), h = f.length))), g = g._next; return f }, q.getTweensOf = function (a, b) { var d, e, f = this._gc, g = [], h = 0; for (f && this._enabled(!0, !0), d = c.getTweensOf(a), e = d.length; --e > -1;)(d[e].timeline === this || b && this._contains(d[e])) && (g[h++] = d[e]); return f && this._enabled(!1, !0), g }, q.recent = function () { return this._recent }, q._contains = function (a) { for (var b = a.timeline; b;) { if (b === this) return !0; b = b.timeline } return !1 }, q.shiftChildren = function (a, b, c) { c = c || 0; for (var d, e = this._first, f = this._labels; e;)e._startTime >= c && (e._startTime += a), e = e._next; if (b) for (d in f) f[d] >= c && (f[d] += a); return this._uncache(!0) }, q._kill = function (a, b) { if (!a && !b) return this._enabled(!1, !1); for (var c = b ? this.getTweensOf(b) : this.getChildren(!0, !0, !1), d = c.length, e = !1; --d > -1;)c[d]._kill(a, b) && (e = !0); return e }, q.clear = function (a) { var b = this.getChildren(!1, !0, !0), c = b.length; for (this._time = this._totalTime = 0; --c > -1;)b[c]._enabled(!1, !1); return a !== !1 && (this._labels = {}), this._uncache(!0) }, q.invalidate = function () { for (var b = this._first; b;)b.invalidate(), b = b._next; return a.prototype.invalidate.call(this) }, q._enabled = function (a, c) { if (a === this._gc) for (var d = this._first; d;)d._enabled(a, !0), d = d._next; return b.prototype._enabled.call(this, a, c) }, q.totalTime = function (b, c, d) { this._forcingPlayhead = !0; var e = a.prototype.totalTime.apply(this, arguments); return this._forcingPlayhead = !1, e }, q.duration = function (a) { return arguments.length ? (0 !== this.duration() && 0 !== a && this.timeScale(this._duration / a), this) : (this._dirty && this.totalDuration(), this._duration) }, q.totalDuration = function (a) { if (!arguments.length) { if (this._dirty) { for (var b, c, d = 0, e = this._last, f = 999999999999; e;)b = e._prev, e._dirty && e.totalDuration(), e._startTime > f && this._sortChildren && !e._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(e, e._startTime - e._delay), this._calculatingDuration = 0) : f = e._startTime, e._startTime < 0 && !e._paused && (d -= e._startTime, this._timeline.smoothChildTiming && (this._startTime += e._startTime / this._timeScale, this._time -= e._startTime, this._totalTime -= e._startTime, this._rawPrevTime -= e._startTime), this.shiftChildren(-e._startTime, !1, -9999999999), f = 0), c = e._startTime + e._totalDuration / e._timeScale, c > d && (d = c), e = b; this._duration = this._totalDuration = d, this._dirty = !1 } return this._totalDuration } return a && this.totalDuration() ? this.timeScale(this._totalDuration / a) : this }, q.paused = function (b) { if (!b) for (var c = this._first, d = this._time; c;)c._startTime === d && "isPause" === c.data && (c._rawPrevTime = 0), c = c._next; return a.prototype.paused.apply(this, arguments) }, q.usesFrames = function () { for (var b = this._timeline; b._timeline;)b = b._timeline; return b === a._rootFramesTimeline }, q.rawTime = function (a) { return a && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(a) - this._startTime) * this._timeScale }, d }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (a, b, c) { var d = function (b) { a.call(this, b), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0 }, e = 1e-10, f = b._internals, g = f.lazyTweens, h = f.lazyRender, i = _gsScope._gsDefine.globals, j = new c(null, null, 1, 0), k = d.prototype = new a; return k.constructor = d, k.kill()._gc = !1, d.version = "1.20.4", k.invalidate = function () { return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), a.prototype.invalidate.call(this) }, k.addCallback = function (a, c, d, e) { return this.add(b.delayedCall(0, a, d, e), c) }, k.removeCallback = function (a, b) { if (a) if (null == b) this._kill(null, a); else for (var c = this.getTweensOf(a, !1), d = c.length, e = this._parseTimeOrLabel(b); --d > -1;)c[d]._startTime === e && c[d]._enabled(!1, !1); return this }, k.removePause = function (b) { return this.removeCallback(a._internals.pauseCallback, b) }, k.tweenTo = function (a, c) { c = c || {}; var d, e, f, g = { ease: j, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1 }, h = c.repeat && i.TweenMax || b; for (e in c) g[e] = c[e]; return g.time = this._parseTimeOrLabel(a), d = Math.abs(Number(g.time) - this._time) / this._timeScale || .001, f = new h(this, d, g), g.onStart = function () { f.target.paused(!0), f.vars.time === f.target.time() || d !== f.duration() || f.isFromTo || f.duration(Math.abs(f.vars.time - f.target.time()) / f.target._timeScale).render(f.time(), !0, !0), c.onStart && c.onStart.apply(c.onStartScope || c.callbackScope || f, c.onStartParams || []) }, f }, k.tweenFromTo = function (a, b, c) { c = c || {}, a = this._parseTimeOrLabel(a), c.startAt = { onComplete: this.seek, onCompleteParams: [a], callbackScope: this }, c.immediateRender = c.immediateRender !== !1; var d = this.tweenTo(b, c); return d.isFromTo = 1, d.duration(Math.abs(d.vars.time - a) / this._timeScale || .001) }, k.render = function (a, b, c) { this._gc && this._enabled(!0, !1); var d, f, i, j, k, l, m, n, o = this._time, p = this._dirty ? this.totalDuration() : this._totalDuration, q = this._duration, r = this._totalTime, s = this._startTime, t = this._timeScale, u = this._rawPrevTime, v = this._paused, w = this._cycle; if (o !== this._time && (a += this._time - o), a >= p - 1e-7 && a >= 0) this._locked || (this._totalTime = p, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (f = !0, j = "onComplete", k = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= a && a >= -1e-7 || 0 > u || u === e) && u !== a && this._first && (k = !0, u > e && (j = "onReverseComplete"))), this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e, this._yoyo && 0 !== (1 & this._cycle) ? this._time = a = 0 : (this._time = q, a = q + 1e-4); else if (1e-7 > a) if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== o || 0 === q && u !== e && (u > 0 || 0 > a && u >= 0) && !this._locked) && (j = "onReverseComplete", f = this._reversed), 0 > a) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (k = f = !0, j = "onReverseComplete") : u >= 0 && this._first && (k = !0), this._rawPrevTime = a; else { if (this._rawPrevTime = q || !b || a || this._rawPrevTime === a ? a : e, 0 === a && f) for (d = this._first; d && 0 === d._startTime;)d._duration || (f = !1), d = d._next; a = 0, this._initted || (k = !0) } else if (0 === q && 0 > u && (k = !0), this._time = this._rawPrevTime = a, this._locked || (this._totalTime = a, 0 !== this._repeat && (l = q + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && a >= r && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 !== (1 & this._cycle) && (this._time = q - this._time), this._time > q ? (this._time = q, a = q + 1e-4) : this._time < 0 ? this._time = a = 0 : a = this._time)), this._hasPause && !this._forcingPlayhead && !b) { if (a = this._time, a >= o || this._repeat && w !== this._cycle) for (d = this._first; d && d._startTime <= a && !m;)d._duration || "isPause" !== d.data || d.ratio || 0 === d._startTime && 0 === this._rawPrevTime || (m = d), d = d._next; else for (d = this._last; d && d._startTime >= a && !m;)d._duration || "isPause" === d.data && d._rawPrevTime > 0 && (m = d), d = d._prev; m && m._startTime < q && (this._time = a = m._startTime, this._totalTime = a + this._cycle * (this._totalDuration + this._repeatDelay)) } if (this._cycle !== w && !this._locked) { var x = this._yoyo && 0 !== (1 & w), y = x === (this._yoyo && 0 !== (1 & this._cycle)), z = this._totalTime, A = this._cycle, B = this._rawPrevTime, C = this._time; if (this._totalTime = w * q, this._cycle < w ? x = !x : this._totalTime += q, this._time = o, this._rawPrevTime = 0 === q ? u - 1e-4 : u, this._cycle = w, this._locked = !0, o = x ? 0 : q, this.render(o, b, 0 === q), b || this._gc || this.vars.onRepeat && (this._cycle = A, this._locked = !1, this._callback("onRepeat")), o !== this._time) return; if (y && (this._cycle = w, this._locked = !0, o = x ? q + 1e-4 : -1e-4, this.render(o, !0, !1)), this._locked = !1, this._paused && !v) return; this._time = C, this._totalTime = z, this._cycle = A, this._rawPrevTime = B } if (!(this._time !== o && this._first || c || k || m)) return void (r !== this._totalTime && this._onUpdate && (b || this._callback("onUpdate"))); if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== r && a > 0 && (this._active = !0), 0 === r && this.vars.onStart && (0 === this._totalTime && this._totalDuration || b || this._callback("onStart")), n = this._time, n >= o) for (d = this._first; d && (i = d._next, n === this._time && (!this._paused || v));)(d._active || d._startTime <= this._time && !d._paused && !d._gc) && (m === d && this.pause(), d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)), d = i; else for (d = this._last; d && (i = d._prev, n === this._time && (!this._paused || v));) { if (d._active || d._startTime <= o && !d._paused && !d._gc) { if (m === d) { for (m = d._prev; m && m.endTime() > this._time;)m.render(m._reversed ? m.totalDuration() - (a - m._startTime) * m._timeScale : (a - m._startTime) * m._timeScale, b, c), m = m._prev; m = null, this.pause() } d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c) } d = i } this._onUpdate && (b || (g.length && h(), this._callback("onUpdate"))), j && (this._locked || this._gc || (s === this._startTime || t !== this._timeScale) && (0 === this._time || p >= this.totalDuration()) && (f && (g.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[j] && this._callback(j))) }, k.getActive = function (a, b, c) { null == a && (a = !0), null == b && (b = !0), null == c && (c = !1); var d, e, f = [], g = this.getChildren(a, b, c), h = 0, i = g.length; for (d = 0; i > d; d++)e = g[d], e.isActive() && (f[h++] = e); return f }, k.getLabelAfter = function (a) { a || 0 !== a && (a = this._time); var b, c = this.getLabelsArray(), d = c.length; for (b = 0; d > b; b++)if (c[b].time > a) return c[b].name; return null }, k.getLabelBefore = function (a) { null == a && (a = this._time); for (var b = this.getLabelsArray(), c = b.length; --c > -1;)if (b[c].time < a) return b[c].name; return null }, k.getLabelsArray = function () { var a, b = [], c = 0; for (a in this._labels) b[c++] = { time: this._labels[a], name: a }; return b.sort(function (a, b) { return a.time - b.time }), b }, k.invalidate = function () { return this._locked = !1, a.prototype.invalidate.call(this) }, k.progress = function (a, b) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - a : a) + this._cycle * (this._duration + this._repeatDelay), b) : this._time / this.duration() || 0 }, k.totalProgress = function (a, b) { return arguments.length ? this.totalTime(this.totalDuration() * a, b) : this._totalTime / this.totalDuration() || 0 }, k.totalDuration = function (b) { return arguments.length ? -1 !== this._repeat && b ? this.timeScale(this.totalDuration() / b) : this : (this._dirty && (a.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, k.time = function (a, b) { return arguments.length ? (this._dirty && this.totalDuration(), a > this._duration && (a = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? a = this._duration - a + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (a += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(a, b)) : this._time }, k.repeat = function (a) { return arguments.length ? (this._repeat = a, this._uncache(!0)) : this._repeat }, k.repeatDelay = function (a) { return arguments.length ? (this._repeatDelay = a, this._uncache(!0)) : this._repeatDelay }, k.yoyo = function (a) { return arguments.length ? (this._yoyo = a, this) : this._yoyo }, k.currentLabel = function (a) { return arguments.length ? this.seek(a, !0) : this.getLabelBefore(this._time + 1e-8) }, d }, !0), function () { var a = 180 / Math.PI, b = [], c = [], d = [], e = {}, f = _gsScope._gsDefine.globals, g = function (a, b, c, d) { c === d && (c = d - (d - b) / 1e6), a === b && (b = a + (c - a) / 1e6), this.a = a, this.b = b, this.c = c, this.d = d, this.da = d - a, this.ca = c - a, this.ba = b - a }, h = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", i = function (a, b, c, d) { var e = { a: a }, f = {}, g = {}, h = { c: d }, i = (a + b) / 2, j = (b + c) / 2, k = (c + d) / 2, l = (i + j) / 2, m = (j + k) / 2, n = (m - l) / 8; return e.b = i + (a - i) / 4, f.b = l + n, e.c = f.a = (e.b + f.b) / 2, f.c = g.a = (l + m) / 2, g.b = m - n, h.b = k + (d - k) / 4, g.c = h.a = (g.b + h.b) / 2, [e, f, g, h] }, j = function (a, e, f, g, h) { var j, k, l, m, n, o, p, q, r, s, t, u, v, w = a.length - 1, x = 0, y = a[0].a; for (j = 0; w > j; j++)n = a[x], k = n.a, l = n.d, m = a[x + 1].d, h ? (t = b[j], u = c[j], v = (u + t) * e * .25 / (g ? .5 : d[j] || .5), o = l - (l - k) * (g ? .5 * e : 0 !== t ? v / t : 0), p = l + (m - l) * (g ? .5 * e : 0 !== u ? v / u : 0), q = l - (o + ((p - o) * (3 * t / (t + u) + .5) / 4 || 0))) : (o = l - (l - k) * e * .5, p = l + (m - l) * e * .5, q = l - (o + p) / 2), o += q, p += q, n.c = r = o, 0 !== j ? n.b = y : n.b = y = n.a + .6 * (n.c - n.a), n.da = l - k, n.ca = r - k, n.ba = y - k, f ? (s = i(k, y, r, l), a.splice(x, 1, s[0], s[1], s[2], s[3]), x += 4) : x++, y = p; n = a[x], n.b = y, n.c = y + .4 * (n.d - y), n.da = n.d - n.a, n.ca = n.c - n.a, n.ba = y - n.a, f && (s = i(n.a, y, n.c, n.d), a.splice(x, 1, s[0], s[1], s[2], s[3])) }, k = function (a, d, e, f) { var h, i, j, k, l, m, n = []; if (f) for (a = [f].concat(a), i = a.length; --i > -1;)"string" == typeof (m = a[i][d]) && "=" === m.charAt(1) && (a[i][d] = f[d] + Number(m.charAt(0) + m.substr(2))); if (h = a.length - 2, 0 > h) return n[0] = new g(a[0][d], 0, 0, a[0][d]), n; for (i = 0; h > i; i++)j = a[i][d], k = a[i + 1][d], n[i] = new g(j, 0, 0, k), e && (l = a[i + 2][d], b[i] = (b[i] || 0) + (k - j) * (k - j), c[i] = (c[i] || 0) + (l - k) * (l - k)); return n[i] = new g(a[i][d], 0, 0, a[i + 1][d]), n }, l = function (a, f, g, i, l, m) { var n, o, p, q, r, s, t, u, v = {}, w = [], x = m || a[0]; l = "string" == typeof l ? "," + l + "," : h, null == f && (f = 1); for (o in a[0]) w.push(o); if (a.length > 1) { for (u = a[a.length - 1], t = !0, n = w.length; --n > -1;)if (o = w[n], Math.abs(x[o] - u[o]) > .05) { t = !1; break } t && (a = a.concat(), m && a.unshift(m), a.push(a[1]), m = a[a.length - 3]) } for (b.length = c.length = d.length = 0, n = w.length; --n > -1;)o = w[n], e[o] = -1 !== l.indexOf("," + o + ","), v[o] = k(a, o, e[o], m); for (n = b.length; --n > -1;)b[n] = Math.sqrt(b[n]), c[n] = Math.sqrt(c[n]); if (!i) { for (n = w.length; --n > -1;)if (e[o]) for (p = v[w[n]], s = p.length - 1, q = 0; s > q; q++)r = p[q + 1].da / c[q] + p[q].da / b[q] || 0, d[q] = (d[q] || 0) + r * r; for (n = d.length; --n > -1;)d[n] = Math.sqrt(d[n]) } for (n = w.length, q = g ? 4 : 1; --n > -1;)o = w[n], p = v[o], j(p, f, g, i, e[o]), t && (p.splice(0, q), p.splice(p.length - q, q)); return v }, m = function (a, b, c) { b = b || "soft"; var d, e, f, h, i, j, k, l, m, n, o, p = {}, q = "cubic" === b ? 3 : 2, r = "soft" === b, s = []; if (r && c && (a = [c].concat(a)), null == a || a.length < q + 1) throw "invalid Bezier data"; for (m in a[0]) s.push(m); for (j = s.length; --j > -1;) { for (m = s[j], p[m] = i = [], n = 0, l = a.length, k = 0; l > k; k++)d = null == c ? a[k][m] : "string" == typeof (o = a[k][m]) && "=" === o.charAt(1) ? c[m] + Number(o.charAt(0) + o.substr(2)) : Number(o), r && k > 1 && l - 1 > k && (i[n++] = (d + i[n - 2]) / 2), i[n++] = d; for (l = n - q + 1, n = 0, k = 0; l > k; k += q)d = i[k], e = i[k + 1], f = i[k + 2], h = 2 === q ? 0 : i[k + 3], i[n++] = o = 3 === q ? new g(d, e, f, h) : new g(d, (2 * e + d) / 3, (2 * e + f) / 3, f); i.length = n } return p }, n = function (a, b, c) { for (var d, e, f, g, h, i, j, k, l, m, n, o = 1 / c, p = a.length; --p > -1;)for (m = a[p], f = m.a, g = m.d - f, h = m.c - f, i = m.b - f, d = e = 0, k = 1; c >= k; k++)j = o * k, l = 1 - j, d = e - (e = (j * j * g + 3 * l * (j * h + l * i)) * j), n = p * c + k - 1, b[n] = (b[n] || 0) + d * d }, o = function (a, b) { b = b >> 0 || 6; var c, d, e, f, g = [], h = [], i = 0, j = 0, k = b - 1, l = [], m = []; for (c in a) n(a[c], g, b); for (e = g.length, d = 0; e > d; d++)i += Math.sqrt(g[d]), f = d % b, m[f] = i, f === k && (j += i, f = d / b >> 0, l[f] = m, h[f] = j, i = 0, m = []); return { length: j, lengths: h, segments: l } }, p = _gsScope._gsDefine.plugin({ propName: "bezier", priority: -1, version: "1.3.8", API: 2, global: !0, init: function (a, b, c) { this._target = a, b instanceof Array && (b = { values: b }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == b.timeResolution ? 6 : parseInt(b.timeResolution, 10); var d, e, f, g, h, i = b.values || [], j = {}, k = i[0], n = b.autoRotate || c.vars.orientToBezier; this._autoRotate = n ? n instanceof Array ? n : [["x", "y", "rotation", n === !0 ? 0 : Number(n) || 0]] : null; for (d in k) this._props.push(d); for (f = this._props.length; --f > -1;)d = this._props[f], this._overwriteProps.push(d), e = this._func[d] = "function" == typeof a[d], j[d] = e ? a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)]() : parseFloat(a[d]), h || j[d] !== i[0][d] && (h = j); if (this._beziers = "cubic" !== b.type && "quadratic" !== b.type && "soft" !== b.type ? l(i, isNaN(b.curviness) ? 1 : b.curviness, !1, "thruBasic" === b.type, b.correlate, h) : m(i, b.type, j), this._segCount = this._beziers[d].length, this._timeRes) { var p = o(this._beziers, this._timeRes); this._length = p.length, this._lengths = p.lengths, this._segments = p.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (n = this._autoRotate) for (this._initialRotations = [], n[0] instanceof Array || (this._autoRotate = n = [n]), f = n.length; --f > -1;) { for (g = 0; 3 > g; g++)d = n[f][g], this._func[d] = "function" == typeof a[d] ? a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)] : !1; d = n[f][2], this._initialRotations[f] = (this._func[d] ? this._func[d].call(this._target) : this._target[d]) || 0, this._overwriteProps.push(d) } return this._startRatio = c.vars.runBackwards ? 1 : 0, !0 }, set: function (b) { var c, d, e, f, g, h, i, j, k, l, m = this._segCount, n = this._func, o = this._target, p = b !== this._startRatio; if (this._timeRes) { if (k = this._lengths, l = this._curSeg, b *= this._length, e = this._li, b > this._l2 && m - 1 > e) { for (j = m - 1; j > e && (this._l2 = k[++e]) <= b;); this._l1 = k[e - 1], this._li = e, this._curSeg = l = this._segments[e], this._s2 = l[this._s1 = this._si = 0] } else if (b < this._l1 && e > 0) { for (; e > 0 && (this._l1 = k[--e]) >= b;); 0 === e && b < this._l1 ? this._l1 = 0 : e++, this._l2 = k[e], this._li = e, this._curSeg = l = this._segments[e], this._s1 = l[(this._si = l.length - 1) - 1] || 0, this._s2 = l[this._si] } if (c = e, b -= this._l1, e = this._si, b > this._s2 && e < l.length - 1) { for (j = l.length - 1; j > e && (this._s2 = l[++e]) <= b;); this._s1 = l[e - 1], this._si = e } else if (b < this._s1 && e > 0) { for (; e > 0 && (this._s1 = l[--e]) >= b;); 0 === e && b < this._s1 ? this._s1 = 0 : e++, this._s2 = l[e], this._si = e } h = (e + (b - this._s1) / (this._s2 - this._s1)) * this._prec || 0 } else c = 0 > b ? 0 : b >= 1 ? m - 1 : m * b >> 0, h = (b - c * (1 / m)) * m; for (d = 1 - h, e = this._props.length; --e > -1;)f = this._props[e], g = this._beziers[f][c], i = (h * h * g.da + 3 * d * (h * g.ca + d * g.ba)) * h + g.a, this._mod[f] && (i = this._mod[f](i, o)), n[f] ? o[f](i) : o[f] = i; if (this._autoRotate) { var q, r, s, t, u, v, w, x = this._autoRotate; for (e = x.length; --e > -1;)f = x[e][2], v = x[e][3] || 0, w = x[e][4] === !0 ? 1 : a, g = this._beziers[x[e][0]], q = this._beziers[x[e][1]], g && q && (g = g[c], q = q[c], r = g.a + (g.b - g.a) * h, t = g.b + (g.c - g.b) * h, r += (t - r) * h, t += (g.c + (g.d - g.c) * h - t) * h, s = q.a + (q.b - q.a) * h, u = q.b + (q.c - q.b) * h, s += (u - s) * h, u += (q.c + (q.d - q.c) * h - u) * h, i = p ? Math.atan2(u - s, t - r) * w + v : this._initialRotations[e], this._mod[f] && (i = this._mod[f](i, o)), n[f] ? o[f](i) : o[f] = i) } } }), q = p.prototype; p.bezierThrough = l, p.cubicToQuadratic = i, p._autoCSS = !0, p.quadraticToCubic = function (a, b, c) { return new g(a, (2 * b + a) / 3, (2 * b + c) / 3, c) }, p._cssRegister = function () { var a = f.CSSPlugin; if (a) { var b = a._internals, c = b._parseToProxy, d = b._setPluginRatio, e = b.CSSPropTween; b._registerComplexSpecialProp("bezier", { parser: function (a, b, f, g, h, i) { b instanceof Array && (b = { values: b }), i = new p; var j, k, l, m = b.values, n = m.length - 1, o = [], q = {}; if (0 > n) return h; for (j = 0; n >= j; j++)l = c(a, m[j], g, h, i, n !== j), o[j] = l.end; for (k in b) q[k] = b[k]; return q.values = o, h = new e(a, "bezier", 0, 0, l.pt, 2), h.data = l, h.plugin = i, h.setRatio = d, 0 === q.autoRotate && (q.autoRotate = !0), !q.autoRotate || q.autoRotate instanceof Array || (j = q.autoRotate === !0 ? 0 : Number(q.autoRotate), q.autoRotate = null != l.end.left ? [["left", "top", "rotation", j, !1]] : null != l.end.x ? [["x", "y", "rotation", j, !1]] : !1), q.autoRotate && (g._transform || g._enableTransforms(!1), l.autoRotate = g._target._gsTransform, l.proxy.rotation = l.autoRotate.rotation || 0, g._overwriteProps.push("rotation")), i._onInitTween(l.proxy, q, g._tween), h } }) } }, q._mod = function (a) { for (var b, c = this._overwriteProps, d = c.length; --d > -1;)b = a[c[d]], b && "function" == typeof b && (this._mod[c[d]] = b) }, q._kill = function (a) { var b, c, d = this._props; for (b in this._beziers) if (b in a) for (delete this._beziers[b], delete this._func[b], c = d.length; --c > -1;)d[c] === b && d.splice(c, 1); if (d = this._autoRotate) for (c = d.length; --c > -1;)a[d[c][2]] && d.splice(c, 1); return this._super._kill.call(this, a) } }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (a, b) { var c, d, e, f, g = function () { a.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = g.prototype.setRatio }, h = _gsScope._gsDefine.globals, i = {}, j = g.prototype = new a("css"); j.constructor = g, g.version = "1.20.4", g.API = 2, g.defaultTransformPerspective = 0, g.defaultSkewType = "compensated", g.defaultSmoothOrigin = !0, j = "px", g.suffixMap = { top: j, right: j, bottom: j, left: j, width: j, height: j, fontSize: j, padding: j, margin: j, perspective: j, lineHeight: "" }; var k, l, m, n, o, p, q, r, s = /(?:\-|\.|\b)(\d|\.|e\-)+/g, t = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, u = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, v = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, w = /(?:\d|\-|\+|=|#|\.)*/g, x = /opacity *= *([^)]*)/i, y = /opacity:([^;]*)/i, z = /alpha\(opacity *=.+?\)/i, A = /^(rgb|hsl)/, B = /([A-Z])/g, C = /-([a-z])/gi, D = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, E = function (a, b) { return b.toUpperCase() }, F = /(?:Left|Right|Width)/i, G = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, H = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, I = /,(?=[^\)]*(?:\(|$))/gi, J = /[\s,\(]/i, K = Math.PI / 180, L = 180 / Math.PI, M = {}, N = { style: {} }, O = _gsScope.document || { createElement: function () { return N } }, P = function (a, b) { return O.createElementNS ? O.createElementNS(b || "http://www.w3.org/1999/xhtml", a) : O.createElement(a) }, Q = P("div"), R = P("img"), S = g._internals = { _specialProps: i }, T = (_gsScope.navigator || {}).userAgent || "", U = function () { var a = T.indexOf("Android"), b = P("a"); return m = -1 !== T.indexOf("Safari") && -1 === T.indexOf("Chrome") && (-1 === a || parseFloat(T.substr(a + 8, 2)) > 3), o = m && parseFloat(T.substr(T.indexOf("Version/") + 8, 2)) < 6, n = -1 !== T.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(T) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(T)) && (p = parseFloat(RegExp.$1)), b ? (b.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(b.style.opacity)) : !1 }(), V = function (a) { return x.test("string" == typeof a ? a : (a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 }, W = function (a) { _gsScope.console && console.log(a) }, X = "", Y = "", Z = function (a, b) { b = b || Q; var c, d, e = b.style; if (void 0 !== e[a]) return a; for (a = a.charAt(0).toUpperCase() + a.substr(1), c = ["O", "Moz", "ms", "Ms", "Webkit"], d = 5; --d > -1 && void 0 === e[c[d] + a];); return d >= 0 ? (Y = 3 === d ? "ms" : c[d], X = "-" + Y.toLowerCase() + "-", Y + a) : null }, $ = O.defaultView ? O.defaultView.getComputedStyle : function () { }, _ = g.getStyle = function (a, b, c, d, e) { var f; return U || "opacity" !== b ? (!d && a.style[b] ? f = a.style[b] : (c = c || $(a)) ? f = c[b] || c.getPropertyValue(b) || c.getPropertyValue(b.replace(B, "-$1").toLowerCase()) : a.currentStyle && (f = a.currentStyle[b]), null == e || f && "none" !== f && "auto" !== f && "auto auto" !== f ? f : e) : V(a) }, aa = S.convertToPixels = function (a, c, d, e, f) { if ("px" === e || !e && "lineHeight" !== c) return d; if ("auto" === e || !d) return 0; var h, i, j, k = F.test(c), l = a, m = Q.style, n = 0 > d, o = 1 === d; if (n && (d = -d), o && (d *= 100), "lineHeight" !== c || e) if ("%" === e && -1 !== c.indexOf("border")) h = d / 100 * (k ? a.clientWidth : a.clientHeight); else { if (m.cssText = "border:0 solid red;position:" + _(a, "position") + ";line-height:0;", "%" !== e && l.appendChild && "v" !== e.charAt(0) && "rem" !== e) m[k ? "borderLeftWidth" : "borderTopWidth"] = d + e; else { if (l = a.parentNode || O.body, -1 !== _(l, "display").indexOf("flex") && (m.position = "absolute"), i = l._gsCache, j = b.ticker.frame, i && k && i.time === j) return i.width * d / 100; m[k ? "width" : "height"] = d + e } l.appendChild(Q), h = parseFloat(Q[k ? "offsetWidth" : "offsetHeight"]), l.removeChild(Q), k && "%" === e && g.cacheWidths !== !1 && (i = l._gsCache = l._gsCache || {}, i.time = j, i.width = h / d * 100), 0 !== h || f || (h = aa(a, c, d, e, !0)) } else i = $(a).lineHeight, a.style.lineHeight = d, h = parseFloat($(a).lineHeight), a.style.lineHeight = i; return o && (h /= 100), n ? -h : h }, ba = S.calculateOffset = function (a, b, c) { if ("absolute" !== _(a, "position", c)) return 0; var d = "left" === b ? "Left" : "Top", e = _(a, "margin" + d, c); return a["offset" + d] - (aa(a, b, parseFloat(e), e.replace(w, "")) || 0) }, ca = function (a, b) { var c, d, e, f = {}; if (b = b || $(a, null)) if (c = b.length) for (; --c > -1;)e = b[c], (-1 === e.indexOf("-transform") || Da === e) && (f[e.replace(C, E)] = b.getPropertyValue(e)); else for (c in b) (-1 === c.indexOf("Transform") || Ca === c) && (f[c] = b[c]); else if (b = a.currentStyle || a.style) for (c in b) "string" == typeof c && void 0 === f[c] && (f[c.replace(C, E)] = b[c]); return U || (f.opacity = V(a)), d = Ra(a, b, !1), f.rotation = d.rotation, f.skewX = d.skewX, f.scaleX = d.scaleX, f.scaleY = d.scaleY, f.x = d.x, f.y = d.y, Fa && (f.z = d.z, f.rotationX = d.rotationX, f.rotationY = d.rotationY, f.scaleZ = d.scaleZ), f.filters && delete f.filters, f }, da = function (a, b, c, d, e) { var f, g, h, i = {}, j = a.style; for (g in c) "cssText" !== g && "length" !== g && isNaN(g) && (b[g] !== (f = c[g]) || e && e[g]) && -1 === g.indexOf("Origin") && ("number" == typeof f || "string" == typeof f) && (i[g] = "auto" !== f || "left" !== g && "top" !== g ? "" !== f && "auto" !== f && "none" !== f || "string" != typeof b[g] || "" === b[g].replace(v, "") ? f : 0 : ba(a, g), void 0 !== j[g] && (h = new sa(j, g, j[g], h))); if (d) for (g in d) "className" !== g && (i[g] = d[g]); return { difs: i, firstMPT: h } }, ea = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, fa = ["marginLeft", "marginRight", "marginTop", "marginBottom"], ga = function (a, b, c) { if ("svg" === (a.nodeName + "").toLowerCase()) return (c || $(a))[b] || 0; if (a.getCTM && Oa(a)) return a.getBBox()[b] || 0; var d = parseFloat("width" === b ? a.offsetWidth : a.offsetHeight), e = ea[b], f = e.length; for (c = c || $(a, null); --f > -1;)d -= parseFloat(_(a, "padding" + e[f], c, !0)) || 0, d -= parseFloat(_(a, "border" + e[f] + "Width", c, !0)) || 0; return d }, ha = function (a, b) { if ("contain" === a || "auto" === a || "auto auto" === a) return a + " "; (null == a || "" === a) && (a = "0 0"); var c, d = a.split(" "), e = -1 !== a.indexOf("left") ? "0%" : -1 !== a.indexOf("right") ? "100%" : d[0], f = -1 !== a.indexOf("top") ? "0%" : -1 !== a.indexOf("bottom") ? "100%" : d[1]; if (d.length > 3 && !b) { for (d = a.split(", ").join(",").split(","), a = [], c = 0; c < d.length; c++)a.push(ha(d[c])); return a.join(",") } return null == f ? f = "center" === e ? "50%" : "0" : "center" === f && (f = "50%"), ("center" === e || isNaN(parseFloat(e)) && -1 === (e + "").indexOf("=")) && (e = "50%"), a = e + " " + f + (d.length > 2 ? " " + d[2] : ""), b && (b.oxp = -1 !== e.indexOf("%"), b.oyp = -1 !== f.indexOf("%"), b.oxr = "=" === e.charAt(1), b.oyr = "=" === f.charAt(1), b.ox = parseFloat(e.replace(v, "")), b.oy = parseFloat(f.replace(v, "")), b.v = a), b || a }, ia = function (a, b) { return "function" == typeof a && (a = a(r, q)), "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) : parseFloat(a) - parseFloat(b) || 0 }, ja = function (a, b) { return "function" == typeof a && (a = a(r, q)), null == a ? b : "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) + b : parseFloat(a) || 0 }, ka = function (a, b, c, d) { var e, f, g, h, i, j = 1e-6; return "function" == typeof a && (a = a(r, q)), null == a ? h = b : "number" == typeof a ? h = a : (e = 360, f = a.split("_"), i = "=" === a.charAt(1), g = (i ? parseInt(a.charAt(0) + "1", 10) * parseFloat(f[0].substr(2)) : parseFloat(f[0])) * (-1 === a.indexOf("rad") ? 1 : L) - (i ? 0 : b), f.length && (d && (d[c] = b + g), -1 !== a.indexOf("short") && (g %= e, g !== g % (e / 2) && (g = 0 > g ? g + e : g - e)), -1 !== a.indexOf("_cw") && 0 > g ? g = (g + 9999999999 * e) % e - (g / e | 0) * e : -1 !== a.indexOf("ccw") && g > 0 && (g = (g - 9999999999 * e) % e - (g / e | 0) * e)), h = b + g), j > h && h > -j && (h = 0), h }, la = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, ma = function (a, b, c) { return a = 0 > a ? a + 1 : a > 1 ? a - 1 : a, 255 * (1 > 6 * a ? b + (c - b) * a * 6 : .5 > a ? c : 2 > 3 * a ? b + (c - b) * (2 / 3 - a) * 6 : b) + .5 | 0 }, na = g.parseColor = function (a, b) { var c, d, e, f, g, h, i, j, k, l, m; if (a) if ("number" == typeof a) c = [a >> 16, a >> 8 & 255, 255 & a]; else { if ("," === a.charAt(a.length - 1) && (a = a.substr(0, a.length - 1)), la[a]) c = la[a]; else if ("#" === a.charAt(0)) 4 === a.length && (d = a.charAt(1), e = a.charAt(2), f = a.charAt(3), a = "#" + d + d + e + e + f + f), a = parseInt(a.substr(1), 16), c = [a >> 16, a >> 8 & 255, 255 & a]; else if ("hsl" === a.substr(0, 3)) if (c = m = a.match(s), b) { if (-1 !== a.indexOf("=")) return a.match(t) } else g = Number(c[0]) % 360 / 360, h = Number(c[1]) / 100, i = Number(c[2]) / 100, e = .5 >= i ? i * (h + 1) : i + h - i * h, d = 2 * i - e, c.length > 3 && (c[3] = Number(c[3])), c[0] = ma(g + 1 / 3, d, e), c[1] = ma(g, d, e), c[2] = ma(g - 1 / 3, d, e); else c = a.match(s) || la.transparent; c[0] = Number(c[0]), c[1] = Number(c[1]), c[2] = Number(c[2]), c.length > 3 && (c[3] = Number(c[3])) } else c = la.black; return b && !m && (d = c[0] / 255, e = c[1] / 255, f = c[2] / 255, j = Math.max(d, e, f), k = Math.min(d, e, f), i = (j + k) / 2, j === k ? g = h = 0 : (l = j - k, h = i > .5 ? l / (2 - j - k) : l / (j + k), g = j === d ? (e - f) / l + (f > e ? 6 : 0) : j === e ? (f - d) / l + 2 : (d - e) / l + 4, g *= 60), c[0] = g + .5 | 0, c[1] = 100 * h + .5 | 0, c[2] = 100 * i + .5 | 0), c }, oa = function (a, b) { var c, d, e, f = a.match(pa) || [], g = 0, h = ""; if (!f.length) return a; for (c = 0; c < f.length; c++)d = f[c], e = a.substr(g, a.indexOf(d, g) - g), g += e.length + d.length, d = na(d, b), 3 === d.length && d.push(1), h += e + (b ? "hsla(" + d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : "rgba(" + d.join(",")) + ")"; return h + a.substr(g) }, pa = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (j in la) pa += "|" + j + "\\b"; pa = new RegExp(pa + ")", "gi"), g.colorStringFilter = function (a) { var b, c = a[0] + " " + a[1]; pa.test(c) && (b = -1 !== c.indexOf("hsl(") || -1 !== c.indexOf("hsla("), a[0] = oa(a[0], b), a[1] = oa(a[1], b)), pa.lastIndex = 0 }, b.defaultStringFilter || (b.defaultStringFilter = g.colorStringFilter); var qa = function (a, b, c, d) { if (null == a) return function (a) { return a }; var e, f = b ? (a.match(pa) || [""])[0] : "", g = a.split(f).join("").match(u) || [], h = a.substr(0, a.indexOf(g[0])), i = ")" === a.charAt(a.length - 1) ? ")" : "", j = -1 !== a.indexOf(" ") ? " " : ",", k = g.length, l = k > 0 ? g[0].replace(s, "") : ""; return k ? e = b ? function (a) { var b, m, n, o; if ("number" == typeof a) a += l; else if (d && I.test(a)) { for (o = a.replace(I, "|").split("|"), n = 0; n < o.length; n++)o[n] = e(o[n]); return o.join(",") } if (b = (a.match(pa) || [f])[0], m = a.split(b).join("").match(u) || [], n = m.length, k > n--) for (; ++n < k;)m[n] = c ? m[(n - 1) / 2 | 0] : g[n]; return h + m.join(j) + j + b + i + (-1 !== a.indexOf("inset") ? " inset" : "") } : function (a) { var b, f, m; if ("number" == typeof a) a += l; else if (d && I.test(a)) { for (f = a.replace(I, "|").split("|"), m = 0; m < f.length; m++)f[m] = e(f[m]); return f.join(",") } if (b = a.match(u) || [], m = b.length, k > m--) for (; ++m < k;)b[m] = c ? b[(m - 1) / 2 | 0] : g[m]; return h + b.join(j) + i } : function (a) { return a } }, ra = function (a) { return a = a.split(","), function (b, c, d, e, f, g, h) { var i, j = (c + "").split(" "); for (h = {}, i = 0; 4 > i; i++)h[a[i]] = j[i] = j[i] || j[(i - 1) / 2 >> 0]; return e.parse(b, h, f, g) } }, sa = (S._setPluginRatio = function (a) { this.plugin.setRatio(a); for (var b, c, d, e, f, g = this.data, h = g.proxy, i = g.firstMPT, j = 1e-6; i;)b = h[i.v], i.r ? b = Math.round(b) : j > b && b > -j && (b = 0), i.t[i.p] = b, i = i._next; if (g.autoRotate && (g.autoRotate.rotation = g.mod ? g.mod(h.rotation, this.t) : h.rotation), 1 === a || 0 === a) for (i = g.firstMPT, f = 1 === a ? "e" : "b"; i;) { if (c = i.t, c.type) { if (1 === c.type) { for (e = c.xs0 + c.s + c.xs1, d = 1; d < c.l; d++)e += c["xn" + d] + c["xs" + (d + 1)]; c[f] = e } } else c[f] = c.s + c.xs0; i = i._next } }, function (a, b, c, d, e) { this.t = a, this.p = b, this.v = c, this.r = e, d && (d._prev = this, this._next = d) }), ta = (S._parseToProxy = function (a, b, c, d, e, f) { var g, h, i, j, k, l = d, m = {}, n = {}, o = c._transform, p = M; for (c._transform = null, M = b, d = k = c.parse(a, b, d, e), M = p, f && (c._transform = o, l && (l._prev = null, l._prev && (l._prev._next = null))); d && d !== l;) { if (d.type <= 1 && (h = d.p, n[h] = d.s + d.c, m[h] = d.s, f || (j = new sa(d, "s", h, j, d.r), d.c = 0), 1 === d.type)) for (g = d.l; --g > 0;)i = "xn" + g, h = d.p + "_" + i, n[h] = d.data[i], m[h] = d[i], f || (j = new sa(d, i, h, j, d.rxp[i])); d = d._next } return { proxy: m, end: n, firstMPT: j, pt: k } }, S.CSSPropTween = function (a, b, d, e, g, h, i, j, k, l, m) { this.t = a, this.p = b, this.s = d, this.c = e, this.n = i || b, a instanceof ta || f.push(this.n), this.r = j, this.type = h || 0, k && (this.pr = k, c = !0), this.b = void 0 === l ? d : l, this.e = void 0 === m ? d + e : m, g && (this._next = g, g._prev = this) }), ua = function (a, b, c, d, e, f) { var g = new ta(a, b, c, d - c, e, -1, f); return g.b = c, g.e = g.xs0 = d, g }, va = g.parseComplex = function (a, b, c, d, e, f, h, i, j, l) { c = c || f || "", "function" == typeof d && (d = d(r, q)), h = new ta(a, b, 0, 0, h, l ? 2 : 1, null, !1, i, c, d), d += "", e && pa.test(d + c) && (d = [c, d], g.colorStringFilter(d), c = d[0], d = d[1]); var m, n, o, p, u, v, w, x, y, z, A, B, C, D = c.split(", ").join(",").split(" "), E = d.split(", ").join(",").split(" "), F = D.length, G = k !== !1; for ((-1 !== d.indexOf(",") || -1 !== c.indexOf(",")) && (-1 !== (d + c).indexOf("rgb") || -1 !== (d + c).indexOf("hsl") ? (D = D.join(" ").replace(I, ", ").split(" "), E = E.join(" ").replace(I, ", ").split(" ")) : (D = D.join(" ").split(",").join(", ").split(" "), E = E.join(" ").split(",").join(", ").split(" ")), F = D.length), F !== E.length && (D = (f || "").split(" "), F = D.length), h.plugin = j, h.setRatio = l, pa.lastIndex = 0, m = 0; F > m; m++)if (p = D[m], u = E[m], x = parseFloat(p), x || 0 === x) h.appendXtra("", x, ia(u, x), u.replace(t, ""), G && -1 !== u.indexOf("px"), !0); else if (e && pa.test(p)) B = u.indexOf(")") + 1, B = ")" + (B ? u.substr(B) : ""), C = -1 !== u.indexOf("hsl") && U, z = u, p = na(p, C), u = na(u, C), y = p.length + u.length > 6, y && !U && 0 === u[3] ? (h["xs" + h.l] += h.l ? " transparent" : "transparent", h.e = h.e.split(E[m]).join("transparent")) : (U || (y = !1), C ? h.appendXtra(z.substr(0, z.indexOf("hsl")) + (y ? "hsla(" : "hsl("), p[0], ia(u[0], p[0]), ",", !1, !0).appendXtra("", p[1], ia(u[1], p[1]), "%,", !1).appendXtra("", p[2], ia(u[2], p[2]), y ? "%," : "%" + B, !1) : h.appendXtra(z.substr(0, z.indexOf("rgb")) + (y ? "rgba(" : "rgb("), p[0], u[0] - p[0], ",", !0, !0).appendXtra("", p[1], u[1] - p[1], ",", !0).appendXtra("", p[2], u[2] - p[2], y ? "," : B, !0), y && (p = p.length < 4 ? 1 : p[3], h.appendXtra("", p, (u.length < 4 ? 1 : u[3]) - p, B, !1))), pa.lastIndex = 0; else if (v = p.match(s)) { if (w = u.match(t), !w || w.length !== v.length) return h; for (o = 0, n = 0; n < v.length; n++)A = v[n], z = p.indexOf(A, o), h.appendXtra(p.substr(o, z - o), Number(A), ia(w[n], A), "", G && "px" === p.substr(z + A.length, 2), 0 === n), o = z + A.length; h["xs" + h.l] += p.substr(o) } else h["xs" + h.l] += h.l || h["xs" + h.l] ? " " + u : u; if (-1 !== d.indexOf("=") && h.data) { for (B = h.xs0 + h.data.s, m = 1; m < h.l; m++)B += h["xs" + m] + h.data["xn" + m]; h.e = B + h["xs" + m] } return h.l || (h.type = -1, h.xs0 = h.e), h.xfirst || h }, wa = 9; for (j = ta.prototype, j.l = j.pr = 0; --wa > 0;)j["xn" + wa] = 0, j["xs" + wa] = ""; j.xs0 = "", j._next = j._prev = j.xfirst = j.data = j.plugin = j.setRatio = j.rxp = null, j.appendXtra = function (a, b, c, d, e, f) { var g = this, h = g.l; return g["xs" + h] += f && (h || g["xs" + h]) ? " " + a : a || "", c || 0 === h || g.plugin ? (g.l++, g.type = g.setRatio ? 2 : 1, g["xs" + g.l] = d || "", h > 0 ? (g.data["xn" + h] = b + c, g.rxp["xn" + h] = e, g["xn" + h] = b, g.plugin || (g.xfirst = new ta(g, "xn" + h, b, c, g.xfirst || g, 0, g.n, e, g.pr), g.xfirst.xs0 = 0), g) : (g.data = { s: b + c }, g.rxp = {}, g.s = b, g.c = c, g.r = e, g)) : (g["xs" + h] += b + (d || ""), g) }; var xa = function (a, b) { b = b || {}, this.p = b.prefix ? Z(a) || a : a, i[a] = i[this.p] = this, this.format = b.formatter || qa(b.defaultValue, b.color, b.collapsible, b.multi), b.parser && (this.parse = b.parser), this.clrs = b.color, this.multi = b.multi, this.keyword = b.keyword, this.dflt = b.defaultValue, this.pr = b.priority || 0 }, ya = S._registerComplexSpecialProp = function (a, b, c) { "object" != typeof b && (b = { parser: c }); var d, e, f = a.split(","), g = b.defaultValue; for (c = c || [g], d = 0; d < f.length; d++)b.prefix = 0 === d && b.prefix, b.defaultValue = c[d] || g, e = new xa(f[d], b) }, za = S._registerPluginProp = function (a) { if (!i[a]) { var b = a.charAt(0).toUpperCase() + a.substr(1) + "Plugin"; ya(a, { parser: function (a, c, d, e, f, g, j) { var k = h.com.greensock.plugins[b]; return k ? (k._cssRegister(), i[d].parse(a, c, d, e, f, g, j)) : (W("Error: " + b + " js file not loaded."), f) } }) } }; j = xa.prototype, j.parseComplex = function (a, b, c, d, e, f) { var g, h, i, j, k, l, m = this.keyword; if (this.multi && (I.test(c) || I.test(b) ? (h = b.replace(I, "|").split("|"), i = c.replace(I, "|").split("|")) : m && (h = [b], i = [c])), i) { for (j = i.length > h.length ? i.length : h.length, g = 0; j > g; g++)b = h[g] = h[g] || this.dflt, c = i[g] = i[g] || this.dflt, m && (k = b.indexOf(m), l = c.indexOf(m), k !== l && (-1 === l ? h[g] = h[g].split(m).join("") : -1 === k && (h[g] += " " + m))); b = h.join(", "), c = i.join(", ") } return va(a, this.p, b, c, this.clrs, this.dflt, d, this.pr, e, f) }, j.parse = function (a, b, c, d, f, g, h) { return this.parseComplex(a.style, this.format(_(a, this.p, e, !1, this.dflt)), this.format(b), f, g) }, g.registerSpecialProp = function (a, b, c) { ya(a, { parser: function (a, d, e, f, g, h, i) { var j = new ta(a, e, 0, 0, g, 2, e, !1, c); return j.plugin = h, j.setRatio = b(a, d, f._tween, e), j }, priority: c }) }, g.useSVGTransformAttr = !0; var Aa, Ba = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), Ca = Z("transform"), Da = X + "transform", Ea = Z("transformOrigin"), Fa = null !== Z("perspective"), Ga = S.Transform = function () { this.perspective = parseFloat(g.defaultTransformPerspective) || 0, this.force3D = g.defaultForce3D !== !1 && Fa ? g.defaultForce3D || "auto" : !1 }, Ha = _gsScope.SVGElement, Ia = function (a, b, c) { var d, e = O.createElementNS("http://www.w3.org/2000/svg", a), f = /([a-z])([A-Z])/g; for (d in c) e.setAttributeNS(null, d.replace(f, "$1-$2").toLowerCase(), c[d]); return b.appendChild(e), e }, Ja = O.documentElement || {}, Ka = function () { var a, b, c, d = p || /Android/i.test(T) && !_gsScope.chrome; return O.createElementNS && !d && (a = Ia("svg", Ja), b = Ia("rect", a, { width: 100, height: 50, x: 100 }), c = b.getBoundingClientRect().width, b.style[Ea] = "50% 50%", b.style[Ca] = "scaleX(0.5)", d = c === b.getBoundingClientRect().width && !(n && Fa), Ja.removeChild(a)), d }(), La = function (a, b, c, d, e, f) { var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v = a._gsTransform, w = Qa(a, !0); v && (t = v.xOrigin, u = v.yOrigin), (!d || (h = d.split(" ")).length < 2) && (n = a.getBBox(), 0 === n.x && 0 === n.y && n.width + n.height === 0 && (n = { x: parseFloat(a.hasAttribute("x") ? a.getAttribute("x") : a.hasAttribute("cx") ? a.getAttribute("cx") : 0) || 0, y: parseFloat(a.hasAttribute("y") ? a.getAttribute("y") : a.hasAttribute("cy") ? a.getAttribute("cy") : 0) || 0, width: 0, height: 0 }), b = ha(b).split(" "), h = [(-1 !== b[0].indexOf("%") ? parseFloat(b[0]) / 100 * n.width : parseFloat(b[0])) + n.x, (-1 !== b[1].indexOf("%") ? parseFloat(b[1]) / 100 * n.height : parseFloat(b[1])) + n.y]), c.xOrigin = k = parseFloat(h[0]), c.yOrigin = l = parseFloat(h[1]), d && w !== Pa && (m = w[0], n = w[1], o = w[2], p = w[3], q = w[4], r = w[5], s = m * p - n * o, s && (i = k * (p / s) + l * (-o / s) + (o * r - p * q) / s, j = k * (-n / s) + l * (m / s) - (m * r - n * q) / s, k = c.xOrigin = h[0] = i, l = c.yOrigin = h[1] = j)), v && (f && (c.xOffset = v.xOffset, c.yOffset = v.yOffset, v = c), e || e !== !1 && g.defaultSmoothOrigin !== !1 ? (i = k - t, j = l - u, v.xOffset += i * w[0] + j * w[2] - i, v.yOffset += i * w[1] + j * w[3] - j) : v.xOffset = v.yOffset = 0), f || a.setAttribute("data-svg-origin", h.join(" ")) }, Ma = function (a) { var b, c = P("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), d = this.parentNode, e = this.nextSibling, f = this.style.cssText; if (Ja.appendChild(c), c.appendChild(this), this.style.display = "block", a) try { b = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ma } catch (g) { } else this._originalGetBBox && (b = this._originalGetBBox()); return e ? d.insertBefore(this, e) : d.appendChild(this), Ja.removeChild(c), this.style.cssText = f, b }, Na = function (a) { try { return a.getBBox() } catch (b) { return Ma.call(a, !0) } }, Oa = function (a) { return !(!Ha || !a.getCTM || a.parentNode && !a.ownerSVGElement || !Na(a)) }, Pa = [1, 0, 0, 1, 0, 0], Qa = function (a, b) { var c, d, e, f, g, h, i = a._gsTransform || new Ga, j = 1e5, k = a.style; if (Ca ? d = _(a, Da, null, !0) : a.currentStyle && (d = a.currentStyle.filter.match(G), d = d && 4 === d.length ? [d[0].substr(4), Number(d[2].substr(4)), Number(d[1].substr(4)), d[3].substr(4), i.x || 0, i.y || 0].join(",") : ""), c = !d || "none" === d || "matrix(1, 0, 0, 1, 0, 0)" === d, !Ca || !(h = !$(a) || "none" === $(a).display) && a.parentNode || (h && (f = k.display, k.display = "block"), a.parentNode || (g = 1, Ja.appendChild(a)), d = _(a, Da, null, !0), c = !d || "none" === d || "matrix(1, 0, 0, 1, 0, 0)" === d, f ? k.display = f : h && Va(k, "display"), g && Ja.removeChild(a)), (i.svg || a.getCTM && Oa(a)) && (c && -1 !== (k[Ca] + "").indexOf("matrix") && (d = k[Ca], c = 0), e = a.getAttribute("transform"), c && e && (e = a.transform.baseVal.consolidate().matrix, d = "matrix(" + e.a + "," + e.b + "," + e.c + "," + e.d + "," + e.e + "," + e.f + ")", c = 0)), c) return Pa; for (e = (d || "").match(s) || [], wa = e.length; --wa > -1;)f = Number(e[wa]), e[wa] = (g = f - (f |= 0)) ? (g * j + (0 > g ? -.5 : .5) | 0) / j + f : f; return b && e.length > 6 ? [e[0], e[1], e[4], e[5], e[12], e[13]] : e }, Ra = S.getTransform = function (a, c, d, e) { if (a._gsTransform && d && !e) return a._gsTransform; var f, h, i, j, k, l, m = d ? a._gsTransform || new Ga : new Ga, n = m.scaleX < 0, o = 2e-5, p = 1e5, q = Fa ? parseFloat(_(a, Ea, c, !1, "0 0 0").split(" ")[2]) || m.zOrigin || 0 : 0, r = parseFloat(g.defaultTransformPerspective) || 0; if (m.svg = !(!a.getCTM || !Oa(a)), m.svg && (La(a, _(a, Ea, c, !1, "50% 50%") + "", m, a.getAttribute("data-svg-origin")), Aa = g.useSVGTransformAttr || Ka), f = Qa(a), f !== Pa) { if (16 === f.length) { var s, t, u, v, w, x = f[0], y = f[1], z = f[2], A = f[3], B = f[4], C = f[5], D = f[6], E = f[7], F = f[8], G = f[9], H = f[10], I = f[12], J = f[13], K = f[14], M = f[11], N = Math.atan2(D, H); m.zOrigin && (K = -m.zOrigin, I = F * K - f[12], J = G * K - f[13], K = H * K + m.zOrigin - f[14]), m.rotationX = N * L, N && (v = Math.cos(-N), w = Math.sin(-N), s = B * v + F * w, t = C * v + G * w, u = D * v + H * w, F = B * -w + F * v, G = C * -w + G * v, H = D * -w + H * v, M = E * -w + M * v, B = s, C = t, D = u), N = Math.atan2(-z, H), m.rotationY = N * L, N && (v = Math.cos(-N), w = Math.sin(-N), s = x * v - F * w, t = y * v - G * w, u = z * v - H * w, G = y * w + G * v, H = z * w + H * v, M = A * w + M * v, x = s, y = t, z = u), N = Math.atan2(y, x), m.rotation = N * L, N && (v = Math.cos(N), w = Math.sin(N), s = x * v + y * w, t = B * v + C * w, u = F * v + G * w, y = y * v - x * w, C = C * v - B * w, G = G * v - F * w, x = s, B = t, F = u), m.rotationX && Math.abs(m.rotationX) + Math.abs(m.rotation) > 359.9 && (m.rotationX = m.rotation = 0, m.rotationY = 180 - m.rotationY), N = Math.atan2(B, C), m.scaleX = (Math.sqrt(x * x + y * y + z * z) * p + .5 | 0) / p, m.scaleY = (Math.sqrt(C * C + D * D) * p + .5 | 0) / p, m.scaleZ = (Math.sqrt(F * F + G * G + H * H) * p + .5 | 0) / p, x /= m.scaleX, B /= m.scaleY, y /= m.scaleX, C /= m.scaleY, Math.abs(N) > o ? (m.skewX = N * L, B = 0, "simple" !== m.skewType && (m.scaleY *= 1 / Math.cos(N))) : m.skewX = 0, m.perspective = M ? 1 / (0 > M ? -M : M) : 0, m.x = I, m.y = J, m.z = K, m.svg && (m.x -= m.xOrigin - (m.xOrigin * x - m.yOrigin * B), m.y -= m.yOrigin - (m.yOrigin * y - m.xOrigin * C)) } else if (!Fa || e || !f.length || m.x !== f[4] || m.y !== f[5] || !m.rotationX && !m.rotationY) { var O = f.length >= 6, P = O ? f[0] : 1, Q = f[1] || 0, R = f[2] || 0, S = O ? f[3] : 1; m.x = f[4] || 0, m.y = f[5] || 0, i = Math.sqrt(P * P + Q * Q), j = Math.sqrt(S * S + R * R), k = P || Q ? Math.atan2(Q, P) * L : m.rotation || 0, l = R || S ? Math.atan2(R, S) * L + k : m.skewX || 0, m.scaleX = i, m.scaleY = j, m.rotation = k, m.skewX = l, Fa && (m.rotationX = m.rotationY = m.z = 0, m.perspective = r, m.scaleZ = 1), m.svg && (m.x -= m.xOrigin - (m.xOrigin * P + m.yOrigin * R), m.y -= m.yOrigin - (m.xOrigin * Q + m.yOrigin * S)) } Math.abs(m.skewX) > 90 && Math.abs(m.skewX) < 270 && (n ? (m.scaleX *= -1, m.skewX += m.rotation <= 0 ? 180 : -180, m.rotation += m.rotation <= 0 ? 180 : -180) : (m.scaleY *= -1, m.skewX += m.skewX <= 0 ? 180 : -180)), m.zOrigin = q; for (h in m) m[h] < o && m[h] > -o && (m[h] = 0) } return d && (a._gsTransform = m, m.svg && (Aa && a.style[Ca] ? b.delayedCall(.001, function () { Va(a.style, Ca) }) : !Aa && a.getAttribute("transform") && b.delayedCall(.001, function () { a.removeAttribute("transform") }))), m }, Sa = function (a) { var b, c, d = this.data, e = -d.rotation * K, f = e + d.skewX * K, g = 1e5, h = (Math.cos(e) * d.scaleX * g | 0) / g, i = (Math.sin(e) * d.scaleX * g | 0) / g, j = (Math.sin(f) * -d.scaleY * g | 0) / g, k = (Math.cos(f) * d.scaleY * g | 0) / g, l = this.t.style, m = this.t.currentStyle; if (m) { c = i, i = -j, j = -c, b = m.filter, l.filter = ""; var n, o, q = this.t.offsetWidth, r = this.t.offsetHeight, s = "absolute" !== m.position, t = "progid:DXImageTransform.Microsoft.Matrix(M11=" + h + ", M12=" + i + ", M21=" + j + ", M22=" + k, u = d.x + q * d.xPercent / 100, v = d.y + r * d.yPercent / 100; if (null != d.ox && (n = (d.oxp ? q * d.ox * .01 : d.ox) - q / 2, o = (d.oyp ? r * d.oy * .01 : d.oy) - r / 2, u += n - (n * h + o * i), v += o - (n * j + o * k)), s ? (n = q / 2, o = r / 2, t += ", Dx=" + (n - (n * h + o * i) + u) + ", Dy=" + (o - (n * j + o * k) + v) + ")") : t += ", sizingMethod='auto expand')", -1 !== b.indexOf("DXImageTransform.Microsoft.Matrix(") ? l.filter = b.replace(H, t) : l.filter = t + " " + b, (0 === a || 1 === a) && 1 === h && 0 === i && 0 === j && 1 === k && (s && -1 === t.indexOf("Dx=0, Dy=0") || x.test(b) && 100 !== parseFloat(RegExp.$1) || -1 === b.indexOf(b.indexOf("Alpha")) && l.removeAttribute("filter")), !s) { var y, z, A, B = 8 > p ? 1 : -1; for (n = d.ieOffsetX || 0, o = d.ieOffsetY || 0, d.ieOffsetX = Math.round((q - ((0 > h ? -h : h) * q + (0 > i ? -i : i) * r)) / 2 + u), d.ieOffsetY = Math.round((r - ((0 > k ? -k : k) * r + (0 > j ? -j : j) * q)) / 2 + v), wa = 0; 4 > wa; wa++)z = fa[wa], y = m[z], c = -1 !== y.indexOf("px") ? parseFloat(y) : aa(this.t, z, parseFloat(y), y.replace(w, "")) || 0, A = c !== d[z] ? 2 > wa ? -d.ieOffsetX : -d.ieOffsetY : 2 > wa ? n - d.ieOffsetX : o - d.ieOffsetY, l[z] = (d[z] = Math.round(c - A * (0 === wa || 2 === wa ? 1 : B))) + "px" } } }, Ta = S.set3DTransformRatio = S.setTransformRatio = function (a) { var b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z = this.data, A = this.t.style, B = z.rotation, C = z.rotationX, D = z.rotationY, E = z.scaleX, F = z.scaleY, G = z.scaleZ, H = z.x, I = z.y, J = z.z, L = z.svg, M = z.perspective, N = z.force3D, O = z.skewY, P = z.skewX; if (O && (P += O, B += O), ((1 === a || 0 === a) && "auto" === N && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !N) && !J && !M && !D && !C && 1 === G || Aa && L || !Fa) return void (B || P || L ? (B *= K, x = P * K, y = 1e5, c = Math.cos(B) * E, f = Math.sin(B) * E, d = Math.sin(B - x) * -F, g = Math.cos(B - x) * F, x && "simple" === z.skewType && (b = Math.tan(x - O * K), b = Math.sqrt(1 + b * b), d *= b, g *= b, O && (b = Math.tan(O * K), b = Math.sqrt(1 + b * b), c *= b, f *= b)), L && (H += z.xOrigin - (z.xOrigin * c + z.yOrigin * d) + z.xOffset, I += z.yOrigin - (z.xOrigin * f + z.yOrigin * g) + z.yOffset, Aa && (z.xPercent || z.yPercent) && (q = this.t.getBBox(), H += .01 * z.xPercent * q.width, I += .01 * z.yPercent * q.height), q = 1e-6, q > H && H > -q && (H = 0), q > I && I > -q && (I = 0)), u = (c * y | 0) / y + "," + (f * y | 0) / y + "," + (d * y | 0) / y + "," + (g * y | 0) / y + "," + H + "," + I + ")", L && Aa ? this.t.setAttribute("transform", "matrix(" + u) : A[Ca] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + u) : A[Ca] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + E + ",0,0," + F + "," + H + "," + I + ")"); if (n && (q = 1e-4, q > E && E > -q && (E = G = 2e-5), q > F && F > -q && (F = G = 2e-5), !M || z.z || z.rotationX || z.rotationY || (M = 0)), B || P) B *= K, r = c = Math.cos(B), s = f = Math.sin(B), P && (B -= P * K, r = Math.cos(B), s = Math.sin(B), "simple" === z.skewType && (b = Math.tan((P - O) * K), b = Math.sqrt(1 + b * b), r *= b, s *= b, z.skewY && (b = Math.tan(O * K), b = Math.sqrt(1 + b * b), c *= b, f *= b))), d = -s, g = r; else { if (!(D || C || 1 !== G || M || L)) return void (A[Ca] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) translate3d(" : "translate3d(") + H + "px," + I + "px," + J + "px)" + (1 !== E || 1 !== F ? " scale(" + E + "," + F + ")" : "")); c = g = 1, d = f = 0 } k = 1, e = h = i = j = l = m = 0, o = M ? -1 / M : 0, p = z.zOrigin, q = 1e-6, v = ",", w = "0", B = D * K, B && (r = Math.cos(B), s = Math.sin(B), i = -s, l = o * -s, e = c * s, h = f * s, k = r, o *= r, c *= r, f *= r), B = C * K, B && (r = Math.cos(B), s = Math.sin(B), b = d * r + e * s, t = g * r + h * s, j = k * s, m = o * s, e = d * -s + e * r, h = g * -s + h * r, k *= r, o *= r, d = b, g = t), 1 !== G && (e *= G, h *= G, k *= G, o *= G), 1 !== F && (d *= F, g *= F, j *= F, m *= F), 1 !== E && (c *= E, f *= E, i *= E, l *= E), (p || L) && (p && (H += e * -p, I += h * -p, J += k * -p + p), L && (H += z.xOrigin - (z.xOrigin * c + z.yOrigin * d) + z.xOffset, I += z.yOrigin - (z.xOrigin * f + z.yOrigin * g) + z.yOffset), q > H && H > -q && (H = w), q > I && I > -q && (I = w), q > J && J > -q && (J = 0)), u = z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix3d(" : "matrix3d(", u += (q > c && c > -q ? w : c) + v + (q > f && f > -q ? w : f) + v + (q > i && i > -q ? w : i), u += v + (q > l && l > -q ? w : l) + v + (q > d && d > -q ? w : d) + v + (q > g && g > -q ? w : g), C || D || 1 !== G ? (u += v + (q > j && j > -q ? w : j) + v + (q > m && m > -q ? w : m) + v + (q > e && e > -q ? w : e), u += v + (q > h && h > -q ? w : h) + v + (q > k && k > -q ? w : k) + v + (q > o && o > -q ? w : o) + v) : u += ",0,0,0,0,1,0,", u += H + v + I + v + J + v + (M ? 1 + -J / M : 1) + ")", A[Ca] = u }; j = Ga.prototype, j.x = j.y = j.z = j.skewX = j.skewY = j.rotation = j.rotationX = j.rotationY = j.zOrigin = j.xPercent = j.yPercent = j.xOffset = j.yOffset = 0, j.scaleX = j.scaleY = j.scaleZ = 1, ya("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function (a, b, c, d, f, h, i) { if (d._lastParsedTransform === i) return f; d._lastParsedTransform = i; var j, k = i.scale && "function" == typeof i.scale ? i.scale : 0; "function" == typeof i[c] && (j = i[c], i[c] = b), k && (i.scale = k(r, a)); var l, m, n, o, p, s, t, u, v, w = a._gsTransform, x = a.style, y = 1e-6, z = Ba.length, A = i, B = {}, C = "transformOrigin", D = Ra(a, e, !0, A.parseTransform), E = A.transform && ("function" == typeof A.transform ? A.transform(r, q) : A.transform); if (D.skewType = A.skewType || D.skewType || g.defaultSkewType, d._transform = D, E && "string" == typeof E && Ca) m = Q.style, m[Ca] = E, m.display = "block", m.position = "absolute", O.body.appendChild(Q), l = Ra(Q, null, !1), "simple" === D.skewType && (l.scaleY *= Math.cos(l.skewX * K)), D.svg && (s = D.xOrigin, t = D.yOrigin, l.x -= D.xOffset, l.y -= D.yOffset, (A.transformOrigin || A.svgOrigin) && (E = {}, La(a, ha(A.transformOrigin), E, A.svgOrigin, A.smoothOrigin, !0), s = E.xOrigin, t = E.yOrigin, l.x -= E.xOffset - D.xOffset, l.y -= E.yOffset - D.yOffset), (s || t) && (u = Qa(Q, !0), l.x -= s - (s * u[0] + t * u[2]), l.y -= t - (s * u[1] + t * u[3]))), O.body.removeChild(Q), l.perspective || (l.perspective = D.perspective), null != A.xPercent && (l.xPercent = ja(A.xPercent, D.xPercent)), null != A.yPercent && (l.yPercent = ja(A.yPercent, D.yPercent)); else if ("object" == typeof A) { if (l = { scaleX: ja(null != A.scaleX ? A.scaleX : A.scale, D.scaleX), scaleY: ja(null != A.scaleY ? A.scaleY : A.scale, D.scaleY), scaleZ: ja(A.scaleZ, D.scaleZ), x: ja(A.x, D.x), y: ja(A.y, D.y), z: ja(A.z, D.z), xPercent: ja(A.xPercent, D.xPercent), yPercent: ja(A.yPercent, D.yPercent), perspective: ja(A.transformPerspective, D.perspective) }, p = A.directionalRotation, null != p) if ("object" == typeof p) for (m in p) A[m] = p[m]; else A.rotation = p; "string" == typeof A.x && -1 !== A.x.indexOf("%") && (l.x = 0, l.xPercent = ja(A.x, D.xPercent)), "string" == typeof A.y && -1 !== A.y.indexOf("%") && (l.y = 0, l.yPercent = ja(A.y, D.yPercent)), l.rotation = ka("rotation" in A ? A.rotation : "shortRotation" in A ? A.shortRotation + "_short" : "rotationZ" in A ? A.rotationZ : D.rotation, D.rotation, "rotation", B), Fa && (l.rotationX = ka("rotationX" in A ? A.rotationX : "shortRotationX" in A ? A.shortRotationX + "_short" : D.rotationX || 0, D.rotationX, "rotationX", B), l.rotationY = ka("rotationY" in A ? A.rotationY : "shortRotationY" in A ? A.shortRotationY + "_short" : D.rotationY || 0, D.rotationY, "rotationY", B)), l.skewX = ka(A.skewX, D.skewX), l.skewY = ka(A.skewY, D.skewY) } for (Fa && null != A.force3D && (D.force3D = A.force3D, o = !0), n = D.force3D || D.z || D.rotationX || D.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, n || null == A.scale || (l.scaleZ = 1); --z > -1;)v = Ba[z], E = l[v] - D[v], (E > y || -y > E || null != A[v] || null != M[v]) && (o = !0, f = new ta(D, v, D[v], E, f), v in B && (f.e = B[v]), f.xs0 = 0, f.plugin = h, d._overwriteProps.push(f.n)); return E = A.transformOrigin, D.svg && (E || A.svgOrigin) && (s = D.xOffset, t = D.yOffset, La(a, ha(E), l, A.svgOrigin, A.smoothOrigin), f = ua(D, "xOrigin", (w ? D : l).xOrigin, l.xOrigin, f, C), f = ua(D, "yOrigin", (w ? D : l).yOrigin, l.yOrigin, f, C), (s !== D.xOffset || t !== D.yOffset) && (f = ua(D, "xOffset", w ? s : D.xOffset, D.xOffset, f, C), f = ua(D, "yOffset", w ? t : D.yOffset, D.yOffset, f, C)), E = "0px 0px"), (E || Fa && n && D.zOrigin) && (Ca ? (o = !0, v = Ea, E = (E || _(a, v, e, !1, "50% 50%")) + "", f = new ta(x, v, 0, 0, f, -1, C), f.b = x[v], f.plugin = h, Fa ? (m = D.zOrigin, E = E.split(" "), D.zOrigin = (E.length > 2 && (0 === m || "0px" !== E[2]) ? parseFloat(E[2]) : m) || 0, f.xs0 = f.e = E[0] + " " + (E[1] || "50%") + " 0px", f = new ta(D, "zOrigin", 0, 0, f, -1, f.n), f.b = m, f.xs0 = f.e = D.zOrigin) : f.xs0 = f.e = E) : ha(E + "", D)), o && (d._transformType = D.svg && Aa || !n && 3 !== this._transformType ? 2 : 3), j && (i[c] = j), k && (i.scale = k), f }, prefix: !0 }), ya("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), ya("borderRadius", { defaultValue: "0px", parser: function (a, b, c, f, g, h) { b = this.format(b); var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], z = a.style; for (q = parseFloat(a.offsetWidth), r = parseFloat(a.offsetHeight), i = b.split(" "), j = 0; j < y.length; j++)this.p.indexOf("border") && (y[j] = Z(y[j])), m = l = _(a, y[j], e, !1, "0px"), -1 !== m.indexOf(" ") && (l = m.split(" "), m = l[0], l = l[1]), n = k = i[j], o = parseFloat(m), t = m.substr((o + "").length), u = "=" === n.charAt(1), u ? (p = parseInt(n.charAt(0) + "1", 10), n = n.substr(2), p *= parseFloat(n), s = n.substr((p + "").length - (0 > p ? 1 : 0)) || "") : (p = parseFloat(n), s = n.substr((p + "").length)), "" === s && (s = d[c] || t), s !== t && (v = aa(a, "borderLeft", o, t), w = aa(a, "borderTop", o, t), "%" === s ? (m = v / q * 100 + "%", l = w / r * 100 + "%") : "em" === s ? (x = aa(a, "borderLeft", 1, "em"), m = v / x + "em", l = w / x + "em") : (m = v + "px", l = w + "px"), u && (n = parseFloat(m) + p + s, k = parseFloat(l) + p + s)), g = va(z, y[j], m + " " + l, n + " " + k, !1, "0px", g); return g }, prefix: !0, formatter: qa("0px 0px 0px 0px", !1, !0) }), ya("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function (a, b, c, d, f, g) { return va(a.style, c, this.format(_(a, c, e, !1, "0px 0px")), this.format(b), !1, "0px", f) }, prefix: !0, formatter: qa("0px 0px", !1, !0) }), ya("backgroundPosition", { defaultValue: "0 0", parser: function (a, b, c, d, f, g) { var h, i, j, k, l, m, n = "background-position", o = e || $(a, null), q = this.format((o ? p ? o.getPropertyValue(n + "-x") + " " + o.getPropertyValue(n + "-y") : o.getPropertyValue(n) : a.currentStyle.backgroundPositionX + " " + a.currentStyle.backgroundPositionY) || "0 0"), r = this.format(b); if (-1 !== q.indexOf("%") != (-1 !== r.indexOf("%")) && r.split(",").length < 2 && (m = _(a, "backgroundImage").replace(D, ""), m && "none" !== m)) { for (h = q.split(" "), i = r.split(" "), R.setAttribute("src", m), j = 2; --j > -1;)q = h[j], k = -1 !== q.indexOf("%"), k !== (-1 !== i[j].indexOf("%")) && (l = 0 === j ? a.offsetWidth - R.width : a.offsetHeight - R.height, h[j] = k ? parseFloat(q) / 100 * l + "px" : parseFloat(q) / l * 100 + "%"); q = h.join(" ") } return this.parseComplex(a.style, q, r, f, g) }, formatter: ha }), ya("backgroundSize", { defaultValue: "0 0", formatter: function (a) { return a += "", ha(-1 === a.indexOf(" ") ? a + " " + a : a) } }), ya("perspective", { defaultValue: "0px", prefix: !0 }), ya("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), ya("transformStyle", { prefix: !0 }), ya("backfaceVisibility", { prefix: !0 }), ya("userSelect", { prefix: !0 }), ya("margin", { parser: ra("marginTop,marginRight,marginBottom,marginLeft") }), ya("padding", { parser: ra("paddingTop,paddingRight,paddingBottom,paddingLeft") }), ya("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (a, b, c, d, f, g) { var h, i, j; return 9 > p ? (i = a.currentStyle, j = 8 > p ? " " : ",", h = "rect(" + i.clipTop + j + i.clipRight + j + i.clipBottom + j + i.clipLeft + ")", b = this.format(b).split(",").join(j)) : (h = this.format(_(a, this.p, e, !1, this.dflt)), b = this.format(b)), this.parseComplex(a.style, h, b, f, g) } }), ya("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), ya("autoRound,strictUnits", { parser: function (a, b, c, d, e) { return e } }), ya("border", { defaultValue: "0px solid #000", parser: function (a, b, c, d, f, g) { var h = _(a, "borderTopWidth", e, !1, "0px"), i = this.format(b).split(" "), j = i[0].replace(w, ""); return "px" !== j && (h = parseFloat(h) / aa(a, "borderTopWidth", 1, j) + j), this.parseComplex(a.style, this.format(h + " " + _(a, "borderTopStyle", e, !1, "solid") + " " + _(a, "borderTopColor", e, !1, "#000")), i.join(" "), f, g) }, color: !0, formatter: function (a) { var b = a.split(" "); return b[0] + " " + (b[1] || "solid") + " " + (a.match(pa) || ["#000"])[0] } }), ya("borderWidth", { parser: ra("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }), ya("float,cssFloat,styleFloat", { parser: function (a, b, c, d, e, f) { var g = a.style, h = "cssFloat" in g ? "cssFloat" : "styleFloat"; return new ta(g, h, 0, 0, e, -1, c, !1, 0, g[h], b) } }); var Ua = function (a) { var b, c = this.t, d = c.filter || _(this.data, "filter") || "", e = this.s + this.c * a | 0; 100 === e && (-1 === d.indexOf("atrix(") && -1 === d.indexOf("radient(") && -1 === d.indexOf("oader(") ? (c.removeAttribute("filter"), b = !_(this.data, "filter")) : (c.filter = d.replace(z, ""), b = !0)), b || (this.xn1 && (c.filter = d = d || "alpha(opacity=" + e + ")"), -1 === d.indexOf("pacity") ? 0 === e && this.xn1 || (c.filter = d + " alpha(opacity=" + e + ")") : c.filter = d.replace(x, "opacity=" + e)) }; ya("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (a, b, c, d, f, g) { var h = parseFloat(_(a, "opacity", e, !1, "1")), i = a.style, j = "autoAlpha" === c; return "string" == typeof b && "=" === b.charAt(1) && (b = ("-" === b.charAt(0) ? -1 : 1) * parseFloat(b.substr(2)) + h), j && 1 === h && "hidden" === _(a, "visibility", e) && 0 !== b && (h = 0), U ? f = new ta(i, "opacity", h, b - h, f) : (f = new ta(i, "opacity", 100 * h, 100 * (b - h), f), f.xn1 = j ? 1 : 0, i.zoom = 1, f.type = 2, f.b = "alpha(opacity=" + f.s + ")", f.e = "alpha(opacity=" + (f.s + f.c) + ")", f.data = a, f.plugin = g, f.setRatio = Ua), j && (f = new ta(i, "visibility", 0, 0, f, -1, null, !1, 0, 0 !== h ? "inherit" : "hidden", 0 === b ? "hidden" : "inherit"), f.xs0 = "inherit", d._overwriteProps.push(f.n), d._overwriteProps.push(c)), f } }); var Va = function (a, b) { b && (a.removeProperty ? (("ms" === b.substr(0, 2) || "webkit" === b.substr(0, 6)) && (b = "-" + b), a.removeProperty(b.replace(B, "-$1").toLowerCase())) : a.removeAttribute(b)) }, Wa = function (a) { if (this.t._gsClassPT = this, 1 === a || 0 === a) { this.t.setAttribute("class", 0 === a ? this.b : this.e); for (var b = this.data, c = this.t.style; b;)b.v ? c[b.p] = b.v : Va(c, b.p), b = b._next; 1 === a && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e) }; ya("className", { parser: function (a, b, d, f, g, h, i) { var j, k, l, m, n, o = a.getAttribute("class") || "", p = a.style.cssText; if (g = f._classNamePT = new ta(a, d, 0, 0, g, 2), g.setRatio = Wa, g.pr = -11, c = !0, g.b = o, k = ca(a, e), l = a._gsClassPT) { for (m = {}, n = l.data; n;)m[n.p] = 1, n = n._next; l.setRatio(1) } return a._gsClassPT = g, g.e = "=" !== b.charAt(1) ? b : o.replace(new RegExp("(?:\\s|^)" + b.substr(2) + "(?![\\w-])"), "") + ("+" === b.charAt(0) ? " " + b.substr(2) : ""), a.setAttribute("class", g.e), j = da(a, k, ca(a), i, m), a.setAttribute("class", o), g.data = j.firstMPT, a.style.cssText = p, g = g.xfirst = f.parse(a, j.difs, g, h) } }); var Xa = function (a) { if ((1 === a || 0 === a) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { var b, c, d, e, f, g = this.t.style, h = i.transform.parse; if ("all" === this.e) g.cssText = "", e = !0; else for (b = this.e.split(" ").join("").split(","), d = b.length; --d > -1;)c = b[d], i[c] && (i[c].parse === h ? e = !0 : c = "transformOrigin" === c ? Ea : i[c].p), Va(g, c); e && (Va(g, Ca), f = this.t._gsTransform, f && (f.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform)) } }; for (ya("clearProps", { parser: function (a, b, d, e, f) { return f = new ta(a, d, 0, 0, f, 2), f.setRatio = Xa, f.e = b, f.pr = -10, f.data = e._tween, c = !0, f } }), j = "bezier,throwProps,physicsProps,physics2D".split(","), wa = j.length; wa--;)za(j[wa]); j = g.prototype, j._firstPT = j._lastParsedTransform = j._transform = null, j._onInitTween = function (a, b, h, j) { if (!a.nodeType) return !1; this._target = q = a, this._tween = h, this._vars = b, r = j, k = b.autoRound, c = !1, d = b.suffixMap || g.suffixMap, e = $(a, ""), f = this._overwriteProps; var n, p, s, t, u, v, w, x, z, A = a.style; if (l && "" === A.zIndex && (n = _(a, "zIndex", e), ("auto" === n || "" === n) && this._addLazySet(A, "zIndex", 0)), "string" == typeof b && (t = A.cssText, n = ca(a, e), A.cssText = t + ";" + b, n = da(a, n, ca(a)).difs, !U && y.test(b) && (n.opacity = parseFloat(RegExp.$1)), b = n, A.cssText = t), b.className ? this._firstPT = p = i.className.parse(a, b.className, "className", this, null, null, b) : this._firstPT = p = this.parse(a, b, null), this._transformType) { for (z = 3 === this._transformType, Ca ? m && (l = !0, "" === A.zIndex && (w = _(a, "zIndex", e), ("auto" === w || "" === w) && this._addLazySet(A, "zIndex", 0)), o && this._addLazySet(A, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (z ? "visible" : "hidden"))) : A.zoom = 1, s = p; s && s._next;)s = s._next; x = new ta(a, "transform", 0, 0, null, 2), this._linkCSSP(x, null, s), x.setRatio = Ca ? Ta : Sa, x.data = this._transform || Ra(a, e, !0), x.tween = h, x.pr = -1, f.pop() } if (c) { for (; p;) { for (v = p._next, s = t; s && s.pr > p.pr;)s = s._next; (p._prev = s ? s._prev : u) ? p._prev._next = p : t = p, (p._next = s) ? s._prev = p : u = p, p = v } this._firstPT = t } return !0 }, j.parse = function (a, b, c, f) { var g, h, j, l, m, n, o, p, s, t, u = a.style; for (g in b) { if (n = b[g], "function" == typeof n && (n = n(r, q)), h = i[g]) c = h.parse(a, n, g, this, c, f, b); else { if ("--" === g.substr(0, 2)) { this._tween._propLookup[g] = this._addTween.call(this._tween, a.style, "setProperty", $(a).getPropertyValue(g) + "", n + "", g, !1, g); continue } m = _(a, g, e) + "", s = "string" == typeof n, "color" === g || "fill" === g || "stroke" === g || -1 !== g.indexOf("Color") || s && A.test(n) ? (s || (n = na(n), n = (n.length > 3 ? "rgba(" : "rgb(") + n.join(",") + ")"), c = va(u, g, m, n, !0, "transparent", c, 0, f)) : s && J.test(n) ? c = va(u, g, m, n, !0, null, c, 0, f) : (j = parseFloat(m), o = j || 0 === j ? m.substr((j + "").length) : "", ("" === m || "auto" === m) && ("width" === g || "height" === g ? (j = ga(a, g, e), o = "px") : "left" === g || "top" === g ? (j = ba(a, g, e), o = "px") : (j = "opacity" !== g ? 0 : 1, o = "")), t = s && "=" === n.charAt(1), t ? (l = parseInt(n.charAt(0) + "1", 10), n = n.substr(2), l *= parseFloat(n), p = n.replace(w, "")) : (l = parseFloat(n), p = s ? n.replace(w, "") : ""), "" === p && (p = g in d ? d[g] : o), n = l || 0 === l ? (t ? l + j : l) + p : b[g], o !== p && ("" !== p || "lineHeight" === g) && (l || 0 === l) && j && (j = aa(a, g, j, o), "%" === p ? (j /= aa(a, g, 100, "%") / 100, b.strictUnits !== !0 && (m = j + "%")) : "em" === p || "rem" === p || "vw" === p || "vh" === p ? j /= aa(a, g, 1, p) : "px" !== p && (l = aa(a, g, l, p), p = "px"), t && (l || 0 === l) && (n = l + j + p)), t && (l += j), !j && 0 !== j || !l && 0 !== l ? void 0 !== u[g] && (n || n + "" != "NaN" && null != n) ? (c = new ta(u, g, l || j || 0, 0, c, -1, g, !1, 0, m, n), c.xs0 = "none" !== n || "display" !== g && -1 === g.indexOf("Style") ? n : m) : W("invalid " + g + " tween value: " + b[g]) : (c = new ta(u, g, j, l - j, c, 0, g, k !== !1 && ("px" === p || "zIndex" === g), 0, m, n), c.xs0 = p)) } f && c && !c.plugin && (c.plugin = f) } return c }, j.setRatio = function (a) { var b, c, d, e = this._firstPT, f = 1e-6; if (1 !== a || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (a || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; e;) { if (b = e.c * a + e.s, e.r ? b = Math.round(b) : f > b && b > -f && (b = 0), e.type) if (1 === e.type) if (d = e.l, 2 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2; else if (3 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3; else if (4 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4; else if (5 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4 + e.xn4 + e.xs5; else { for (c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++)c += e["xn" + d] + e["xs" + (d + 1)]; e.t[e.p] = c } else -1 === e.type ? e.t[e.p] = e.xs0 : e.setRatio && e.setRatio(a); else e.t[e.p] = b + e.xs0; e = e._next } else for (; e;)2 !== e.type ? e.t[e.p] = e.b : e.setRatio(a), e = e._next; else for (; e;) { if (2 !== e.type) if (e.r && -1 !== e.type) if (b = Math.round(e.s + e.c), e.type) { if (1 === e.type) { for (d = e.l, c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++)c += e["xn" + d] + e["xs" + (d + 1)]; e.t[e.p] = c } } else e.t[e.p] = b + e.xs0; else e.t[e.p] = e.e; else e.setRatio(a); e = e._next } }, j._enableTransforms = function (a) { this._transform = this._transform || Ra(this._target, e, !0), this._transformType = this._transform.svg && Aa || !a && 3 !== this._transformType ? 2 : 3 }; var Ya = function (a) { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) }; j._addLazySet = function (a, b, c) { var d = this._firstPT = new ta(a, b, 0, 0, this._firstPT, 2); d.e = c, d.setRatio = Ya, d.data = this }, j._linkCSSP = function (a, b, c, d) { return a && (b && (b._prev = a), a._next && (a._next._prev = a._prev), a._prev ? a._prev._next = a._next : this._firstPT === a && (this._firstPT = a._next, d = !0), c ? c._next = a : d || null !== this._firstPT || (this._firstPT = a), a._next = b, a._prev = c), a }, j._mod = function (a) { for (var b = this._firstPT; b;)"function" == typeof a[b.p] && a[b.p] === Math.round && (b.r = 1), b = b._next }, j._kill = function (b) { var c, d, e, f = b; if (b.autoAlpha || b.alpha) { f = {}; for (d in b) f[d] = b[d]; f.opacity = 1, f.autoAlpha && (f.visibility = 1) } for (b.className && (c = this._classNamePT) && (e = c.xfirst, e && e._prev ? this._linkCSSP(e._prev, c._next, e._prev._prev) : e === this._firstPT && (this._firstPT = c._next), c._next && this._linkCSSP(c._next, c._next._next, e._prev), this._classNamePT = null), c = this._firstPT; c;)c.plugin && c.plugin !== d && c.plugin._kill && (c.plugin._kill(b), d = c.plugin), c = c._next; return a.prototype._kill.call(this, f) }; var Za = function (a, b, c) { var d, e, f, g; if (a.slice) for (e = a.length; --e > -1;)Za(a[e], b, c); else for (d = a.childNodes, e = d.length; --e > -1;)f = d[e], g = f.type, f.style && (b.push(ca(f)), c && c.push(f)), 1 !== g && 9 !== g && 11 !== g || !f.childNodes.length || Za(f, b, c) }; return g.cascadeTo = function (a, c, d) { var e, f, g, h, i = b.to(a, c, d), j = [i], k = [], l = [], m = [], n = b._internals.reservedProps; for (a = i._targets || i.target, Za(a, k, m), i.render(c, !0, !0), Za(a, l), i.render(0, !0, !0), i._enabled(!0), e = m.length; --e > -1;)if (f = da(m[e], k[e], l[e]), f.firstMPT) { f = f.difs; for (g in d) n[g] && (f[g] = d[g]); h = {}; for (g in f) h[g] = k[e][g]; j.push(b.fromTo(m[e], c, h, f)) } return j }, a.activate([g]), g }, !0), function () { var a = _gsScope._gsDefine.plugin({ propName: "roundProps", version: "1.6.0", priority: -1, API: 2, init: function (a, b, c) { return this._tween = c, !0 } }), b = function (a) { for (; a;)a.f || a.blob || (a.m = Math.round), a = a._next }, c = a.prototype; c._onInitAllProps = function () { for (var a, c, d, e = this._tween, f = e.vars.roundProps.join ? e.vars.roundProps : e.vars.roundProps.split(","), g = f.length, h = {}, i = e._propLookup.roundProps; --g > -1;)h[f[g]] = Math.round; for (g = f.length; --g > -1;)for (a = f[g], c = e._firstPT; c;)d = c._next, c.pg ? c.t._mod(h) : c.n === a && (2 === c.f && c.t ? b(c.t._firstPT) : (this._add(c.t, a, c.s, c.c), d && (d._prev = c._prev), c._prev ? c._prev._next = d : e._firstPT === c && (e._firstPT = d), c._next = c._prev = null, e._propLookup[a] = i)), c = d; return !1 }, c._add = function (a, b, c, d) { this._addTween(a, b, c, c + d, b, Math.round), this._overwriteProps.push(b) } }(), function () { _gsScope._gsDefine.plugin({ propName: "attr", API: 2, version: "0.6.1", init: function (a, b, c, d) { var e, f; if ("function" != typeof a.setAttribute) return !1; for (e in b) f = b[e], "function" == typeof f && (f = f(d, a)), this._addTween(a, "setAttribute", a.getAttribute(e) + "", f + "", e, !1, e), this._overwriteProps.push(e); return !0 } }) }(), _gsScope._gsDefine.plugin({ propName: "directionalRotation", version: "0.3.1", API: 2, init: function (a, b, c, d) { "object" != typeof b && (b = { rotation: b }), this.finals = {}; var e, f, g, h, i, j, k = b.useRadians === !0 ? 2 * Math.PI : 360, l = 1e-6; for (e in b) "useRadians" !== e && (h = b[e], "function" == typeof h && (h = h(d, a)), j = (h + "").split("_"), f = j[0], g = parseFloat("function" != typeof a[e] ? a[e] : a[e.indexOf("set") || "function" != typeof a["get" + e.substr(3)] ? e : "get" + e.substr(3)]()), h = this.finals[e] = "string" == typeof f && "=" === f.charAt(1) ? g + parseInt(f.charAt(0) + "1", 10) * Number(f.substr(2)) : Number(f) || 0, i = h - g, j.length && (f = j.join("_"), -1 !== f.indexOf("short") && (i %= k, i !== i % (k / 2) && (i = 0 > i ? i + k : i - k)), -1 !== f.indexOf("_cw") && 0 > i ? i = (i + 9999999999 * k) % k - (i / k | 0) * k : -1 !== f.indexOf("ccw") && i > 0 && (i = (i - 9999999999 * k) % k - (i / k | 0) * k)), (i > l || -l > i) && (this._addTween(a, e, g, g + i, e), this._overwriteProps.push(e))); return !0 }, set: function (a) { var b; if (1 !== a) this._super.setRatio.call(this, a); else for (b = this._firstPT; b;)b.f ? b.t[b.p](this.finals[b.p]) : b.t[b.p] = this.finals[b.p], b = b._next } })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function (a) { var b, c, d, e, f = _gsScope.GreenSockGlobals || _gsScope, g = f.com.greensock, h = 2 * Math.PI, i = Math.PI / 2, j = g._class, k = function (b, c) { var d = j("easing." + b, function () { }, !0), e = d.prototype = new a; return e.constructor = d, e.getRatio = c, d }, l = a.register || function () { }, m = function (a, b, c, d, e) { var f = j("easing." + a, { easeOut: new b, easeIn: new c, easeInOut: new d }, !0); return l(f, a), f }, n = function (a, b, c) { this.t = a, this.v = b, c && (this.next = c, c.prev = this, this.c = c.v - b, this.gap = c.t - a) }, o = function (b, c) { var d = j("easing." + b, function (a) { this._p1 = a || 0 === a ? a : 1.70158, this._p2 = 1.525 * this._p1 }, !0), e = d.prototype = new a; return e.constructor = d, e.getRatio = c, e.config = function (a) { return new d(a) }, d }, p = m("Back", o("BackOut", function (a) { return (a -= 1) * a * ((this._p1 + 1) * a + this._p1) + 1 }), o("BackIn", function (a) { return a * a * ((this._p1 + 1) * a - this._p1) }), o("BackInOut", function (a) { return (a *= 2) < 1 ? .5 * a * a * ((this._p2 + 1) * a - this._p2) : .5 * ((a -= 2) * a * ((this._p2 + 1) * a + this._p2) + 2) })), q = j("easing.SlowMo", function (a, b, c) { b = b || 0 === b ? b : .7, null == a ? a = .7 : a > 1 && (a = 1), this._p = 1 !== a ? b : 0, this._p1 = (1 - a) / 2, this._p2 = a, this._p3 = this._p1 + this._p2, this._calcEnd = c === !0 }, !0), r = q.prototype = new a; return r.constructor = q, r.getRatio = function (a) { var b = a + (.5 - a) * this._p; return a < this._p1 ? this._calcEnd ? 1 - (a = 1 - a / this._p1) * a : b - (a = 1 - a / this._p1) * a * a * a * b : a > this._p3 ? this._calcEnd ? 1 === a ? 0 : 1 - (a = (a - this._p3) / this._p1) * a : b + (a - b) * (a = (a - this._p3) / this._p1) * a * a * a : this._calcEnd ? 1 : b }, q.ease = new q(.7, .7), r.config = q.config = function (a, b, c) { return new q(a, b, c) }, b = j("easing.SteppedEase", function (a, b) { a = a || 1, this._p1 = 1 / a, this._p2 = a + (b ? 0 : 1), this._p3 = b ? 1 : 0 }, !0), r = b.prototype = new a, r.constructor = b, r.getRatio = function (a) { return 0 > a ? a = 0 : a >= 1 && (a = .999999999), ((this._p2 * a | 0) + this._p3) * this._p1 }, r.config = b.config = function (a, c) { return new b(a, c) }, c = j("easing.ExpoScaleEase", function (a, b, c) { this._p1 = Math.log(b / a), this._p2 = b - a, this._p3 = a, this._ease = c }, !0), r = c.prototype = new a, r.constructor = c, r.getRatio = function (a) { return this._ease && (a = this._ease.getRatio(a)), (this._p3 * Math.exp(this._p1 * a) - this._p3) / this._p2 }, r.config = c.config = function (a, b, d) { return new c(a, b, d) }, d = j("easing.RoughEase", function (b) { b = b || {}; for (var c, d, e, f, g, h, i = b.taper || "none", j = [], k = 0, l = 0 | (b.points || 20), m = l, o = b.randomize !== !1, p = b.clamp === !0, q = b.template instanceof a ? b.template : null, r = "number" == typeof b.strength ? .4 * b.strength : .4; --m > -1;)c = o ? Math.random() : 1 / l * m, d = q ? q.getRatio(c) : c, "none" === i ? e = r : "out" === i ? (f = 1 - c, e = f * f * r) : "in" === i ? e = c * c * r : .5 > c ? (f = 2 * c, e = f * f * .5 * r) : (f = 2 * (1 - c), e = f * f * .5 * r), o ? d += Math.random() * e - .5 * e : m % 2 ? d += .5 * e : d -= .5 * e, p && (d > 1 ? d = 1 : 0 > d && (d = 0)), j[k++] = { x: c, y: d }; for (j.sort(function (a, b) { return a.x - b.x }), h = new n(1, 1, null), m = l; --m > -1;)g = j[m], h = new n(g.x, g.y, h); this._prev = new n(0, 0, 0 !== h.t ? h : h.next) }, !0), r = d.prototype = new a, r.constructor = d, r.getRatio = function (a) { var b = this._prev; if (a > b.t) { for (; b.next && a >= b.t;)b = b.next; b = b.prev } else for (; b.prev && a <= b.t;)b = b.prev; return this._prev = b, b.v + (a - b.t) / b.gap * b.c }, r.config = function (a) { return new d(a) }, d.ease = new d, m("Bounce", k("BounceOut", function (a) { return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375 }), k("BounceIn", function (a) { return (a = 1 - a) < 1 / 2.75 ? 1 - 7.5625 * a * a : 2 / 2.75 > a ? 1 - (7.5625 * (a -= 1.5 / 2.75) * a + .75) : 2.5 / 2.75 > a ? 1 - (7.5625 * (a -= 2.25 / 2.75) * a + .9375) : 1 - (7.5625 * (a -= 2.625 / 2.75) * a + .984375) }), k("BounceInOut", function (a) { var b = .5 > a; return a = b ? 1 - 2 * a : 2 * a - 1, a = 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375, b ? .5 * (1 - a) : .5 * a + .5 })), m("Circ", k("CircOut", function (a) { return Math.sqrt(1 - (a -= 1) * a) }), k("CircIn", function (a) { return -(Math.sqrt(1 - a * a) - 1) }), k("CircInOut", function (a) { return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1) })), e = function (b, c, d) { var e = j("easing." + b, function (a, b) { this._p1 = a >= 1 ? a : 1, this._p2 = (b || d) / (1 > a ? a : 1), this._p3 = this._p2 / h * (Math.asin(1 / this._p1) || 0), this._p2 = h / this._p2 }, !0), f = e.prototype = new a; return f.constructor = e, f.getRatio = c, f.config = function (a, b) { return new e(a, b) }, e }, m("Elastic", e("ElasticOut", function (a) { return this._p1 * Math.pow(2, -10 * a) * Math.sin((a - this._p3) * this._p2) + 1 }, .3), e("ElasticIn", function (a) { return -(this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2)) }, .3), e("ElasticInOut", function (a) { return (a *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2) * .5 + 1 }, .45)), m("Expo", k("ExpoOut", function (a) { return 1 - Math.pow(2, -10 * a) }), k("ExpoIn", function (a) { return Math.pow(2, 10 * (a - 1)) - .001 }), k("ExpoInOut", function (a) { return (a *= 2) < 1 ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (2 - Math.pow(2, -10 * (a - 1))) })), m("Sine", k("SineOut", function (a) { return Math.sin(a * i) }), k("SineIn", function (a) { return -Math.cos(a * i) + 1 }), k("SineInOut", function (a) { return -.5 * (Math.cos(Math.PI * a) - 1) })), j("easing.EaseLookup", { find: function (b) { return a.map[b] } }, !0), l(f.SlowMo, "SlowMo", "ease,"), l(d, "RoughEase", "ease,"), l(b, "SteppedEase", "ease,"), p }, !0) }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function (a, b) { "use strict"; var c = {}, d = a.document, e = a.GreenSockGlobals = a.GreenSockGlobals || a; if (!e.TweenLite) { var f, g, h, i, j, k = function (a) { var b, c = a.split("."), d = e; for (b = 0; b < c.length; b++)d[c[b]] = d = d[c[b]] || {}; return d }, l = k("com.greensock"), m = 1e-10, n = function (a) { var b, c = [], d = a.length; for (b = 0; b !== d; c.push(a[b++])); return c }, o = function () { }, p = function () { var a = Object.prototype.toString, b = a.call([]); return function (c) { return null != c && (c instanceof Array || "object" == typeof c && !!c.push && a.call(c) === b) } }(), q = {}, r = function (d, f, g, h) { this.sc = q[d] ? q[d].sc : [], q[d] = this, this.gsClass = null, this.func = g; var i = []; this.check = function (j) { for (var l, m, n, o, p = f.length, s = p; --p > -1;)(l = q[f[p]] || new r(f[p], [])).gsClass ? (i[p] = l.gsClass, s--) : j && l.sc.push(this); if (0 === s && g) { if (m = ("com.greensock." + d).split("."), n = m.pop(), o = k(m.join("."))[n] = this.gsClass = g.apply(g, i), h) if (e[n] = c[n] = o, "undefined" != typeof module && module.exports) if (d === b) { module.exports = c[b] = o; for (p in c) o[p] = c[p] } else c[b] && (c[b][n] = o); else "function" == typeof define && define.amd && define((a.GreenSockAMDPath ? a.GreenSockAMDPath + "/" : "") + d.split(".").pop(), [], function () { return o }); for (p = 0; p < this.sc.length; p++)this.sc[p].check() } }, this.check(!0) }, s = a._gsDefine = function (a, b, c, d) { return new r(a, b, c, d) }, t = l._class = function (a, b, c) { return b = b || function () { }, s(a, [], function () { return b }, c), b }; s.globals = e; var u = [0, 0, 1, 1], v = t("easing.Ease", function (a, b, c, d) { this._func = a, this._type = c || 0, this._power = d || 0, this._params = b ? u.concat(b) : u }, !0), w = v.map = {}, x = v.register = function (a, b, c, d) { for (var e, f, g, h, i = b.split(","), j = i.length, k = (c || "easeIn,easeOut,easeInOut").split(","); --j > -1;)for (f = i[j], e = d ? t("easing." + f, null, !0) : l.easing[f] || {}, g = k.length; --g > -1;)h = k[g], w[f + "." + h] = w[h + f] = e[h] = a.getRatio ? a : a[h] || new a }; for (h = v.prototype, h._calcEnd = !1, h.getRatio = function (a) { if (this._func) return this._params[0] = a, this._func.apply(null, this._params); var b = this._type, c = this._power, d = 1 === b ? 1 - a : 2 === b ? a : .5 > a ? 2 * a : 2 * (1 - a); return 1 === c ? d *= d : 2 === c ? d *= d * d : 3 === c ? d *= d * d * d : 4 === c && (d *= d * d * d * d), 1 === b ? 1 - d : 2 === b ? d : .5 > a ? d / 2 : 1 - d / 2 }, f = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], g = f.length; --g > -1;)h = f[g] + ",Power" + g, x(new v(null, null, 1, g), h, "easeOut", !0), x(new v(null, null, 2, g), h, "easeIn" + (0 === g ? ",easeNone" : "")), x(new v(null, null, 3, g), h, "easeInOut"); w.linear = l.easing.Linear.easeIn, w.swing = l.easing.Quad.easeInOut; var y = t("events.EventDispatcher", function (a) { this._listeners = {}, this._eventTarget = a || this }); h = y.prototype, h.addEventListener = function (a, b, c, d, e) { e = e || 0; var f, g, h = this._listeners[a], k = 0; for (this !== i || j || i.wake(), null == h && (this._listeners[a] = h = []), g = h.length; --g > -1;)f = h[g], f.c === b && f.s === c ? h.splice(g, 1) : 0 === k && f.pr < e && (k = g + 1); h.splice(k, 0, { c: b, s: c, up: d, pr: e }) }, h.removeEventListener = function (a, b) { var c, d = this._listeners[a]; if (d) for (c = d.length; --c > -1;)if (d[c].c === b) return void d.splice(c, 1) }, h.dispatchEvent = function (a) { var b, c, d, e = this._listeners[a]; if (e) for (b = e.length, b > 1 && (e = e.slice(0)), c = this._eventTarget; --b > -1;)d = e[b], d && (d.up ? d.c.call(d.s || c, { type: a, target: c }) : d.c.call(d.s || c)) }; var z = a.requestAnimationFrame, A = a.cancelAnimationFrame, B = Date.now || function () { return (new Date).getTime() }, C = B(); for (f = ["ms", "moz", "webkit", "o"], g = f.length; --g > -1 && !z;)z = a[f[g] + "RequestAnimationFrame"], A = a[f[g] + "CancelAnimationFrame"] || a[f[g] + "CancelRequestAnimationFrame"]; t("Ticker", function (a, b) { var c, e, f, g, h, k = this, l = B(), n = b !== !1 && z ? "auto" : !1, p = 500, q = 33, r = "tick", s = function (a) { var b, d, i = B() - C; i > p && (l += i - q), C += i, k.time = (C - l) / 1e3, b = k.time - h, (!c || b > 0 || a === !0) && (k.frame++, h += b + (b >= g ? .004 : g - b), d = !0), a !== !0 && (f = e(s)), d && k.dispatchEvent(r) }; y.call(k), k.time = k.frame = 0, k.tick = function () { s(!0) }, k.lagSmoothing = function (a, b) { return arguments.length ? (p = a || 1 / m, void (q = Math.min(b, p, 0))) : 1 / m > p }, k.sleep = function () { null != f && (n && A ? A(f) : clearTimeout(f), e = o, f = null, k === i && (j = !1)) }, k.wake = function (a) { null !== f ? k.sleep() : a ? l += -C + (C = B()) : k.frame > 10 && (C = B() - p + 5), e = 0 === c ? o : n && z ? z : function (a) { return setTimeout(a, 1e3 * (h - k.time) + 1 | 0) }, k === i && (j = !0), s(2) }, k.fps = function (a) { return arguments.length ? (c = a, g = 1 / (c || 60), h = this.time + g, void k.wake()) : c }, k.useRAF = function (a) { return arguments.length ? (k.sleep(), n = a, void k.fps(c)) : n }, k.fps(a), setTimeout(function () { "auto" === n && k.frame < 5 && "hidden" !== (d || {}).visibilityState && k.useRAF(!1) }, 1500) }), h = l.Ticker.prototype = new l.events.EventDispatcher, h.constructor = l.Ticker; var D = t("core.Animation", function (a, b) { if (this.vars = b = b || {}, this._duration = this._totalDuration = a || 0, this._delay = Number(b.delay) || 0, this._timeScale = 1, this._active = b.immediateRender === !0, this.data = b.data, this._reversed = b.reversed === !0, X) { j || i.wake(); var c = this.vars.useFrames ? W : X; c.add(this, c._time), this.vars.paused && this.paused(!0) } }); i = D.ticker = new l.Ticker, h = D.prototype, h._dirty = h._gc = h._initted = h._paused = !1, h._totalTime = h._time = 0, h._rawPrevTime = -1, h._next = h._last = h._onUpdate = h._timeline = h.timeline = null, h._paused = !1; var E = function () { j && B() - C > 2e3 && ("hidden" !== (d || {}).visibilityState || !i.lagSmoothing()) && i.wake(); var a = setTimeout(E, 2e3); a.unref && a.unref() }; E(), h.play = function (a, b) { return null != a && this.seek(a, b), this.reversed(!1).paused(!1) }, h.pause = function (a, b) { return null != a && this.seek(a, b), this.paused(!0) }, h.resume = function (a, b) { return null != a && this.seek(a, b), this.paused(!1) }, h.seek = function (a, b) { return this.totalTime(Number(a), b !== !1) }, h.restart = function (a, b) { return this.reversed(!1).paused(!1).totalTime(a ? -this._delay : 0, b !== !1, !0) }, h.reverse = function (a, b) { return null != a && this.seek(a || this.totalDuration(), b), this.reversed(!0).paused(!1) }, h.render = function (a, b, c) { }, h.invalidate = function () { return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this }, h.isActive = function () { var a, b = this._timeline, c = this._startTime; return !b || !this._gc && !this._paused && b.isActive() && (a = b.rawTime(!0)) >= c && a < c + this.totalDuration() / this._timeScale - 1e-7 }, h._enabled = function (a, b) { return j || i.wake(), this._gc = !a, this._active = this.isActive(), b !== !0 && (a && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !a && this.timeline && this._timeline._remove(this, !0)), !1 }, h._kill = function (a, b) { return this._enabled(!1, !1) }, h.kill = function (a, b) { return this._kill(a, b), this }, h._uncache = function (a) { for (var b = a ? this : this.timeline; b;)b._dirty = !0, b = b.timeline; return this }, h._swapSelfInParams = function (a) { for (var b = a.length, c = a.concat(); --b > -1;)"{self}" === a[b] && (c[b] = this); return c }, h._callback = function (a) { var b = this.vars, c = b[a], d = b[a + "Params"], e = b[a + "Scope"] || b.callbackScope || this, f = d ? d.length : 0; switch (f) { case 0: c.call(e); break; case 1: c.call(e, d[0]); break; case 2: c.call(e, d[0], d[1]); break; default: c.apply(e, d) } }, h.eventCallback = function (a, b, c, d) { if ("on" === (a || "").substr(0, 2)) { var e = this.vars; if (1 === arguments.length) return e[a]; null == b ? delete e[a] : (e[a] = b, e[a + "Params"] = p(c) && -1 !== c.join("").indexOf("{self}") ? this._swapSelfInParams(c) : c, e[a + "Scope"] = d), "onUpdate" === a && (this._onUpdate = b) } return this }, h.delay = function (a) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + a - this._delay), this._delay = a, this) : this._delay }, h.duration = function (a) { return arguments.length ? (this._duration = this._totalDuration = a, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== a && this.totalTime(this._totalTime * (a / this._duration), !0), this) : (this._dirty = !1, this._duration) }, h.totalDuration = function (a) { return this._dirty = !1, arguments.length ? this.duration(a) : this._totalDuration }, h.time = function (a, b) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(a > this._duration ? this._duration : a, b)) : this._time }, h.totalTime = function (a, b, c) { if (j || i.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (0 > a && !c && (a += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var d = this._totalDuration, e = this._timeline; if (a > d && !c && (a = d), this._startTime = (this._paused ? this._pauseTime : e._time) - (this._reversed ? d - a : a) / this._timeScale, e._dirty || this._uncache(!1), e._timeline) for (; e._timeline;)e._timeline._time !== (e._startTime + e._totalTime) / e._timeScale && e.totalTime(e._totalTime, !0), e = e._timeline } this._gc && this._enabled(!0, !1), (this._totalTime !== a || 0 === this._duration) && (J.length && Z(), this.render(a, b, !1), J.length && Z()) } return this }, h.progress = h.totalProgress = function (a, b) { var c = this.duration(); return arguments.length ? this.totalTime(c * a, b) : c ? this._time / c : this.ratio }, h.startTime = function (a) { return arguments.length ? (a !== this._startTime && (this._startTime = a, this.timeline && this.timeline._sortChildren && this.timeline.add(this, a - this._delay)), this) : this._startTime }, h.endTime = function (a) { return this._startTime + (0 != a ? this.totalDuration() : this.duration()) / this._timeScale }, h.timeScale = function (a) { if (!arguments.length) return this._timeScale; var b, c; for (a = a || m, this._timeline && this._timeline.smoothChildTiming && (b = this._pauseTime, c = b || 0 === b ? b : this._timeline.totalTime(), this._startTime = c - (c - this._startTime) * this._timeScale / a), this._timeScale = a, c = this.timeline; c && c.timeline;)c._dirty = !0, c.totalDuration(), c = c.timeline; return this }, h.reversed = function (a) { return arguments.length ? (a != this._reversed && (this._reversed = a, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, h.paused = function (a) { if (!arguments.length) return this._paused; var b, c, d = this._timeline; return a != this._paused && d && (j || a || i.wake(), b = d.rawTime(), c = b - this._pauseTime, !a && d.smoothChildTiming && (this._startTime += c, this._uncache(!1)), this._pauseTime = a ? b : null, this._paused = a, this._active = this.isActive(), !a && 0 !== c && this._initted && this.duration() && (b = d.smoothChildTiming ? this._totalTime : (b - this._startTime) / this._timeScale, this.render(b, b === this._totalTime, !0))), this._gc && !a && this._enabled(!0, !1), this }; var F = t("core.SimpleTimeline", function (a) { D.call(this, 0, a), this.autoRemoveChildren = this.smoothChildTiming = !0 }); h = F.prototype = new D, h.constructor = F, h.kill()._gc = !1, h._first = h._last = h._recent = null, h._sortChildren = !1, h.add = h.insert = function (a, b, c, d) { var e, f; if (a._startTime = Number(b || 0) + a._delay, a._paused && this !== a._timeline && (a._pauseTime = a._startTime + (this.rawTime() - a._startTime) / a._timeScale), a.timeline && a.timeline._remove(a, !0), a.timeline = a._timeline = this, a._gc && a._enabled(!0, !0), e = this._last, this._sortChildren) for (f = a._startTime; e && e._startTime > f;)e = e._prev; return e ? (a._next = e._next, e._next = a) : (a._next = this._first, this._first = a), a._next ? a._next._prev = a : this._last = a, a._prev = e, this._recent = a, this._timeline && this._uncache(!0), this }, h._remove = function (a, b) { return a.timeline === this && (b || a._enabled(!1, !0), a._prev ? a._prev._next = a._next : this._first === a && (this._first = a._next), a._next ? a._next._prev = a._prev : this._last === a && (this._last = a._prev), a._next = a._prev = a.timeline = null, a === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this }, h.render = function (a, b, c) { var d, e = this._first; for (this._totalTime = this._time = this._rawPrevTime = a; e;)d = e._next, (e._active || a >= e._startTime && !e._paused && !e._gc) && (e._reversed ? e.render((e._dirty ? e.totalDuration() : e._totalDuration) - (a - e._startTime) * e._timeScale, b, c) : e.render((a - e._startTime) * e._timeScale, b, c)), e = d }, h.rawTime = function () { return j || i.wake(), this._totalTime }; var G = t("TweenLite", function (b, c, d) { if (D.call(this, c, d), this.render = G.prototype.render, null == b) throw "Cannot tween a null target."; this.target = b = "string" != typeof b ? b : G.selector(b) || b; var e, f, g, h = b.jquery || b.length && b !== a && b[0] && (b[0] === a || b[0].nodeType && b[0].style && !b.nodeType), i = this.vars.overwrite; if (this._overwrite = i = null == i ? V[G.defaultOverwrite] : "number" == typeof i ? i >> 0 : V[i], (h || b instanceof Array || b.push && p(b)) && "number" != typeof b[0]) for (this._targets = g = n(b), this._propLookup = [], this._siblings = [], e = 0; e < g.length; e++)f = g[e], f ? "string" != typeof f ? f.length && f !== a && f[0] && (f[0] === a || f[0].nodeType && f[0].style && !f.nodeType) ? (g.splice(e--, 1), this._targets = g = g.concat(n(f))) : (this._siblings[e] = $(f, this, !1), 1 === i && this._siblings[e].length > 1 && aa(f, this, null, 1, this._siblings[e])) : (f = g[e--] = G.selector(f), "string" == typeof f && g.splice(e + 1, 1)) : g.splice(e--, 1); else this._propLookup = {}, this._siblings = $(b, this, !1), 1 === i && this._siblings.length > 1 && aa(b, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === c && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -m, this.render(Math.min(0, -this._delay))) }, !0), H = function (b) { return b && b.length && b !== a && b[0] && (b[0] === a || b[0].nodeType && b[0].style && !b.nodeType) }, I = function (a, b) { var c, d = {}; for (c in a) U[c] || c in b && "transform" !== c && "x" !== c && "y" !== c && "width" !== c && "height" !== c && "className" !== c && "border" !== c || !(!R[c] || R[c] && R[c]._autoCSS) || (d[c] = a[c], delete a[c]); a.css = d }; h = G.prototype = new D, h.constructor = G, h.kill()._gc = !1, h.ratio = 0, h._firstPT = h._targets = h._overwrittenProps = h._startAt = null, h._notifyPluginsOfEnabled = h._lazy = !1, G.version = "1.20.4", G.defaultEase = h._ease = new v(null, null, 1, 1), G.defaultOverwrite = "auto", G.ticker = i, G.autoSleep = 120, G.lagSmoothing = function (a, b) { i.lagSmoothing(a, b) }, G.selector = a.$ || a.jQuery || function (b) { var c = a.$ || a.jQuery; return c ? (G.selector = c, c(b)) : "undefined" == typeof d ? b : d.querySelectorAll ? d.querySelectorAll(b) : d.getElementById("#" === b.charAt(0) ? b.substr(1) : b) }; var J = [], K = {}, L = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, M = /[\+-]=-?[\.\d]/, N = function (a) { for (var b, c = this._firstPT, d = 1e-6; c;)b = c.blob ? 1 === a && null != this.end ? this.end : a ? this.join("") : this.start : c.c * a + c.s, c.m ? b = c.m(b, this._target || c.t) : d > b && b > -d && !c.blob && (b = 0), c.f ? c.fp ? c.t[c.p](c.fp, b) : c.t[c.p](b) : c.t[c.p] = b, c = c._next }, O = function (a, b, c, d) { var e, f, g, h, i, j, k, l = [], m = 0, n = "", o = 0; for (l.start = a, l.end = b, a = l[0] = a + "", b = l[1] = b + "", c && (c(l), a = l[0], b = l[1]), l.length = 0, e = a.match(L) || [], f = b.match(L) || [], d && (d._next = null, d.blob = 1, l._firstPT = l._applyPT = d), i = f.length, h = 0; i > h; h++)k = f[h], j = b.substr(m, b.indexOf(k, m) - m), n += j || !h ? j : ",", m += j.length, o ? o = (o + 1) % 5 : "rgba(" === j.substr(-5) && (o = 1), k === e[h] || e.length <= h ? n += k : (n && (l.push(n), n = ""), g = parseFloat(e[h]), l.push(g), l._firstPT = { _next: l._firstPT, t: l, p: l.length - 1, s: g, c: ("=" === k.charAt(1) ? parseInt(k.charAt(0) + "1", 10) * parseFloat(k.substr(2)) : parseFloat(k) - g) || 0, f: 0, m: o && 4 > o ? Math.round : 0 }), m += k.length; return n += b.substr(m), n && l.push(n), l.setRatio = N, M.test(b) && (l.end = null), l }, P = function (a, b, c, d, e, f, g, h, i) { "function" == typeof d && (d = d(i || 0, a)); var j, k = typeof a[b], l = "function" !== k ? "" : b.indexOf("set") || "function" != typeof a["get" + b.substr(3)] ? b : "get" + b.substr(3), m = "get" !== c ? c : l ? g ? a[l](g) : a[l]() : a[b], n = "string" == typeof d && "=" === d.charAt(1), o = { t: a, p: b, s: m, f: "function" === k, pg: 0, n: e || b, m: f ? "function" == typeof f ? f : Math.round : 0, pr: 0, c: n ? parseInt(d.charAt(0) + "1", 10) * parseFloat(d.substr(2)) : parseFloat(d) - m || 0 }; return ("number" != typeof m || "number" != typeof d && !n) && (g || isNaN(m) || !n && isNaN(d) || "boolean" == typeof m || "boolean" == typeof d ? (o.fp = g, j = O(m, n ? parseFloat(o.s) + o.c + (o.s + "").replace(/[0-9\-\.]/g, "") : d, h || G.defaultStringFilter, o), o = { t: j, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: e || b, pr: 0, m: 0 }) : (o.s = parseFloat(m), n || (o.c = parseFloat(d) - o.s || 0))), o.c ? ((o._next = this._firstPT) && (o._next._prev = o), this._firstPT = o, o) : void 0 }, Q = G._internals = { isArray: p, isSelector: H, lazyTweens: J, blobDif: O }, R = G._plugins = {}, S = Q.tweenLookup = {}, T = 0, U = Q.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1, yoyoEase: 1 }, V = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 }, W = D._rootFramesTimeline = new F, X = D._rootTimeline = new F, Y = 30, Z = Q.lazyRender = function () { var a, b = J.length; for (K = {}; --b > -1;)a = J[b], a && a._lazy !== !1 && (a.render(a._lazy[0], a._lazy[1], !0), a._lazy = !1); J.length = 0 }; X._startTime = i.time, W._startTime = i.frame, X._active = W._active = !0, setTimeout(Z, 1), D._updateRoot = G.render = function () { var a, b, c; if (J.length && Z(), X.render((i.time - X._startTime) * X._timeScale, !1, !1), W.render((i.frame - W._startTime) * W._timeScale, !1, !1), J.length && Z(), i.frame >= Y) { Y = i.frame + (parseInt(G.autoSleep, 10) || 120); for (c in S) { for (b = S[c].tweens, a = b.length; --a > -1;)b[a]._gc && b.splice(a, 1); 0 === b.length && delete S[c] } if (c = X._first, (!c || c._paused) && G.autoSleep && !W._first && 1 === i._listeners.tick.length) { for (; c && c._paused;)c = c._next; c || i.sleep() } } }, i.addEventListener("tick", D._updateRoot); var $ = function (a, b, c) { var d, e, f = a._gsTweenID; if (S[f || (a._gsTweenID = f = "t" + T++)] || (S[f] = { target: a, tweens: [] }), b && (d = S[f].tweens, d[e = d.length] = b, c)) for (; --e > -1;)d[e] === b && d.splice(e, 1); return S[f].tweens }, _ = function (a, b, c, d) { var e, f, g = a.vars.onOverwrite; return g && (e = g(a, b, c, d)), g = G.onOverwrite, g && (f = g(a, b, c, d)), e !== !1 && f !== !1 }, aa = function (a, b, c, d, e) { var f, g, h, i; if (1 === d || d >= 4) { for (i = e.length, f = 0; i > f; f++)if ((h = e[f]) !== b) h._gc || h._kill(null, a, b) && (g = !0); else if (5 === d) break; return g } var j, k = b._startTime + m, l = [], n = 0, o = 0 === b._duration; for (f = e.length; --f > -1;)(h = e[f]) === b || h._gc || h._paused || (h._timeline !== b._timeline ? (j = j || ba(b, 0, o), 0 === ba(h, j, o) && (l[n++] = h)) : h._startTime <= k && h._startTime + h.totalDuration() / h._timeScale > k && ((o || !h._initted) && k - h._startTime <= 2e-10 || (l[n++] = h))); for (f = n; --f > -1;)if (h = l[f], 2 === d && h._kill(c, a, b) && (g = !0), 2 !== d || !h._firstPT && h._initted) { if (2 !== d && !_(h, b)) continue; h._enabled(!1, !1) && (g = !0) } return g }, ba = function (a, b, c) { for (var d = a._timeline, e = d._timeScale, f = a._startTime; d._timeline;) { if (f += d._startTime, e *= d._timeScale, d._paused) return -100; d = d._timeline } return f /= e, f > b ? f - b : c && f === b || !a._initted && 2 * m > f - b ? m : (f += a.totalDuration() / a._timeScale / e) > b + m ? 0 : f - b - m }; h._init = function () { var a, b, c, d, e, f, g = this.vars, h = this._overwrittenProps, i = this._duration, j = !!g.immediateRender, k = g.ease; if (g.startAt) { this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), e = {}; for (d in g.startAt) e[d] = g.startAt[d]; if (e.data = "isStart", e.overwrite = !1, e.immediateRender = !0, e.lazy = j && g.lazy !== !1, e.startAt = e.delay = null, e.onUpdate = g.onUpdate, e.onUpdateParams = g.onUpdateParams, e.onUpdateScope = g.onUpdateScope || g.callbackScope || this, this._startAt = G.to(this.target, 0, e), j) if (this._time > 0) this._startAt = null; else if (0 !== i) return } else if (g.runBackwards && 0 !== i) if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null; else { 0 !== this._time && (j = !1), c = {}; for (d in g) U[d] && "autoCSS" !== d || (c[d] = g[d]); if (c.overwrite = 0, c.data = "isFromStart", c.lazy = j && g.lazy !== !1, c.immediateRender = j, this._startAt = G.to(this.target, 0, c), j) { if (0 === this._time) return } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null) } if (this._ease = k = k ? k instanceof v ? k : "function" == typeof k ? new v(k, g.easeParams) : w[k] || G.defaultEase : G.defaultEase, g.easeParams instanceof Array && k.config && (this._ease = k.config.apply(k, g.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (f = this._targets.length, a = 0; f > a; a++)this._initProps(this._targets[a], this._propLookup[a] = {}, this._siblings[a], h ? h[a] : null, a) && (b = !0); else b = this._initProps(this.target, this._propLookup, this._siblings, h, 0); if (b && G._onPluginEvent("_onInitAllProps", this), h && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), g.runBackwards) for (c = this._firstPT; c;)c.s += c.c, c.c = -c.c, c = c._next; this._onUpdate = g.onUpdate, this._initted = !0 }, h._initProps = function (b, c, d, e, f) { var g, h, i, j, k, l; if (null == b) return !1; K[b._gsTweenID] && Z(), this.vars.css || b.style && b !== a && b.nodeType && R.css && this.vars.autoCSS !== !1 && I(this.vars, b); for (g in this.vars) if (l = this.vars[g], U[g]) l && (l instanceof Array || l.push && p(l)) && -1 !== l.join("").indexOf("{self}") && (this.vars[g] = l = this._swapSelfInParams(l, this)); else if (R[g] && (j = new R[g])._onInitTween(b, this.vars[g], this, f)) { for (this._firstPT = k = { _next: this._firstPT, t: j, p: "setRatio", s: 0, c: 1, f: 1, n: g, pg: 1, pr: j._priority, m: 0 }, h = j._overwriteProps.length; --h > -1;)c[j._overwriteProps[h]] = this._firstPT; (j._priority || j._onInitAllProps) && (i = !0), (j._onDisable || j._onEnable) && (this._notifyPluginsOfEnabled = !0), k._next && (k._next._prev = k) } else c[g] = P.call(this, b, g, "get", l, g, 0, null, this.vars.stringFilter, f); return e && this._kill(e, b) ? this._initProps(b, c, d, e, f) : this._overwrite > 1 && this._firstPT && d.length > 1 && aa(b, this, c, this._overwrite, d) ? (this._kill(c, b), this._initProps(b, c, d, e, f)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (K[b._gsTweenID] = !0), i) }, h.render = function (a, b, c) { var d, e, f, g, h = this._time, i = this._duration, j = this._rawPrevTime; if (a >= i - 1e-7 && a >= 0) this._totalTime = this._time = i, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (d = !0, e = "onComplete", c = c || this._timeline.autoRemoveChildren), 0 === i && (this._initted || !this.vars.lazy || c) && (this._startTime === this._timeline._duration && (a = 0), (0 > j || 0 >= a && a >= -1e-7 || j === m && "isPause" !== this.data) && j !== a && (c = !0, j > m && (e = "onReverseComplete")), this._rawPrevTime = g = !b || a || j === a ? a : m); else if (1e-7 > a) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== h || 0 === i && j > 0) && (e = "onReverseComplete", d = this._reversed), 0 > a && (this._active = !1, 0 === i && (this._initted || !this.vars.lazy || c) && (j >= 0 && (j !== m || "isPause" !== this.data) && (c = !0), this._rawPrevTime = g = !b || a || j === a ? a : m)), (!this._initted || this._startAt && this._startAt.progress()) && (c = !0); else if (this._totalTime = this._time = a, this._easeType) { var k = a / i, l = this._easeType, n = this._easePower; (1 === l || 3 === l && k >= .5) && (k = 1 - k), 3 === l && (k *= 2), 1 === n ? k *= k : 2 === n ? k *= k * k : 3 === n ? k *= k * k * k : 4 === n && (k *= k * k * k * k), 1 === l ? this.ratio = 1 - k : 2 === l ? this.ratio = k : .5 > a / i ? this.ratio = k / 2 : this.ratio = 1 - k / 2 } else this.ratio = this._ease.getRatio(a / i); if (this._time !== h || c) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!c && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = h, this._rawPrevTime = j, J.push(this), void (this._lazy = [a, b]); this._time && !d ? this.ratio = this._ease.getRatio(this._time / i) : d && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== h && a >= 0 && (this._active = !0), 0 === h && (this._startAt && (a >= 0 ? this._startAt.render(a, !0, c) : e || (e = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === i) && (b || this._callback("onStart"))), f = this._firstPT; f;)f.f ? f.t[f.p](f.c * this.ratio + f.s) : f.t[f.p] = f.c * this.ratio + f.s, f = f._next; this._onUpdate && (0 > a && this._startAt && a !== -1e-4 && this._startAt.render(a, !0, c), b || (this._time !== h || d || c) && this._callback("onUpdate")), e && (!this._gc || c) && (0 > a && this._startAt && !this._onUpdate && a !== -1e-4 && this._startAt.render(a, !0, c), d && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[e] && this._callback(e), 0 === i && this._rawPrevTime === m && g !== m && (this._rawPrevTime = 0)) } }, h._kill = function (a, b, c) { if ("all" === a && (a = null), null == a && (null == b || b === this.target)) return this._lazy = !1, this._enabled(!1, !1); b = "string" != typeof b ? b || this._targets || this.target : G.selector(b) || b; var d, e, f, g, h, i, j, k, l, m = c && this._time && c._startTime === this._startTime && this._timeline === c._timeline; if ((p(b) || H(b)) && "number" != typeof b[0]) for (d = b.length; --d > -1;)this._kill(a, b[d], c) && (i = !0); else { if (this._targets) { for (d = this._targets.length; --d > -1;)if (b === this._targets[d]) { h = this._propLookup[d] || {}, this._overwrittenProps = this._overwrittenProps || [], e = this._overwrittenProps[d] = a ? this._overwrittenProps[d] || {} : "all"; break } } else { if (b !== this.target) return !1; h = this._propLookup, e = this._overwrittenProps = a ? this._overwrittenProps || {} : "all" } if (h) { if (j = a || h, k = a !== e && "all" !== e && a !== h && ("object" != typeof a || !a._tempKill), c && (G.onOverwrite || this.vars.onOverwrite)) { for (f in j) h[f] && (l || (l = []), l.push(f)); if ((l || !a) && !_(this, c, b, l)) return !1 } for (f in j) (g = h[f]) && (m && (g.f ? g.t[g.p](g.s) : g.t[g.p] = g.s, i = !0), g.pg && g.t._kill(j) && (i = !0), g.pg && 0 !== g.t._overwriteProps.length || (g._prev ? g._prev._next = g._next : g === this._firstPT && (this._firstPT = g._next), g._next && (g._next._prev = g._prev), g._next = g._prev = null), delete h[f]), k && (e[f] = 1); !this._firstPT && this._initted && this._enabled(!1, !1) } } return i }, h.invalidate = function () { return this._notifyPluginsOfEnabled && G._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], D.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -m, this.render(Math.min(0, -this._delay))), this }, h._enabled = function (a, b) { if (j || i.wake(), a && this._gc) { var c, d = this._targets; if (d) for (c = d.length; --c > -1;)this._siblings[c] = $(d[c], this, !0); else this._siblings = $(this.target, this, !0) } return D.prototype._enabled.call(this, a, b), this._notifyPluginsOfEnabled && this._firstPT ? G._onPluginEvent(a ? "_onEnable" : "_onDisable", this) : !1 }, G.to = function (a, b, c) { return new G(a, b, c) }, G.from = function (a, b, c) { return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, new G(a, b, c) }, G.fromTo = function (a, b, c, d) { return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, new G(a, b, d) }, G.delayedCall = function (a, b, c, d, e) { return new G(b, 0, { delay: a, onComplete: b, onCompleteParams: c, callbackScope: d, onReverseComplete: b, onReverseCompleteParams: c, immediateRender: !1, lazy: !1, useFrames: e, overwrite: 0 }) }, G.set = function (a, b) { return new G(a, 0, b) }, G.getTweensOf = function (a, b) { if (null == a) return []; a = "string" != typeof a ? a : G.selector(a) || a; var c, d, e, f; if ((p(a) || H(a)) && "number" != typeof a[0]) { for (c = a.length, d = []; --c > -1;)d = d.concat(G.getTweensOf(a[c], b)); for (c = d.length; --c > -1;)for (f = d[c], e = c; --e > -1;)f === d[e] && d.splice(c, 1) } else if (a._gsTweenID) for (d = $(a).concat(), c = d.length; --c > -1;)(d[c]._gc || b && !d[c].isActive()) && d.splice(c, 1); return d || [] }, G.killTweensOf = G.killDelayedCallsTo = function (a, b, c) { "object" == typeof b && (c = b, b = !1); for (var d = G.getTweensOf(a, b), e = d.length; --e > -1;)d[e]._kill(c, a) }; var ca = t("plugins.TweenPlugin", function (a, b) { this._overwriteProps = (a || "").split(","), this._propName = this._overwriteProps[0], this._priority = b || 0, this._super = ca.prototype }, !0); if (h = ca.prototype, ca.version = "1.19.0", ca.API = 2, h._firstPT = null, h._addTween = P, h.setRatio = N, h._kill = function (a) { var b, c = this._overwriteProps, d = this._firstPT; if (null != a[this._propName]) this._overwriteProps = []; else for (b = c.length; --b > -1;)null != a[c[b]] && c.splice(b, 1); for (; d;)null != a[d.n] && (d._next && (d._next._prev = d._prev), d._prev ? (d._prev._next = d._next, d._prev = null) : this._firstPT === d && (this._firstPT = d._next)), d = d._next; return !1 }, h._mod = h._roundProps = function (a) { for (var b, c = this._firstPT; c;)b = a[this._propName] || null != c.n && a[c.n.split(this._propName + "_").join("")], b && "function" == typeof b && (2 === c.f ? c.t._applyPT.m = b : c.m = b), c = c._next }, G._onPluginEvent = function (a, b) { var c, d, e, f, g, h = b._firstPT; if ("_onInitAllProps" === a) { for (; h;) { for (g = h._next, d = e; d && d.pr > h.pr;)d = d._next; (h._prev = d ? d._prev : f) ? h._prev._next = h : e = h, (h._next = d) ? d._prev = h : f = h, h = g } h = b._firstPT = e } for (; h;)h.pg && "function" == typeof h.t[a] && h.t[a]() && (c = !0), h = h._next; return c }, ca.activate = function (a) { for (var b = a.length; --b > -1;)a[b].API === ca.API && (R[(new a[b])._propName] = a[b]); return !0 }, s.plugin = function (a) { if (!(a && a.propName && a.init && a.API)) throw "illegal plugin definition."; var b, c = a.propName, d = a.priority || 0, e = a.overwriteProps, f = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" }, g = t("plugins." + c.charAt(0).toUpperCase() + c.substr(1) + "Plugin", function () { ca.call(this, c, d), this._overwriteProps = e || [] }, a.global === !0), h = g.prototype = new ca(c); h.constructor = g, g.API = a.API; for (b in f) "function" == typeof a[b] && (h[f[b]] = a[b]); return g.version = a.version, ca.activate([g]), g }, f = a._gsQueue) { for (g = 0; g < f.length; g++)f[g](); for (h in q) q[h].func || a.console.log("GSAP encountered missing dependency: " + h) } j = !1 } }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax"); !function (t) { var o = t.noise = {}; function r(t, o, r) { this.x = t, this.y = o, this.z = r } r.prototype.dot2 = function (t, o) { return this.x * t + this.y * o }, r.prototype.dot3 = function (t, o, r) { return this.x * t + this.y * o + this.z * r }; var n = [new r(1, 1, 0), new r(-1, 1, 0), new r(1, -1, 0), new r(-1, -1, 0), new r(1, 0, 1), new r(-1, 0, 1), new r(1, 0, -1), new r(-1, 0, -1), new r(0, 1, 1), new r(0, -1, 1), new r(0, 1, -1), new r(0, -1, -1)], e = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], a = new Array(512), i = new Array(512); o.seed = function (t) { t > 0 && t < 1 && (t *= 65536), (t = Math.floor(t)) < 256 && (t |= t << 8); for (var o = 0; o < 256; o++) { var r; r = 1 & o ? e[o] ^ 255 & t : e[o] ^ t >> 8 & 255, a[o] = a[o + 256] = r, i[o] = i[o + 256] = n[r % 12] } }, o.seed(0); var d = .5 * (Math.sqrt(3) - 1), f = (3 - Math.sqrt(3)) / 6, h = 1 / 6; function u(t) { return t * t * t * (t * (6 * t - 15) + 10) } function s(t, o, r) { return (1 - r) * t + r * o } o.simplex2 = function (t, o) { var r, n, e = (t + o) * d, h = Math.floor(t + e), u = Math.floor(o + e), s = (h + u) * f, l = t - h + s, w = o - u + s; l > w ? (r = 1, n = 0) : (r = 0, n = 1); var v = l - r + f, M = w - n + f, c = l - 1 + 2 * f, p = w - 1 + 2 * f, y = i[(h &= 255) + a[u &= 255]], x = i[h + r + a[u + n]], m = i[h + 1 + a[u + 1]], q = .5 - l * l - w * w, z = .5 - v * v - M * M, A = .5 - c * c - p * p; return 70 * ((q < 0 ? 0 : (q *= q) * q * y.dot2(l, w)) + (z < 0 ? 0 : (z *= z) * z * x.dot2(v, M)) + (A < 0 ? 0 : (A *= A) * A * m.dot2(c, p))) }, o.simplex3 = function (t, o, r) { var n, e, d, f, u, s, l = (t + o + r) * (1 / 3), w = Math.floor(t + l), v = Math.floor(o + l), M = Math.floor(r + l), c = (w + v + M) * h, p = t - w + c, y = o - v + c, x = r - M + c; p >= y ? y >= x ? (n = 1, e = 0, d = 0, f = 1, u = 1, s = 0) : p >= x ? (n = 1, e = 0, d = 0, f = 1, u = 0, s = 1) : (n = 0, e = 0, d = 1, f = 1, u = 0, s = 1) : y < x ? (n = 0, e = 0, d = 1, f = 0, u = 1, s = 1) : p < x ? (n = 0, e = 1, d = 0, f = 0, u = 1, s = 1) : (n = 0, e = 1, d = 0, f = 1, u = 1, s = 0); var m = p - n + h, q = y - e + h, z = x - d + h, A = p - f + 2 * h, b = y - u + 2 * h, g = x - s + 2 * h, j = p - 1 + .5, k = y - 1 + .5, B = x - 1 + .5, C = i[(w &= 255) + a[(v &= 255) + a[M &= 255]]], D = i[w + n + a[v + e + a[M + d]]], E = i[w + f + a[v + u + a[M + s]]], F = i[w + 1 + a[v + 1 + a[M + 1]]], G = .6 - p * p - y * y - x * x, H = .6 - m * m - q * q - z * z, I = .6 - A * A - b * b - g * g, J = .6 - j * j - k * k - B * B; return 32 * ((G < 0 ? 0 : (G *= G) * G * C.dot3(p, y, x)) + (H < 0 ? 0 : (H *= H) * H * D.dot3(m, q, z)) + (I < 0 ? 0 : (I *= I) * I * E.dot3(A, b, g)) + (J < 0 ? 0 : (J *= J) * J * F.dot3(j, k, B))) }, o.perlin2 = function (t, o) { var r = Math.floor(t), n = Math.floor(o); t -= r, o -= n; var e = i[(r &= 255) + a[n &= 255]].dot2(t, o), d = i[r + a[n + 1]].dot2(t, o - 1), f = i[r + 1 + a[n]].dot2(t - 1, o), h = i[r + 1 + a[n + 1]].dot2(t - 1, o - 1), l = u(t); return s(s(e, f, l), s(d, h, l), u(o)) }, o.perlin3 = function (t, o, r) { var n = Math.floor(t), e = Math.floor(o), d = Math.floor(r); t -= n, o -= e, r -= d; var f = i[(n &= 255) + a[(e &= 255) + a[d &= 255]]].dot3(t, o, r), h = i[n + a[e + a[d + 1]]].dot3(t, o, r - 1), l = i[n + a[e + 1 + a[d]]].dot3(t, o - 1, r), w = i[n + a[e + 1 + a[d + 1]]].dot3(t, o - 1, r - 1), v = i[n + 1 + a[e + a[d]]].dot3(t - 1, o, r), M = i[n + 1 + a[e + a[d + 1]]].dot3(t - 1, o, r - 1), c = i[n + 1 + a[e + 1 + a[d]]].dot3(t - 1, o - 1, r), p = i[n + 1 + a[e + 1 + a[d + 1]]].dot3(t - 1, o - 1, r - 1), y = u(t), x = u(o), m = u(r); return s(s(s(f, v, y), s(h, M, y), m), s(s(l, c, y), s(w, p, y), m), x) } }(this); !function (a, b, c, d) { function e(b, c) { this.settings = null, this.options = a.extend({}, e.Defaults, c), this.$element = a(b), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = { time: null, target: null, pointer: null, stage: { start: null, current: null }, direction: null }, this._states = { current: {}, tags: { initializing: ["busy"], animating: ["busy"], dragging: ["interacting"] } }, a.each(["onResize", "onThrottledResize"], a.proxy(function (b, c) { this._handlers[c] = a.proxy(this[c], this) }, this)), a.each(e.Plugins, a.proxy(function (a, b) { this._plugins[a.charAt(0).toLowerCase() + a.slice(1)] = new b(this) }, this)), a.each(e.Workers, a.proxy(function (b, c) { this._pipe.push({ filter: c.filter, run: a.proxy(c.run, this) }) }, this)), this.setup(), this.initialize() } e.Defaults = { items: 3, loop: !1, center: !1, rewind: !1, mouseDrag: !0, touchDrag: !0, pullDrag: !0, freeDrag: !1, margin: 0, stagePadding: 0, merge: !1, mergeFit: !0, autoWidth: !1, startPosition: 0, rtl: !1, smartSpeed: 250, fluidSpeed: !1, dragEndSpeed: !1, responsive: {}, responsiveRefreshRate: 200, responsiveBaseElement: b, fallbackEasing: "swing", info: !1, nestedItemSelector: !1, itemElement: "div", stageElement: "div", refreshClass: "owl-refresh", loadedClass: "owl-loaded", loadingClass: "owl-loading", rtlClass: "owl-rtl", responsiveClass: "owl-responsive", dragClass: "owl-drag", itemClass: "owl-item", stageClass: "owl-stage", stageOuterClass: "owl-stage-outer", grabClass: "owl-grab" }, e.Width = { Default: "default", Inner: "inner", Outer: "outer" }, e.Type = { Event: "event", State: "state" }, e.Plugins = {}, e.Workers = [{ filter: ["width", "settings"], run: function () { this._width = this.$element.width() } }, { filter: ["width", "items", "settings"], run: function (a) { a.current = this._items && this._items[this.relative(this._current)] } }, { filter: ["items", "settings"], run: function () { this.$stage.children(".cloned").remove() } }, { filter: ["width", "items", "settings"], run: function (a) { var b = this.settings.margin || "", c = !this.settings.autoWidth, d = this.settings.rtl, e = { width: "auto", "margin-left": d ? b : "", "margin-right": d ? "" : b }; !c && this.$stage.children().css(e), a.css = e } }, { filter: ["width", "items", "settings"], run: function (a) { var b = (this.width() / this.settings.items).toFixed(3) - this.settings.margin, c = null, d = this._items.length, e = !this.settings.autoWidth, f = []; for (a.items = { merge: !1, width: b }; d--;)c = this._mergers[d], c = this.settings.mergeFit && Math.min(c, this.settings.items) || c, a.items.merge = c > 1 || a.items.merge, f[d] = e ? b * c : this._items[d].width(); this._widths = f } }, { filter: ["items", "settings"], run: function () { var b = [], c = this._items, d = this.settings, e = Math.max(2 * d.items, 4), f = 2 * Math.ceil(c.length / 2), g = d.loop && c.length ? d.rewind ? e : Math.max(e, f) : 0, h = "", i = ""; for (g /= 2; g > 0;)b.push(this.normalize(b.length / 2, !0)), h += c[b[b.length - 1]][0].outerHTML, b.push(this.normalize(c.length - 1 - (b.length - 1) / 2, !0)), i = c[b[b.length - 1]][0].outerHTML + i, g -= 1; this._clones = b, a(h).addClass("cloned").appendTo(this.$stage), a(i).addClass("cloned").prependTo(this.$stage) } }, { filter: ["width", "items", "settings"], run: function () { for (var a = this.settings.rtl ? 1 : -1, b = this._clones.length + this._items.length, c = -1, d = 0, e = 0, f = []; ++c < b;)d = f[c - 1] || 0, e = this._widths[this.relative(c)] + this.settings.margin, f.push(d + e * a); this._coordinates = f } }, { filter: ["width", "items", "settings"], run: function () { var a = this.settings.stagePadding, b = this._coordinates, c = { width: Math.ceil(Math.abs(b[b.length - 1])) + 2 * a, "padding-left": a || "", "padding-right": a || "" }; this.$stage.css(c) } }, { filter: ["width", "items", "settings"], run: function (a) { var b = this._coordinates.length, c = !this.settings.autoWidth, d = this.$stage.children(); if (c && a.items.merge) for (; b--;)a.css.width = this._widths[this.relative(b)], d.eq(b).css(a.css); else c && (a.css.width = a.items.width, d.css(a.css)) } }, { filter: ["items"], run: function () { this._coordinates.length < 1 && this.$stage.removeAttr("style") } }, { filter: ["width", "items", "settings"], run: function (a) { a.current = a.current ? this.$stage.children().index(a.current) : 0, a.current = Math.max(this.minimum(), Math.min(this.maximum(), a.current)), this.reset(a.current) } }, { filter: ["position"], run: function () { this.animate(this.coordinates(this._current)) } }, { filter: ["width", "position", "items", "settings"], run: function () { var a, b, c, d, e = this.settings.rtl ? 1 : -1, f = 2 * this.settings.stagePadding, g = this.coordinates(this.current()) + f, h = g + this.width() * e, i = []; for (c = 0, d = this._coordinates.length; c < d; c++)a = this._coordinates[c - 1] || 0, b = Math.abs(this._coordinates[c]) + f * e, (this.op(a, "<=", g) && this.op(a, ">", h) || this.op(b, "<", g) && this.op(b, ">", h)) && i.push(c); this.$stage.children(".active").removeClass("active"), this.$stage.children(":eq(" + i.join("), :eq(") + ")").addClass("active"), this.$stage.children(".center").removeClass("center"), this.settings.center && this.$stage.children().eq(this.current()).addClass("center") } }], e.prototype.initializeStage = function () { this.$stage = this.$element.find("." + this.settings.stageClass), this.$stage.length || (this.$element.addClass(this.options.loadingClass), this.$stage = a("<" + this.settings.stageElement + ' class="' + this.settings.stageClass + '"/>').wrap('<div class="' + this.settings.stageOuterClass + '"/>'), this.$element.append(this.$stage.parent())) }, e.prototype.initializeItems = function () { var b = this.$element.find(".owl-item"); if (b.length) return this._items = b.get().map(function (b) { return a(b) }), this._mergers = this._items.map(function () { return 1 }), void this.refresh(); this.replace(this.$element.children().not(this.$stage.parent())), this.isVisible() ? this.refresh() : this.invalidate("width"), this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass) }, e.prototype.initialize = function () { if (this.enter("initializing"), this.trigger("initialize"), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is("pre-loading")) { var a, b, c; a = this.$element.find("img"), b = this.settings.nestedItemSelector ? "." + this.settings.nestedItemSelector : d, c = this.$element.children(b).width(), a.length && c <= 0 && this.preloadAutoWidthImages(a) } this.initializeStage(), this.initializeItems(), this.registerEventHandlers(), this.leave("initializing"), this.trigger("initialized") }, e.prototype.isVisible = function () { return !this.settings.checkVisibility || this.$element.is(":visible") }, e.prototype.setup = function () { var b = this.viewport(), c = this.options.responsive, d = -1, e = null; c ? (a.each(c, function (a) { a <= b && a > d && (d = Number(a)) }), e = a.extend({}, this.options, c[d]), "function" == typeof e.stagePadding && (e.stagePadding = e.stagePadding()), delete e.responsive, e.responsiveClass && this.$element.attr("class", this.$element.attr("class").replace(new RegExp("(" + this.options.responsiveClass + "-)\\S+\\s", "g"), "$1" + d))) : e = a.extend({}, this.options), this.trigger("change", { property: { name: "settings", value: e } }), this._breakpoint = d, this.settings = e, this.invalidate("settings"), this.trigger("changed", { property: { name: "settings", value: this.settings } }) }, e.prototype.optionsLogic = function () { this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1) }, e.prototype.prepare = function (b) { var c = this.trigger("prepare", { content: b }); return c.data || (c.data = a("<" + this.settings.itemElement + "/>").addClass(this.options.itemClass).append(b)), this.trigger("prepared", { content: c.data }), c.data }, e.prototype.update = function () { for (var b = 0, c = this._pipe.length, d = a.proxy(function (a) { return this[a] }, this._invalidated), e = {}; b < c;)(this._invalidated.all || a.grep(this._pipe[b].filter, d).length > 0) && this._pipe[b].run(e), b++; this._invalidated = {}, !this.is("valid") && this.enter("valid") }, e.prototype.width = function (a) { switch (a = a || e.Width.Default) { case e.Width.Inner: case e.Width.Outer: return this._width; default: return this._width - 2 * this.settings.stagePadding + this.settings.margin } }, e.prototype.refresh = function () { this.enter("refreshing"), this.trigger("refresh"), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave("refreshing"), this.trigger("refreshed") }, e.prototype.onThrottledResize = function () { b.clearTimeout(this.resizeTimer), this.resizeTimer = b.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate) }, e.prototype.onResize = function () { return !!this._items.length && (this._width !== this.$element.width() && (!!this.isVisible() && (this.enter("resizing"), this.trigger("resize").isDefaultPrevented() ? (this.leave("resizing"), !1) : (this.invalidate("width"), this.refresh(), this.leave("resizing"), void this.trigger("resized"))))) }, e.prototype.registerEventHandlers = function () { a.support.transition && this.$stage.on(a.support.transition.end + ".owl.core", a.proxy(this.onTransitionEnd, this)), !1 !== this.settings.responsive && this.on(b, "resize", this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on("mousedown.owl.core", a.proxy(this.onDragStart, this)), this.$stage.on("dragstart.owl.core selectstart.owl.core", function () { return !1 })), this.settings.touchDrag && (this.$stage.on("touchstart.owl.core", a.proxy(this.onDragStart, this)), this.$stage.on("touchcancel.owl.core", a.proxy(this.onDragEnd, this))) }, e.prototype.onDragStart = function (b) { var d = null; 3 !== b.which && (a.support.transform ? (d = this.$stage.css("transform").replace(/.*\(|\)| /g, "").split(","), d = { x: d[16 === d.length ? 12 : 4], y: d[16 === d.length ? 13 : 5] }) : (d = this.$stage.position(), d = { x: this.settings.rtl ? d.left + this.$stage.width() - this.width() + this.settings.margin : d.left, y: d.top }), this.is("animating") && (a.support.transform ? this.animate(d.x) : this.$stage.stop(), this.invalidate("position")), this.$element.toggleClass(this.options.grabClass, "mousedown" === b.type), this.speed(0), this._drag.time = (new Date).getTime(), this._drag.target = a(b.target), this._drag.stage.start = d, this._drag.stage.current = d, this._drag.pointer = this.pointer(b), a(c).on("mouseup.owl.core touchend.owl.core", a.proxy(this.onDragEnd, this)), a(c).one("mousemove.owl.core touchmove.owl.core", a.proxy(function (b) { var d = this.difference(this._drag.pointer, this.pointer(b)); a(c).on("mousemove.owl.core touchmove.owl.core", a.proxy(this.onDragMove, this)), Math.abs(d.x) < Math.abs(d.y) && this.is("valid") || (b.preventDefault(), this.enter("dragging"), this.trigger("drag")) }, this))) }, e.prototype.onDragMove = function (a) { var b = null, c = null, d = null, e = this.difference(this._drag.pointer, this.pointer(a)), f = this.difference(this._drag.stage.start, e); this.is("dragging") && (a.preventDefault(), this.settings.loop ? (b = this.coordinates(this.minimum()), c = this.coordinates(this.maximum() + 1) - b, f.x = ((f.x - b) % c + c) % c + b) : (b = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), c = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), d = this.settings.pullDrag ? -1 * e.x / 5 : 0, f.x = Math.max(Math.min(f.x, b + d), c + d)), this._drag.stage.current = f, this.animate(f.x)) }, e.prototype.onDragEnd = function (b) { var d = this.difference(this._drag.pointer, this.pointer(b)), e = this._drag.stage.current, f = d.x > 0 ^ this.settings.rtl ? "left" : "right"; a(c).off(".owl.core"), this.$element.removeClass(this.options.grabClass), (0 !== d.x && this.is("dragging") || !this.is("valid")) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(e.x, 0 !== d.x ? f : this._drag.direction)), this.invalidate("position"), this.update(), this._drag.direction = f, (Math.abs(d.x) > 3 || (new Date).getTime() - this._drag.time > 300) && this._drag.target.one("click.owl.core", function () { return !1 })), this.is("dragging") && (this.leave("dragging"), this.trigger("dragged")) }, e.prototype.closest = function (b, c) { var e = -1, f = 30, g = this.width(), h = this.coordinates(); return this.settings.freeDrag || a.each(h, a.proxy(function (a, i) { return "left" === c && b > i - f && b < i + f ? e = a : "right" === c && b > i - g - f && b < i - g + f ? e = a + 1 : this.op(b, "<", i) && this.op(b, ">", h[a + 1] !== d ? h[a + 1] : i - g) && (e = "left" === c ? a + 1 : a), -1 === e }, this)), this.settings.loop || (this.op(b, ">", h[this.minimum()]) ? e = b = this.minimum() : this.op(b, "<", h[this.maximum()]) && (e = b = this.maximum())), e }, e.prototype.animate = function (b) { var c = this.speed() > 0; this.is("animating") && this.onTransitionEnd(), c && (this.enter("animating"), this.trigger("translate")), a.support.transform3d && a.support.transition ? this.$stage.css({ transform: "translate3d(" + b + "px,0px,0px)", transition: this.speed() / 1e3 + "s" }) : c ? this.$stage.animate({ left: b + "px" }, this.speed(), this.settings.fallbackEasing, a.proxy(this.onTransitionEnd, this)) : this.$stage.css({ left: b + "px" }) }, e.prototype.is = function (a) { return this._states.current[a] && this._states.current[a] > 0 }, e.prototype.current = function (a) { if (a === d) return this._current; if (0 === this._items.length) return d; if (a = this.normalize(a), this._current !== a) { var b = this.trigger("change", { property: { name: "position", value: a } }); b.data !== d && (a = this.normalize(b.data)), this._current = a, this.invalidate("position"), this.trigger("changed", { property: { name: "position", value: this._current } }) } return this._current }, e.prototype.invalidate = function (b) { return "string" === a.type(b) && (this._invalidated[b] = !0, this.is("valid") && this.leave("valid")), a.map(this._invalidated, function (a, b) { return b }) }, e.prototype.reset = function (a) { (a = this.normalize(a)) !== d && (this._speed = 0, this._current = a, this.suppress(["translate", "translated"]), this.animate(this.coordinates(a)), this.release(["translate", "translated"])) }, e.prototype.normalize = function (a, b) { var c = this._items.length, e = b ? 0 : this._clones.length; return !this.isNumeric(a) || c < 1 ? a = d : (a < 0 || a >= c + e) && (a = ((a - e / 2) % c + c) % c + e / 2), a }, e.prototype.relative = function (a) { return a -= this._clones.length / 2, this.normalize(a, !0) }, e.prototype.maximum = function (a) { var b, c, d, e = this.settings, f = this._coordinates.length; if (e.loop) f = this._clones.length / 2 + this._items.length - 1; else if (e.autoWidth || e.merge) { if (b = this._items.length) for (c = this._items[--b].width(), d = this.$element.width(); b-- && !((c += this._items[b].width() + this.settings.margin) > d);); f = b + 1 } else f = e.center ? this._items.length - 1 : this._items.length - e.items; return a && (f -= this._clones.length / 2), Math.max(f, 0) }, e.prototype.minimum = function (a) { return a ? 0 : this._clones.length / 2 }, e.prototype.items = function (a) { return a === d ? this._items.slice() : (a = this.normalize(a, !0), this._items[a]) }, e.prototype.mergers = function (a) { return a === d ? this._mergers.slice() : (a = this.normalize(a, !0), this._mergers[a]) }, e.prototype.clones = function (b) { var c = this._clones.length / 2, e = c + this._items.length, f = function (a) { return a % 2 == 0 ? e + a / 2 : c - (a + 1) / 2 }; return b === d ? a.map(this._clones, function (a, b) { return f(b) }) : a.map(this._clones, function (a, c) { return a === b ? f(c) : null }) }, e.prototype.speed = function (a) { return a !== d && (this._speed = a), this._speed }, e.prototype.coordinates = function (b) { var c, e = 1, f = b - 1; return b === d ? a.map(this._coordinates, a.proxy(function (a, b) { return this.coordinates(b) }, this)) : (this.settings.center ? (this.settings.rtl && (e = -1, f = b + 1), c = this._coordinates[b], c += (this.width() - c + (this._coordinates[f] || 0)) / 2 * e) : c = this._coordinates[f] || 0, c = Math.ceil(c)) }, e.prototype.duration = function (a, b, c) { return 0 === c ? 0 : Math.min(Math.max(Math.abs(b - a), 1), 6) * Math.abs(c || this.settings.smartSpeed) }, e.prototype.to = function (a, b) { var c = this.current(), d = null, e = a - this.relative(c), f = (e > 0) - (e < 0), g = this._items.length, h = this.minimum(), i = this.maximum(); this.settings.loop ? (!this.settings.rewind && Math.abs(e) > g / 2 && (e += -1 * f * g), a = c + e, (d = ((a - h) % g + g) % g + h) !== a && d - e <= i && d - e > 0 && (c = d - e, a = d, this.reset(c))) : this.settings.rewind ? (i += 1, a = (a % i + i) % i) : a = Math.max(h, Math.min(i, a)), this.speed(this.duration(c, a, b)), this.current(a), this.isVisible() && this.update() }, e.prototype.next = function (a) { a = a || !1, this.to(this.relative(this.current()) + 1, a) }, e.prototype.prev = function (a) { a = a || !1, this.to(this.relative(this.current()) - 1, a) }, e.prototype.onTransitionEnd = function (a) { if (a !== d && (a.stopPropagation(), (a.target || a.srcElement || a.originalTarget) !== this.$stage.get(0))) return !1; this.leave("animating"), this.trigger("translated") }, e.prototype.viewport = function () { var d; return this.options.responsiveBaseElement !== b ? d = a(this.options.responsiveBaseElement).width() : b.innerWidth ? d = b.innerWidth : c.documentElement && c.documentElement.clientWidth ? d = c.documentElement.clientWidth : console.warn("Can not detect viewport width."), d }, e.prototype.replace = function (b) { this.$stage.empty(), this._items = [], b && (b = b instanceof jQuery ? b : a(b)), this.settings.nestedItemSelector && (b = b.find("." + this.settings.nestedItemSelector)), b.filter(function () { return 1 === this.nodeType }).each(a.proxy(function (a, b) { b = this.prepare(b), this.$stage.append(b), this._items.push(b), this._mergers.push(1 * b.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1) }, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate("items") }, e.prototype.add = function (b, c) { var e = this.relative(this._current); c = c === d ? this._items.length : this.normalize(c, !0), b = b instanceof jQuery ? b : a(b), this.trigger("add", { content: b, position: c }), b = this.prepare(b), 0 === this._items.length || c === this._items.length ? (0 === this._items.length && this.$stage.append(b), 0 !== this._items.length && this._items[c - 1].after(b), this._items.push(b), this._mergers.push(1 * b.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)) : (this._items[c].before(b), this._items.splice(c, 0, b), this._mergers.splice(c, 0, 1 * b.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)), this._items[e] && this.reset(this._items[e].index()), this.invalidate("items"), this.trigger("added", { content: b, position: c }) }, e.prototype.remove = function (a) { (a = this.normalize(a, !0)) !== d && (this.trigger("remove", { content: this._items[a], position: a }), this._items[a].remove(), this._items.splice(a, 1), this._mergers.splice(a, 1), this.invalidate("items"), this.trigger("removed", { content: null, position: a })) }, e.prototype.preloadAutoWidthImages = function (b) { b.each(a.proxy(function (b, c) { this.enter("pre-loading"), c = a(c), a(new Image).one("load", a.proxy(function (a) { c.attr("src", a.target.src), c.css("opacity", 1), this.leave("pre-loading"), !this.is("pre-loading") && !this.is("initializing") && this.refresh() }, this)).attr("src", c.attr("src") || c.attr("data-src") || c.attr("data-src-retina")) }, this)) }, e.prototype.destroy = function () { this.$element.off(".owl.core"), this.$stage.off(".owl.core"), a(c).off(".owl.core"), !1 !== this.settings.responsive && (b.clearTimeout(this.resizeTimer), this.off(b, "resize", this._handlers.onThrottledResize)); for (var d in this._plugins) this._plugins[d].destroy(); this.$stage.children(".cloned").remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$stage.remove(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class", this.$element.attr("class").replace(new RegExp(this.options.responsiveClass + "-\\S+\\s", "g"), "")).removeData("owl.carousel") }, e.prototype.op = function (a, b, c) { var d = this.settings.rtl; switch (b) { case "<": return d ? a > c : a < c; case ">": return d ? a < c : a > c; case ">=": return d ? a <= c : a >= c; case "<=": return d ? a >= c : a <= c } }, e.prototype.on = function (a, b, c, d) { a.addEventListener ? a.addEventListener(b, c, d) : a.attachEvent && a.attachEvent("on" + b, c) }, e.prototype.off = function (a, b, c, d) { a.removeEventListener ? a.removeEventListener(b, c, d) : a.detachEvent && a.detachEvent("on" + b, c) }, e.prototype.trigger = function (b, c, d, f, g) { var h = { item: { count: this._items.length, index: this.current() } }, i = a.camelCase(a.grep(["on", b, d], function (a) { return a }).join("-").toLowerCase()), j = a.Event([b, "owl", d || "carousel"].join(".").toLowerCase(), a.extend({ relatedTarget: this }, h, c)); return this._supress[b] || (a.each(this._plugins, function (a, b) { b.onTrigger && b.onTrigger(j) }), this.register({ type: e.Type.Event, name: b }), this.$element.trigger(j), this.settings && "function" == typeof this.settings[i] && this.settings[i].call(this, j)), j }, e.prototype.enter = function (b) { a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) { this._states.current[b] === d && (this._states.current[b] = 0), this._states.current[b]++ }, this)) }, e.prototype.leave = function (b) { a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) { this._states.current[b]-- }, this)) }, e.prototype.register = function (b) { if (b.type === e.Type.Event) { if (a.event.special[b.name] || (a.event.special[b.name] = {}), !a.event.special[b.name].owl) { var c = a.event.special[b.name]._default; a.event.special[b.name]._default = function (a) { return !c || !c.apply || a.namespace && -1 !== a.namespace.indexOf("owl") ? a.namespace && a.namespace.indexOf("owl") > -1 : c.apply(this, arguments) }, a.event.special[b.name].owl = !0 } } else b.type === e.Type.State && (this._states.tags[b.name] ? this._states.tags[b.name] = this._states.tags[b.name].concat(b.tags) : this._states.tags[b.name] = b.tags, this._states.tags[b.name] = a.grep(this._states.tags[b.name], a.proxy(function (c, d) { return a.inArray(c, this._states.tags[b.name]) === d }, this))) }, e.prototype.suppress = function (b) { a.each(b, a.proxy(function (a, b) { this._supress[b] = !0 }, this)) }, e.prototype.release = function (b) { a.each(b, a.proxy(function (a, b) { delete this._supress[b] }, this)) }, e.prototype.pointer = function (a) { var c = { x: null, y: null }; return a = a.originalEvent || a || b.event, a = a.touches && a.touches.length ? a.touches[0] : a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : a, a.pageX ? (c.x = a.pageX, c.y = a.pageY) : (c.x = a.clientX, c.y = a.clientY), c }, e.prototype.isNumeric = function (a) { return !isNaN(parseFloat(a)) }, e.prototype.difference = function (a, b) { return { x: a.x - b.x, y: a.y - b.y } }, a.fn.owlCarousel = function (b) { var c = Array.prototype.slice.call(arguments, 1); return this.each(function () { var d = a(this), f = d.data("owl.carousel"); f || (f = new e(this, "object" == typeof b && b), d.data("owl.carousel", f), a.each(["next", "prev", "to", "destroy", "refresh", "replace", "add", "remove"], function (b, c) { f.register({ type: e.Type.Event, name: c }), f.$element.on(c + ".owl.carousel.core", a.proxy(function (a) { a.namespace && a.relatedTarget !== this && (this.suppress([c]), f[c].apply(this, [].slice.call(arguments, 1)), this.release([c])) }, f)) })), "string" == typeof b && "_" !== b.charAt(0) && f[b].apply(f, c) }) }, a.fn.owlCarousel.Constructor = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { var e = function (b) { this._core = b, this._interval = null, this._visible = null, this._handlers = { "initialized.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.autoRefresh && this.watch() }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers) }; e.Defaults = { autoRefresh: !0, autoRefreshInterval: 500 }, e.prototype.watch = function () { this._interval || (this._visible = this._core.isVisible(), this._interval = b.setInterval(a.proxy(this.refresh, this), this._core.settings.autoRefreshInterval)) }, e.prototype.refresh = function () { this._core.isVisible() !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass("owl-hidden", !this._visible), this._visible && this._core.invalidate("width") && this._core.refresh()) }, e.prototype.destroy = function () { var a, c; b.clearInterval(this._interval); for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (c in Object.getOwnPropertyNames(this)) "function" != typeof this[c] && (this[c] = null) }, a.fn.owlCarousel.Constructor.Plugins.AutoRefresh = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { var e = function (b) { this._core = b, this._loaded = [], this._handlers = { "initialized.owl.carousel change.owl.carousel resized.owl.carousel": a.proxy(function (b) { if (b.namespace && this._core.settings && this._core.settings.lazyLoad && (b.property && "position" == b.property.name || "initialized" == b.type)) for (var c = this._core.settings, e = c.center && Math.ceil(c.items / 2) || c.items, f = c.center && -1 * e || 0, g = (b.property && b.property.value !== d ? b.property.value : this._core.current()) + f, h = this._core.clones().length, i = a.proxy(function (a, b) { this.load(b) }, this); f++ < e;)this.load(h / 2 + this._core.relative(g)), h && a.each(this._core.clones(this._core.relative(g)), i), g++ }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers) }; e.Defaults = { lazyLoad: !1 }, e.prototype.load = function (c) { var d = this._core.$stage.children().eq(c), e = d && d.find(".owl-lazy"); !e || a.inArray(d.get(0), this._loaded) > -1 || (e.each(a.proxy(function (c, d) { var e, f = a(d), g = b.devicePixelRatio > 1 && f.attr("data-src-retina") || f.attr("data-src") || f.attr("data-srcset"); this._core.trigger("load", { element: f, url: g }, "lazy"), f.is("img") ? f.one("load.owl.lazy", a.proxy(function () { f.css("opacity", 1), this._core.trigger("loaded", { element: f, url: g }, "lazy") }, this)).attr("src", g) : f.is("source") ? f.one("load.owl.lazy", a.proxy(function () { this._core.trigger("loaded", { element: f, url: g }, "lazy") }, this)).attr("srcset", g) : (e = new Image, e.onload = a.proxy(function () { f.css({ "background-image": 'url("' + g + '")', opacity: "1" }), this._core.trigger("loaded", { element: f, url: g }, "lazy") }, this), e.src = g) }, this)), this._loaded.push(d.get(0))) }, e.prototype.destroy = function () { var a, b; for (a in this.handlers) this._core.$element.off(a, this.handlers[a]); for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.Lazy = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { var e = function (c) { this._core = c, this._handlers = { "initialized.owl.carousel refreshed.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.autoHeight && this.update() }, this), "changed.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.autoHeight && "position" === a.property.name && (console.log("update called"), this.update()) }, this), "loaded.owl.lazy": a.proxy(function (a) { a.namespace && this._core.settings.autoHeight && a.element.closest("." + this._core.settings.itemClass).index() === this._core.current() && this.update() }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._intervalId = null; var d = this; a(b).on("load", function () { d._core.settings.autoHeight && d.update() }), a(b).resize(function () { d._core.settings.autoHeight && (null != d._intervalId && clearTimeout(d._intervalId), d._intervalId = setTimeout(function () { d.update() }, 250)) }) }; e.Defaults = { autoHeight: !1, autoHeightClass: "owl-height" }, e.prototype.update = function () { var b = this._core._current, c = b + this._core.settings.items, d = this._core.$stage.children().toArray().slice(b, c), e = [], f = 0; a.each(d, function (b, c) { e.push(a(c).height()) }), f = Math.max.apply(null, e), this._core.$stage.parent().height(f).addClass(this._core.settings.autoHeightClass) }, e.prototype.destroy = function () { var a, b; for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.AutoHeight = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { var e = function (b) { this._core = b, this._videos = {}, this._playing = null, this._handlers = { "initialized.owl.carousel": a.proxy(function (a) { a.namespace && this._core.register({ type: "state", name: "playing", tags: ["interacting"] }) }, this), "resize.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.video && this.isInFullScreen() && a.preventDefault() }, this), "refreshed.owl.carousel": a.proxy(function (a) { a.namespace && this._core.is("resizing") && this._core.$stage.find(".cloned .owl-video-frame").remove() }, this), "changed.owl.carousel": a.proxy(function (a) { a.namespace && "position" === a.property.name && this._playing && this.stop() }, this), "prepared.owl.carousel": a.proxy(function (b) { if (b.namespace) { var c = a(b.content).find(".owl-video"); c.length && (c.css("display", "none"), this.fetch(c, a(b.content))) } }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on("click.owl.video", ".owl-video-play-icon", a.proxy(function (a) { this.play(a) }, this)) }; e.Defaults = { video: !1, videoHeight: !1, videoWidth: !1 }, e.prototype.fetch = function (a, b) { var c = function () { return a.attr("data-vimeo-id") ? "vimeo" : a.attr("data-vzaar-id") ? "vzaar" : "youtube" }(), d = a.attr("data-vimeo-id") || a.attr("data-youtube-id") || a.attr("data-vzaar-id"), e = a.attr("data-width") || this._core.settings.videoWidth, f = a.attr("data-height") || this._core.settings.videoHeight, g = a.attr("href"); if (!g) throw new Error("Missing video URL."); if (d = g.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/), d[3].indexOf("youtu") > -1) c = "youtube"; else if (d[3].indexOf("vimeo") > -1) c = "vimeo"; else { if (!(d[3].indexOf("vzaar") > -1)) throw new Error("Video URL not supported."); c = "vzaar" } d = d[6], this._videos[g] = { type: c, id: d, width: e, height: f }, b.attr("data-video", g), this.thumbnail(a, this._videos[g]) }, e.prototype.thumbnail = function (b, c) { var d, e, f, g = c.width && c.height ? 'style="width:' + c.width + "px;height:" + c.height + 'px;"' : "", h = b.find("img"), i = "src", j = "", k = this._core.settings, l = function (a) { e = '<div class="owl-video-play-icon"></div>', d = k.lazyLoad ? '<div class="owl-video-tn ' + j + '" ' + i + '="' + a + '"></div>' : '<div class="owl-video-tn" style="opacity:1;background-image:url(' + a + ')"></div>', b.after(d), b.after(e) }; if (b.wrap('<div class="owl-video-wrapper"' + g + "></div>"), this._core.settings.lazyLoad && (i = "data-src", j = "owl-lazy"), h.length) return l(h.attr(i)), h.remove(), !1; "youtube" === c.type ? (f = "//img.youtube.com/vi/" + c.id + "/hqdefault.jpg", l(f)) : "vimeo" === c.type ? a.ajax({ type: "GET", url: "//vimeo.com/api/v2/video/" + c.id + ".json", jsonp: "callback", dataType: "jsonp", success: function (a) { f = a[0].thumbnail_large, l(f) } }) : "vzaar" === c.type && a.ajax({ type: "GET", url: "//vzaar.com/api/videos/" + c.id + ".json", jsonp: "callback", dataType: "jsonp", success: function (a) { f = a.framegrab_url, l(f) } }) }, e.prototype.stop = function () { this._core.trigger("stop", null, "video"), this._playing.find(".owl-video-frame").remove(), this._playing.removeClass("owl-video-playing"), this._playing = null, this._core.leave("playing"), this._core.trigger("stopped", null, "video") }, e.prototype.play = function (b) { var c, d = a(b.target), e = d.closest("." + this._core.settings.itemClass), f = this._videos[e.attr("data-video")], g = f.width || "100%", h = f.height || this._core.$stage.height(); this._playing || (this._core.enter("playing"), this._core.trigger("play", null, "video"), e = this._core.items(this._core.relative(e.index())), this._core.reset(e.index()), "youtube" === f.type ? c = '<iframe width="' + g + '" height="' + h + '" src="//www.youtube.com/embed/' + f.id + "?autoplay=1&rel=0&v=" + f.id + '" frameborder="0" allowfullscreen></iframe>' : "vimeo" === f.type ? c = '<iframe src="//player.vimeo.com/video/' + f.id + '?autoplay=1" width="' + g + '" height="' + h + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>' : "vzaar" === f.type && (c = '<iframe frameborder="0"height="' + h + '"width="' + g + '" allowfullscreen mozallowfullscreen webkitAllowFullScreen src="//view.vzaar.com/' + f.id + '/player?autoplay=true"></iframe>'), a('<div class="owl-video-frame">' + c + "</div>").insertAfter(e.find(".owl-video")), this._playing = e.addClass("owl-video-playing")) }, e.prototype.isInFullScreen = function () { var b = c.fullscreenElement || c.mozFullScreenElement || c.webkitFullscreenElement; return b && a(b).parent().hasClass("owl-video-frame") }, e.prototype.destroy = function () { var a, b; this._core.$element.off("click.owl.video"); for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.Video = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { var e = function (b) { this.core = b, this.core.options = a.extend({}, e.Defaults, this.core.options), this.swapping = !0, this.previous = d, this.next = d, this.handlers = { "change.owl.carousel": a.proxy(function (a) { a.namespace && "position" == a.property.name && (this.previous = this.core.current(), this.next = a.property.value) }, this), "drag.owl.carousel dragged.owl.carousel translated.owl.carousel": a.proxy(function (a) { a.namespace && (this.swapping = "translated" == a.type) }, this), "translate.owl.carousel": a.proxy(function (a) { a.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap() }, this) }, this.core.$element.on(this.handlers) }; e.Defaults = { animateOut: !1, animateIn: !1 }, e.prototype.swap = function () { if (1 === this.core.settings.items && a.support.animation && a.support.transition) { this.core.speed(0); var b, c = a.proxy(this.clear, this), d = this.core.$stage.children().eq(this.previous), e = this.core.$stage.children().eq(this.next), f = this.core.settings.animateIn, g = this.core.settings.animateOut; this.core.current() !== this.previous && (g && (b = this.core.coordinates(this.previous) - this.core.coordinates(this.next), d.one(a.support.animation.end, c).css({ left: b + "px" }).addClass("animated owl-animated-out").addClass(g)), f && e.one(a.support.animation.end, c).addClass("animated owl-animated-in").addClass(f)) } }, e.prototype.clear = function (b) { a(b.target).css({ left: "" }).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd() }, e.prototype.destroy = function () { var a, b; for (a in this.handlers) this.core.$element.off(a, this.handlers[a]); for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.Animate = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { var e = function (b) { this._core = b, this._call = null, this._time = 0, this._timeout = 0, this._paused = !0, this._handlers = { "changed.owl.carousel": a.proxy(function (a) { a.namespace && "settings" === a.property.name ? this._core.settings.autoplay ? this.play() : this.stop() : a.namespace && "position" === a.property.name && this._paused && (this._time = 0) }, this), "initialized.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.autoplay && this.play() }, this), "play.owl.autoplay": a.proxy(function (a, b, c) { a.namespace && this.play(b, c) }, this), "stop.owl.autoplay": a.proxy(function (a) { a.namespace && this.stop() }, this), "mouseover.owl.autoplay": a.proxy(function () { this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause() }, this), "mouseleave.owl.autoplay": a.proxy(function () { this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.play() }, this), "touchstart.owl.core": a.proxy(function () { this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause() }, this), "touchend.owl.core": a.proxy(function () { this._core.settings.autoplayHoverPause && this.play() }, this) }, this._core.$element.on(this._handlers), this._core.options = a.extend({}, e.Defaults, this._core.options) }; e.Defaults = { autoplay: !1, autoplayTimeout: 5e3, autoplayHoverPause: !1, autoplaySpeed: !1 }, e.prototype._next = function (d) { this._call = b.setTimeout(a.proxy(this._next, this, d), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()), this._core.is("busy") || this._core.is("interacting") || c.hidden || this._core.next(d || this._core.settings.autoplaySpeed) }, e.prototype.read = function () { return (new Date).getTime() - this._time }, e.prototype.play = function (c, d) { var e; this._core.is("rotating") || this._core.enter("rotating"), c = c || this._core.settings.autoplayTimeout, e = Math.min(this._time % (this._timeout || c), c), this._paused ? (this._time = this.read(), this._paused = !1) : b.clearTimeout(this._call), this._time += this.read() % c - e, this._timeout = c, this._call = b.setTimeout(a.proxy(this._next, this, d), c - e) }, e.prototype.stop = function () { this._core.is("rotating") && (this._time = 0, this._paused = !0, b.clearTimeout(this._call), this._core.leave("rotating")) }, e.prototype.pause = function () { this._core.is("rotating") && !this._paused && (this._time = this.read(), this._paused = !0, b.clearTimeout(this._call)) }, e.prototype.destroy = function () { var a, b; this.stop(); for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.autoplay = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { "use strict"; var e = function (b) { this._core = b, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = { next: this._core.next, prev: this._core.prev, to: this._core.to }, this._handlers = { "prepared.owl.carousel": a.proxy(function (b) { b.namespace && this._core.settings.dotsData && this._templates.push('<div class="' + this._core.settings.dotClass + '">' + a(b.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot") + "</div>") }, this), "added.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 0, this._templates.pop()) }, this), "remove.owl.carousel": a.proxy(function (a) { a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 1) }, this), "changed.owl.carousel": a.proxy(function (a) { a.namespace && "position" == a.property.name && this.draw() }, this), "initialized.owl.carousel": a.proxy(function (a) { a.namespace && !this._initialized && (this._core.trigger("initialize", null, "navigation"), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger("initialized", null, "navigation")) }, this), "refreshed.owl.carousel": a.proxy(function (a) { a.namespace && this._initialized && (this._core.trigger("refresh", null, "navigation"), this.update(), this.draw(), this._core.trigger("refreshed", null, "navigation")) }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers) }; e.Defaults = { nav: !1, navText: ['<span aria-label="Previous">&#x2039;</span>', '<span aria-label="Next">&#x203a;</span>'], navSpeed: !1, navElement: 'button type="button" role="presentation"', navContainer: !1, navContainerClass: "owl-nav", navClass: ["owl-prev", "owl-next"], slideBy: 1, dotClass: "owl-dot", dotsClass: "owl-dots", dots: !0, dotsEach: !1, dotsData: !1, dotsSpeed: !1, dotsContainer: !1 }, e.prototype.initialize = function () { var b, c = this._core.settings; this._controls.$relative = (c.navContainer ? a(c.navContainer) : a("<div>").addClass(c.navContainerClass).appendTo(this.$element)).addClass("disabled"), this._controls.$previous = a("<" + c.navElement + ">").addClass(c.navClass[0]).html(c.navText[0]).prependTo(this._controls.$relative).on("click", a.proxy(function (a) { this.prev(c.navSpeed) }, this)), this._controls.$next = a("<" + c.navElement + ">").addClass(c.navClass[1]).html(c.navText[1]).appendTo(this._controls.$relative).on("click", a.proxy(function (a) { this.next(c.navSpeed) }, this)), c.dotsData || (this._templates = [a('<button role="button">').addClass(c.dotClass).append(a("<span>")).prop("outerHTML")]), this._controls.$absolute = (c.dotsContainer ? a(c.dotsContainer) : a("<div>").addClass(c.dotsClass).appendTo(this.$element)).addClass("disabled"), this._controls.$absolute.on("click", "button", a.proxy(function (b) { var d = a(b.target).parent().is(this._controls.$absolute) ? a(b.target).index() : a(b.target).parent().index(); b.preventDefault(), this.to(d, c.dotsSpeed) }, this)); for (b in this._overrides) this._core[b] = a.proxy(this[b], this) }, e.prototype.destroy = function () { var a, b, c, d, e; e = this._core.settings; for (a in this._handlers) this.$element.off(a, this._handlers[a]); for (b in this._controls) "$relative" === b && e.navContainer ? this._controls[b].html("") : this._controls[b].remove(); for (d in this.overides) this._core[d] = this._overrides[d]; for (c in Object.getOwnPropertyNames(this)) "function" != typeof this[c] && (this[c] = null) }, e.prototype.update = function () { var a, b, c, d = this._core.clones().length / 2, e = d + this._core.items().length, f = this._core.maximum(!0), g = this._core.settings, h = g.center || g.autoWidth || g.dotsData ? 1 : g.dotsEach || g.items; if ("page" !== g.slideBy && (g.slideBy = Math.min(g.slideBy, g.items)), g.dots || "page" == g.slideBy) for (this._pages = [], a = d, b = 0, c = 0; a < e; a++) { if (b >= h || 0 === b) { if (this._pages.push({ start: Math.min(f, a - d), end: a - d + h - 1 }), Math.min(f, a - d) === f) break; b = 0, ++c } b += this._core.mergers(this._core.relative(a)) } }, e.prototype.draw = function () { var b, c = this._core.settings, d = this._core.items().length <= c.items, e = this._core.relative(this._core.current()), f = c.loop || c.rewind; this._controls.$relative.toggleClass("disabled", !c.nav || d), c.nav && (this._controls.$previous.toggleClass("disabled", !f && e <= this._core.minimum(!0)), this._controls.$next.toggleClass("disabled", !f && e >= this._core.maximum(!0))), this._controls.$absolute.toggleClass("disabled", !c.dots || d), c.dots && (b = this._pages.length - this._controls.$absolute.children().length, c.dotsData && 0 !== b ? this._controls.$absolute.html(this._templates.join("")) : b > 0 ? this._controls.$absolute.append(new Array(b + 1).join(this._templates[0])) : b < 0 && this._controls.$absolute.children().slice(b).remove(), this._controls.$absolute.find(".active").removeClass("active"), this._controls.$absolute.children().eq(a.inArray(this.current(), this._pages)).addClass("active")) }, e.prototype.onTrigger = function (b) { var c = this._core.settings; b.page = { index: a.inArray(this.current(), this._pages), count: this._pages.length, size: c && (c.center || c.autoWidth || c.dotsData ? 1 : c.dotsEach || c.items) } }, e.prototype.current = function () { var b = this._core.relative(this._core.current()); return a.grep(this._pages, a.proxy(function (a, c) { return a.start <= b && a.end >= b }, this)).pop() }, e.prototype.getPosition = function (b) { var c, d, e = this._core.settings; return "page" == e.slideBy ? (c = a.inArray(this.current(), this._pages), d = this._pages.length, b ? ++c : --c, c = this._pages[(c % d + d) % d].start) : (c = this._core.relative(this._core.current()), d = this._core.items().length, b ? c += e.slideBy : c -= e.slideBy), c }, e.prototype.next = function (b) { a.proxy(this._overrides.to, this._core)(this.getPosition(!0), b) }, e.prototype.prev = function (b) { a.proxy(this._overrides.to, this._core)(this.getPosition(!1), b) }, e.prototype.to = function (b, c, d) { var e; !d && this._pages.length ? (e = this._pages.length, a.proxy(this._overrides.to, this._core)(this._pages[(b % e + e) % e].start, c)) : a.proxy(this._overrides.to, this._core)(b, c) }, a.fn.owlCarousel.Constructor.Plugins.Navigation = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { "use strict"; var e = function (c) { this._core = c, this._hashes = {}, this.$element = this._core.$element, this._handlers = { "initialized.owl.carousel": a.proxy(function (c) { c.namespace && "URLHash" === this._core.settings.startPosition && a(b).trigger("hashchange.owl.navigation") }, this), "prepared.owl.carousel": a.proxy(function (b) { if (b.namespace) { var c = a(b.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash"); if (!c) return; this._hashes[c] = b.content } }, this), "changed.owl.carousel": a.proxy(function (c) { if (c.namespace && "position" === c.property.name) { var d = this._core.items(this._core.relative(this._core.current())), e = a.map(this._hashes, function (a, b) { return a === d ? b : null }).join(); if (!e || b.location.hash.slice(1) === e) return; b.location.hash = e } }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers), a(b).on("hashchange.owl.navigation", a.proxy(function (a) { var c = b.location.hash.substring(1), e = this._core.$stage.children(), f = this._hashes[c] && e.index(this._hashes[c]); f !== d && f !== this._core.current() && this._core.to(this._core.relative(f), !1, !0) }, this)) }; e.Defaults = { URLhashListener: !1 }, e.prototype.destroy = function () { var c, d; a(b).off("hashchange.owl.navigation"); for (c in this._handlers) this._core.$element.off(c, this._handlers[c]); for (d in Object.getOwnPropertyNames(this)) "function" != typeof this[d] && (this[d] = null) }, a.fn.owlCarousel.Constructor.Plugins.Hash = e }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) { function e(b, c) { var e = !1, f = b.charAt(0).toUpperCase() + b.slice(1); return a.each((b + " " + h.join(f + " ") + f).split(" "), function (a, b) { if (g[b] !== d) return e = !c || b, !1 }), e } function f(a) { return e(a, !0) } var g = a("<support>").get(0).style, h = "Webkit Moz O ms".split(" "), i = { transition: { end: { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd", transition: "transitionend" } }, animation: { end: { WebkitAnimation: "webkitAnimationEnd", MozAnimation: "animationend", OAnimation: "oAnimationEnd", animation: "animationend" } } }, j = { csstransforms: function () { return !!e("transform") }, csstransforms3d: function () { return !!e("perspective") }, csstransitions: function () { return !!e("transition") }, cssanimations: function () { return !!e("animation") } }; j.csstransitions() && (a.support.transition = new String(f("transition")), a.support.transition.end = i.transition.end[a.support.transition]), j.cssanimations() && (a.support.animation = new String(f("animation")), a.support.animation.end = i.animation.end[a.support.animation]), j.csstransforms() && (a.support.transform = new String(f("transform")), a.support.transform3d = j.csstransforms3d()) }(window.Zepto || window.jQuery, window, document);/*!
* jquery.counterup.js 1.0
*
* Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
* Released under the GPL v2 License
*
* Date: Nov 26, 2013
*/!function (t) { "use strict"; t.fn.countUp = function (e) { var a = t.extend({ time: 2e3, delay: 10 }, e); return this.each(function () { var e = t(this), n = a, u = function () { e.data("counterupTo") || e.data("counterupTo", e.text()); var t = parseInt(e.data("counter-time")) > 0 ? parseInt(e.data("counter-time")) : n.time, a = parseInt(e.data("counter-delay")) > 0 ? parseInt(e.data("counter-delay")) : n.delay, u = t / a, r = e.data("counterupTo"), o = [r], c = /[0-9]+,[0-9]+/.test(r); r = r.replace(/,/g, ""); for (var d = (/^[0-9]+$/.test(r), /^[0-9]+\.[0-9]+$/.test(r)), s = d ? (r.split(".")[1] || []).length : 0, i = u; i >= 1; i--) { var p = parseInt(Math.round(r / u * i)); if (d && (p = parseFloat(r / u * i).toFixed(s)), c) for (; /(\d+)(\d{3})/.test(p.toString());)p = p.toString().replace(/(\d+)(\d{3})/, "$1,$2"); o.unshift(p) } e.data("counterup-nums", o), e.text("0"); var f = function () { e.text(e.data("counterup-nums").shift()), e.data("counterup-nums").length ? setTimeout(e.data("counterup-func"), a) : (delete e.data("counterup-nums"), e.data("counterup-nums", null), e.data("counterup-func", null)) }; e.data("counterup-func", f), setTimeout(e.data("counterup-func"), a) }; e.waypoint(u, { offset: "100%", triggerOnce: !0 }) }) } }(jQuery);/*!
Waypoints - 4.0.0
Copyright Â© 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/(function () {
    'use strict'
    var keyCounter = 0
    var allWaypoints = {}
    function Waypoint(options) {
        if (!options) { throw new Error('No options passed to Waypoint constructor') }
        if (!options.element) { throw new Error('No element option passed to Waypoint constructor') }
        if (!options.handler) { throw new Error('No handler option passed to Waypoint constructor') }
        this.key = 'waypoint-' + keyCounter
        this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)
        this.element = this.options.element
        this.adapter = new Waypoint.Adapter(this.element)
        this.callback = options.handler
        this.axis = this.options.horizontal ? 'horizontal' : 'vertical'
        this.enabled = this.options.enabled
        this.triggerPoint = null
        this.group = Waypoint.Group.findOrCreate({ name: this.options.group, axis: this.axis })
        this.context = Waypoint.Context.findOrCreateByElement(this.options.context)
        if (Waypoint.offsetAliases[this.options.offset]) { this.options.offset = Waypoint.offsetAliases[this.options.offset] }
        this.group.add(this)
        this.context.add(this)
        allWaypoints[this.key] = this
        keyCounter += 1
    }
    Waypoint.prototype.queueTrigger = function (direction) { this.group.queueTrigger(this, direction) }
    Waypoint.prototype.trigger = function (args) {
        if (!this.enabled) { return }
        if (this.callback) { this.callback.apply(this, args) }
    }
    Waypoint.prototype.destroy = function () {
        this.context.remove(this)
        this.group.remove(this)
        delete allWaypoints[this.key]
    }
    Waypoint.prototype.disable = function () {
        this.enabled = false
        return this
    }
    Waypoint.prototype.enable = function () {
        this.context.refresh()
        this.enabled = true
        return this
    }
    Waypoint.prototype.next = function () { return this.group.next(this) }
    Waypoint.prototype.previous = function () { return this.group.previous(this) }
    Waypoint.invokeAll = function (method) {
        var allWaypointsArray = []
        for (var waypointKey in allWaypoints) { allWaypointsArray.push(allWaypoints[waypointKey]) }
        for (var i = 0, end = allWaypointsArray.length; i < end; i++) { allWaypointsArray[i][method]() }
    }
    Waypoint.destroyAll = function () { Waypoint.invokeAll('destroy') }
    Waypoint.disableAll = function () { Waypoint.invokeAll('disable') }
    Waypoint.enableAll = function () { Waypoint.invokeAll('enable') }
    Waypoint.refreshAll = function () { Waypoint.Context.refreshAll() }
    Waypoint.viewportHeight = function () { return window.innerHeight || document.documentElement.clientHeight }
    Waypoint.viewportWidth = function () { return document.documentElement.clientWidth }
    Waypoint.adapters = []
    Waypoint.defaults = { context: window, continuous: true, enabled: true, group: 'default', horizontal: false, offset: 0 }
    Waypoint.offsetAliases = { 'bottom-in-view': function () { return this.context.innerHeight() - this.adapter.outerHeight() }, 'right-in-view': function () { return this.context.innerWidth() - this.adapter.outerWidth() } }
    window.Waypoint = Waypoint
}()); (function () {
    'use strict'
    function requestAnimationFrameShim(callback) { window.setTimeout(callback, 1000 / 60) }
    var keyCounter = 0
    var contexts = {}
    var Waypoint = window.Waypoint
    var oldWindowLoad = window.onload
    function Context(element) {
        this.element = element
        this.Adapter = Waypoint.Adapter
        this.adapter = new this.Adapter(element)
        this.key = 'waypoint-context-' + keyCounter
        this.didScroll = false
        this.didResize = false
        this.oldScroll = { x: this.adapter.scrollLeft(), y: this.adapter.scrollTop() }
        this.waypoints = { vertical: {}, horizontal: {} }
        element.waypointContextKey = this.key
        contexts[element.waypointContextKey] = this
        keyCounter += 1
        this.createThrottledScrollHandler()
        this.createThrottledResizeHandler()
    }
    Context.prototype.add = function (waypoint) {
        var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'
        this.waypoints[axis][waypoint.key] = waypoint
        this.refresh()
    }
    Context.prototype.checkEmpty = function () {
        var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)
        var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)
        if (horizontalEmpty && verticalEmpty) {
            this.adapter.off('.waypoints')
            delete contexts[this.key]
        }
    }
    Context.prototype.createThrottledResizeHandler = function () {
        var self = this
        function resizeHandler() {
            self.handleResize()
            self.didResize = false
        }
        this.adapter.on('resize.waypoints', function () {
            if (!self.didResize) {
                self.didResize = true
                Waypoint.requestAnimationFrame(resizeHandler)
            }
        })
    }
    Context.prototype.createThrottledScrollHandler = function () {
        var self = this
        function scrollHandler() {
            self.handleScroll()
            self.didScroll = false
        }
        this.adapter.on('scroll.waypoints', function () {
            if (!self.didScroll || Waypoint.isTouch) {
                self.didScroll = true
                Waypoint.requestAnimationFrame(scrollHandler)
            }
        })
    }
    Context.prototype.handleResize = function () { Waypoint.Context.refreshAll() }
    Context.prototype.handleScroll = function () {
        var triggeredGroups = {}
        var axes = { horizontal: { newScroll: this.adapter.scrollLeft(), oldScroll: this.oldScroll.x, forward: 'right', backward: 'left' }, vertical: { newScroll: this.adapter.scrollTop(), oldScroll: this.oldScroll.y, forward: 'down', backward: 'up' } }
        for (var axisKey in axes) {
            var axis = axes[axisKey]
            var isForward = axis.newScroll > axis.oldScroll
            var direction = isForward ? axis.forward : axis.backward
            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey]
                var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint
                var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint
                var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
                var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint
                if (crossedForward || crossedBackward) {
                    waypoint.queueTrigger(direction)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
            }
        }
        for (var groupKey in triggeredGroups) { triggeredGroups[groupKey].flushTriggers() }
        this.oldScroll = { x: axes.horizontal.newScroll, y: axes.vertical.newScroll }
    }
    Context.prototype.innerHeight = function () {
        if (this.element == this.element.window) { return Waypoint.viewportHeight() }
        return this.adapter.innerHeight()
    }
    Context.prototype.remove = function (waypoint) {
        delete this.waypoints[waypoint.axis][waypoint.key]
        this.checkEmpty()
    }
    Context.prototype.innerWidth = function () {
        if (this.element == this.element.window) { return Waypoint.viewportWidth() }
        return this.adapter.innerWidth()
    }
    Context.prototype.destroy = function () {
        var allWaypoints = []
        for (var axis in this.waypoints) { for (var waypointKey in this.waypoints[axis]) { allWaypoints.push(this.waypoints[axis][waypointKey]) } }
        for (var i = 0, end = allWaypoints.length; i < end; i++) { allWaypoints[i].destroy() }
    }
    Context.prototype.refresh = function () {
        var isWindow = this.element == this.element.window
        var contextOffset = isWindow ? undefined : this.adapter.offset()
        var triggeredGroups = {}
        var axes
        this.handleScroll()
        axes = { horizontal: { contextOffset: isWindow ? 0 : contextOffset.left, contextScroll: isWindow ? 0 : this.oldScroll.x, contextDimension: this.innerWidth(), oldScroll: this.oldScroll.x, forward: 'right', backward: 'left', offsetProp: 'left' }, vertical: { contextOffset: isWindow ? 0 : contextOffset.top, contextScroll: isWindow ? 0 : this.oldScroll.y, contextDimension: this.innerHeight(), oldScroll: this.oldScroll.y, forward: 'down', backward: 'up', offsetProp: 'top' } }
        for (var axisKey in axes) {
            var axis = axes[axisKey]
            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey]
                var adjustment = waypoint.options.offset
                var oldTriggerPoint = waypoint.triggerPoint
                var elementOffset = 0
                var freshWaypoint = oldTriggerPoint == null
                var contextModifier, wasBeforeScroll, nowAfterScroll
                var triggeredBackward, triggeredForward
                if (waypoint.element !== waypoint.element.window) { elementOffset = waypoint.adapter.offset()[axis.offsetProp] }
                if (typeof adjustment === 'function') { adjustment = adjustment.apply(waypoint) }
                else if (typeof adjustment === 'string') {
                    adjustment = parseFloat(adjustment)
                    if (waypoint.options.offset.indexOf('%') > -1) { adjustment = Math.ceil(axis.contextDimension * adjustment / 100) }
                }
                contextModifier = axis.contextScroll - axis.contextOffset
                waypoint.triggerPoint = elementOffset + contextModifier - adjustment
                wasBeforeScroll = oldTriggerPoint < axis.oldScroll
                nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll
                triggeredBackward = wasBeforeScroll && nowAfterScroll
                triggeredForward = !wasBeforeScroll && !nowAfterScroll
                if (!freshWaypoint && triggeredBackward) {
                    waypoint.queueTrigger(axis.backward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
                else if (!freshWaypoint && triggeredForward) {
                    waypoint.queueTrigger(axis.forward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
                else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
                    waypoint.queueTrigger(axis.forward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
            }
        }
        Waypoint.requestAnimationFrame(function () { for (var groupKey in triggeredGroups) { triggeredGroups[groupKey].flushTriggers() } })
        return this
    }
    Context.findOrCreateByElement = function (element) { return Context.findByElement(element) || new Context(element) }
    Context.refreshAll = function () { for (var contextId in contexts) { contexts[contextId].refresh() } }
    Context.findByElement = function (element) { return contexts[element.waypointContextKey] }
    window.onload = function () {
        if (oldWindowLoad) { oldWindowLoad() }
        Context.refreshAll()
    }
    Waypoint.requestAnimationFrame = function (callback) {
        var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim
        requestFn.call(window, callback)
    }
    Waypoint.Context = Context
}()); (function () {
    'use strict'
    function byTriggerPoint(a, b) { return a.triggerPoint - b.triggerPoint }
    function byReverseTriggerPoint(a, b) { return b.triggerPoint - a.triggerPoint }
    var groups = { vertical: {}, horizontal: {} }
    var Waypoint = window.Waypoint
    function Group(options) {
        this.name = options.name
        this.axis = options.axis
        this.id = this.name + '-' + this.axis
        this.waypoints = []
        this.clearTriggerQueues()
        groups[this.axis][this.name] = this
    }
    Group.prototype.add = function (waypoint) { this.waypoints.push(waypoint) }
    Group.prototype.clearTriggerQueues = function () { this.triggerQueues = { up: [], down: [], left: [], right: [] } }
    Group.prototype.flushTriggers = function () {
        for (var direction in this.triggerQueues) {
            var waypoints = this.triggerQueues[direction]
            var reverse = direction === 'up' || direction === 'left'
            waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)
            for (var i = 0, end = waypoints.length; i < end; i += 1) {
                var waypoint = waypoints[i]
                if (waypoint.options.continuous || i === waypoints.length - 1) { waypoint.trigger([direction]) }
            }
        }
        this.clearTriggerQueues()
    }
    Group.prototype.next = function (waypoint) {
        this.waypoints.sort(byTriggerPoint)
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        var isLast = index === this.waypoints.length - 1
        return isLast ? null : this.waypoints[index + 1]
    }
    Group.prototype.previous = function (waypoint) {
        this.waypoints.sort(byTriggerPoint)
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        return index ? this.waypoints[index - 1] : null
    }
    Group.prototype.queueTrigger = function (waypoint, direction) { this.triggerQueues[direction].push(waypoint) }
    Group.prototype.remove = function (waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        if (index > -1) { this.waypoints.splice(index, 1) }
    }
    Group.prototype.first = function () { return this.waypoints[0] }
    Group.prototype.last = function () { return this.waypoints[this.waypoints.length - 1] }
    Group.findOrCreate = function (options) { return groups[options.axis][options.name] || new Group(options) }
    Waypoint.Group = Group
}()); (function () {
    'use strict'
    var $ = window.jQuery
    var Waypoint = window.Waypoint
    function JQueryAdapter(element) { this.$element = $(element) }
    $.each(['innerHeight', 'innerWidth', 'off', 'offset', 'on', 'outerHeight', 'outerWidth', 'scrollLeft', 'scrollTop'], function (i, method) {
        JQueryAdapter.prototype[method] = function () {
            var args = Array.prototype.slice.call(arguments)
            return this.$element[method].apply(this.$element, args)
        }
    })
    $.each(['extend', 'inArray', 'isEmptyObject'], function (i, method) { JQueryAdapter[method] = $[method] })
    Waypoint.adapters.push({ name: 'jquery', Adapter: JQueryAdapter })
    Waypoint.Adapter = JQueryAdapter
}()); (function () {
    'use strict'
    var Waypoint = window.Waypoint
    function createExtension(framework) {
        return function () {
            var waypoints = []
            var overrides = arguments[0]
            if (framework.isFunction(arguments[0])) {
                overrides = framework.extend({}, arguments[1])
                overrides.handler = arguments[0]
            }
            this.each(function () {
                var options = framework.extend({}, overrides, { element: this })
                if (typeof options.context === 'string') { options.context = framework(this).closest(options.context)[0] }
                waypoints.push(new Waypoint(options))
            })
            return waypoints
        }
    }
    if (window.jQuery) { window.jQuery.fn.waypoint = createExtension(window.jQuery) }
    if (window.Zepto) { window.Zepto.fn.waypoint = createExtension(window.Zepto) }
}());/*! Magnific Popup - v1.1.0 - 2016-02-20
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2016 Dmitry Semenov; */!function (a) { "function" == typeof define && define.amd ? define(["jquery"], a) : a("object" == typeof exports ? require("jquery") : window.jQuery || window.Zepto) }(function (a) { var b, c, d, e, f, g, h = "Close", i = "BeforeClose", j = "AfterClose", k = "BeforeAppend", l = "MarkupParse", m = "Open", n = "Change", o = "mfp", p = "." + o, q = "mfp-ready", r = "mfp-removing", s = "mfp-prevent-close", t = function () { }, u = !!window.jQuery, v = a(window), w = function (a, c) { b.ev.on(o + a + p, c) }, x = function (b, c, d, e) { var f = document.createElement("div"); return f.className = "mfp-" + b, d && (f.innerHTML = d), e ? c && c.appendChild(f) : (f = a(f), c && f.appendTo(c)), f }, y = function (c, d) { b.ev.triggerHandler(o + c, d), b.st.callbacks && (c = c.charAt(0).toLowerCase() + c.slice(1), b.st.callbacks[c] && b.st.callbacks[c].apply(b, a.isArray(d) ? d : [d])) }, z = function (c) { return c === g && b.currTemplate.closeBtn || (b.currTemplate.closeBtn = a(b.st.closeMarkup.replace("%title%", b.st.tClose)), g = c), b.currTemplate.closeBtn }, A = function () { a.magnificPopup.instance || (b = new t, b.init(), a.magnificPopup.instance = b) }, B = function () { var a = document.createElement("p").style, b = ["ms", "O", "Moz", "Webkit"]; if (void 0 !== a.transition) return !0; for (; b.length;)if (b.pop() + "Transition" in a) return !0; return !1 }; t.prototype = { constructor: t, init: function () { var c = navigator.appVersion; b.isLowIE = b.isIE8 = document.all && !document.addEventListener, b.isAndroid = /android/gi.test(c), b.isIOS = /iphone|ipad|ipod/gi.test(c), b.supportsTransition = B(), b.probablyMobile = b.isAndroid || b.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), d = a(document), b.popupsCache = {} }, open: function (c) { var e; if (c.isObj === !1) { b.items = c.items.toArray(), b.index = 0; var g, h = c.items; for (e = 0; e < h.length; e++)if (g = h[e], g.parsed && (g = g.el[0]), g === c.el[0]) { b.index = e; break } } else b.items = a.isArray(c.items) ? c.items : [c.items], b.index = c.index || 0; if (b.isOpen) return void b.updateItemHTML(); b.types = [], f = "", c.mainEl && c.mainEl.length ? b.ev = c.mainEl.eq(0) : b.ev = d, c.key ? (b.popupsCache[c.key] || (b.popupsCache[c.key] = {}), b.currTemplate = b.popupsCache[c.key]) : b.currTemplate = {}, b.st = a.extend(!0, {}, a.magnificPopup.defaults, c), b.fixedContentPos = "auto" === b.st.fixedContentPos ? !b.probablyMobile : b.st.fixedContentPos, b.st.modal && (b.st.closeOnContentClick = !1, b.st.closeOnBgClick = !1, b.st.showCloseBtn = !1, b.st.enableEscapeKey = !1), b.bgOverlay || (b.bgOverlay = x("bg").on("click" + p, function () { b.close() }), b.wrap = x("wrap").attr("tabindex", -1).on("click" + p, function (a) { b._checkIfClose(a.target) && b.close() }), b.container = x("container", b.wrap)), b.contentContainer = x("content"), b.st.preloader && (b.preloader = x("preloader", b.container, b.st.tLoading)); var i = a.magnificPopup.modules; for (e = 0; e < i.length; e++) { var j = i[e]; j = j.charAt(0).toUpperCase() + j.slice(1), b["init" + j].call(b) } y("BeforeOpen"), b.st.showCloseBtn && (b.st.closeBtnInside ? (w(l, function (a, b, c, d) { c.close_replaceWith = z(d.type) }), f += " mfp-close-btn-in") : b.wrap.append(z())), b.st.alignTop && (f += " mfp-align-top"), b.fixedContentPos ? b.wrap.css({ overflow: b.st.overflowY, overflowX: "hidden", overflowY: b.st.overflowY }) : b.wrap.css({ top: v.scrollTop(), position: "absolute" }), (b.st.fixedBgPos === !1 || "auto" === b.st.fixedBgPos && !b.fixedContentPos) && b.bgOverlay.css({ height: d.height(), position: "absolute" }), b.st.enableEscapeKey && d.on("keyup" + p, function (a) { 27 === a.keyCode && b.close() }), v.on("resize" + p, function () { b.updateSize() }), b.st.closeOnContentClick || (f += " mfp-auto-cursor"), f && b.wrap.addClass(f); var k = b.wH = v.height(), n = {}; if (b.fixedContentPos && b._hasScrollBar(k)) { var o = b._getScrollbarSize(); o && (n.marginRight = o) } b.fixedContentPos && (b.isIE7 ? a("body, html").css("overflow", "hidden") : n.overflow = "hidden"); var r = b.st.mainClass; return b.isIE7 && (r += " mfp-ie7"), r && b._addClassToMFP(r), b.updateItemHTML(), y("BuildControls"), a("html").css(n), b.bgOverlay.add(b.wrap).prependTo(b.st.prependTo || a(document.body)), b._lastFocusedEl = document.activeElement, setTimeout(function () { b.content ? (b._addClassToMFP(q), b._setFocus()) : b.bgOverlay.addClass(q), d.on("focusin" + p, b._onFocusIn) }, 16), b.isOpen = !0, b.updateSize(k), y(m), c }, close: function () { b.isOpen && (y(i), b.isOpen = !1, b.st.removalDelay && !b.isLowIE && b.supportsTransition ? (b._addClassToMFP(r), setTimeout(function () { b._close() }, b.st.removalDelay)) : b._close()) }, _close: function () { y(h); var c = r + " " + q + " "; if (b.bgOverlay.detach(), b.wrap.detach(), b.container.empty(), b.st.mainClass && (c += b.st.mainClass + " "), b._removeClassFromMFP(c), b.fixedContentPos) { var e = { marginRight: "" }; b.isIE7 ? a("body, html").css("overflow", "") : e.overflow = "", a("html").css(e) } d.off("keyup" + p + " focusin" + p), b.ev.off(p), b.wrap.attr("class", "mfp-wrap").removeAttr("style"), b.bgOverlay.attr("class", "mfp-bg"), b.container.attr("class", "mfp-container"), !b.st.showCloseBtn || b.st.closeBtnInside && b.currTemplate[b.currItem.type] !== !0 || b.currTemplate.closeBtn && b.currTemplate.closeBtn.detach(), b.st.autoFocusLast && b._lastFocusedEl && a(b._lastFocusedEl).focus(), b.currItem = null, b.content = null, b.currTemplate = null, b.prevHeight = 0, y(j) }, updateSize: function (a) { if (b.isIOS) { var c = document.documentElement.clientWidth / window.innerWidth, d = window.innerHeight * c; b.wrap.css("height", d), b.wH = d } else b.wH = a || v.height(); b.fixedContentPos || b.wrap.css("height", b.wH), y("Resize") }, updateItemHTML: function () { var c = b.items[b.index]; b.contentContainer.detach(), b.content && b.content.detach(), c.parsed || (c = b.parseEl(b.index)); var d = c.type; if (y("BeforeChange", [b.currItem ? b.currItem.type : "", d]), b.currItem = c, !b.currTemplate[d]) { var f = b.st[d] ? b.st[d].markup : !1; y("FirstMarkupParse", f), f ? b.currTemplate[d] = a(f) : b.currTemplate[d] = !0 } e && e !== c.type && b.container.removeClass("mfp-" + e + "-holder"); var g = b["get" + d.charAt(0).toUpperCase() + d.slice(1)](c, b.currTemplate[d]); b.appendContent(g, d), c.preloaded = !0, y(n, c), e = c.type, b.container.prepend(b.contentContainer), y("AfterChange") }, appendContent: function (a, c) { b.content = a, a ? b.st.showCloseBtn && b.st.closeBtnInside && b.currTemplate[c] === !0 ? b.content.find(".mfp-close").length || b.content.append(z()) : b.content = a : b.content = "", y(k), b.container.addClass("mfp-" + c + "-holder"), b.contentContainer.append(b.content) }, parseEl: function (c) { var d, e = b.items[c]; if (e.tagName ? e = { el: a(e) } : (d = e.type, e = { data: e, src: e.src }), e.el) { for (var f = b.types, g = 0; g < f.length; g++)if (e.el.hasClass("mfp-" + f[g])) { d = f[g]; break } e.src = e.el.attr("data-mfp-src"), e.src || (e.src = e.el.attr("href")) } return e.type = d || b.st.type || "inline", e.index = c, e.parsed = !0, b.items[c] = e, y("ElementParse", e), b.items[c] }, addGroup: function (a, c) { var d = function (d) { d.mfpEl = this, b._openClick(d, a, c) }; c || (c = {}); var e = "click.magnificPopup"; c.mainEl = a, c.items ? (c.isObj = !0, a.off(e).on(e, d)) : (c.isObj = !1, c.delegate ? a.off(e).on(e, c.delegate, d) : (c.items = a, a.off(e).on(e, d))) }, _openClick: function (c, d, e) { var f = void 0 !== e.midClick ? e.midClick : a.magnificPopup.defaults.midClick; if (f || !(2 === c.which || c.ctrlKey || c.metaKey || c.altKey || c.shiftKey)) { var g = void 0 !== e.disableOn ? e.disableOn : a.magnificPopup.defaults.disableOn; if (g) if (a.isFunction(g)) { if (!g.call(b)) return !0 } else if (v.width() < g) return !0; c.type && (c.preventDefault(), b.isOpen && c.stopPropagation()), e.el = a(c.mfpEl), e.delegate && (e.items = d.find(e.delegate)), b.open(e) } }, updateStatus: function (a, d) { if (b.preloader) { c !== a && b.container.removeClass("mfp-s-" + c), d || "loading" !== a || (d = b.st.tLoading); var e = { status: a, text: d }; y("UpdateStatus", e), a = e.status, d = e.text, b.preloader.html(d), b.preloader.find("a").on("click", function (a) { a.stopImmediatePropagation() }), b.container.addClass("mfp-s-" + a), c = a } }, _checkIfClose: function (c) { if (!a(c).hasClass(s)) { var d = b.st.closeOnContentClick, e = b.st.closeOnBgClick; if (d && e) return !0; if (!b.content || a(c).hasClass("mfp-close") || b.preloader && c === b.preloader[0]) return !0; if (c === b.content[0] || a.contains(b.content[0], c)) { if (d) return !0 } else if (e && a.contains(document, c)) return !0; return !1 } }, _addClassToMFP: function (a) { b.bgOverlay.addClass(a), b.wrap.addClass(a) }, _removeClassFromMFP: function (a) { this.bgOverlay.removeClass(a), b.wrap.removeClass(a) }, _hasScrollBar: function (a) { return (b.isIE7 ? d.height() : document.body.scrollHeight) > (a || v.height()) }, _setFocus: function () { (b.st.focus ? b.content.find(b.st.focus).eq(0) : b.wrap).focus() }, _onFocusIn: function (c) { return c.target === b.wrap[0] || a.contains(b.wrap[0], c.target) ? void 0 : (b._setFocus(), !1) }, _parseMarkup: function (b, c, d) { var e; d.data && (c = a.extend(d.data, c)), y(l, [b, c, d]), a.each(c, function (c, d) { if (void 0 === d || d === !1) return !0; if (e = c.split("_"), e.length > 1) { var f = b.find(p + "-" + e[0]); if (f.length > 0) { var g = e[1]; "replaceWith" === g ? f[0] !== d[0] && f.replaceWith(d) : "img" === g ? f.is("img") ? f.attr("src", d) : f.replaceWith(a("<img>").attr("src", d).attr("class", f.attr("class"))) : f.attr(e[1], d) } } else b.find(p + "-" + c).html(d) }) }, _getScrollbarSize: function () { if (void 0 === b.scrollbarSize) { var a = document.createElement("div"); a.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(a), b.scrollbarSize = a.offsetWidth - a.clientWidth, document.body.removeChild(a) } return b.scrollbarSize } }, a.magnificPopup = { instance: null, proto: t.prototype, modules: [], open: function (b, c) { return A(), b = b ? a.extend(!0, {}, b) : {}, b.isObj = !0, b.index = c || 0, this.instance.open(b) }, close: function () { return a.magnificPopup.instance && a.magnificPopup.instance.close() }, registerModule: function (b, c) { c.options && (a.magnificPopup.defaults[b] = c.options), a.extend(this.proto, c.proto), this.modules.push(b) }, defaults: { disableOn: 0, key: null, midClick: !1, mainClass: "", preloader: !0, focus: "", closeOnContentClick: !1, closeOnBgClick: !0, closeBtnInside: !0, showCloseBtn: !0, enableEscapeKey: !0, modal: !1, alignTop: !1, removalDelay: 0, prependTo: null, fixedContentPos: "auto", fixedBgPos: "auto", overflowY: "auto", closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>', tClose: "Close (Esc)", tLoading: "Loading...", autoFocusLast: !0 } }, a.fn.magnificPopup = function (c) { A(); var d = a(this); if ("string" == typeof c) if ("open" === c) { var e, f = u ? d.data("magnificPopup") : d[0].magnificPopup, g = parseInt(arguments[1], 10) || 0; f.items ? e = f.items[g] : (e = d, f.delegate && (e = e.find(f.delegate)), e = e.eq(g)), b._openClick({ mfpEl: e }, d, f) } else b.isOpen && b[c].apply(b, Array.prototype.slice.call(arguments, 1)); else c = a.extend(!0, {}, c), u ? d.data("magnificPopup", c) : d[0].magnificPopup = c, b.addGroup(d, c); return d }; var C, D, E, F = "inline", G = function () { E && (D.after(E.addClass(C)).detach(), E = null) }; a.magnificPopup.registerModule(F, { options: { hiddenClass: "hide", markup: "", tNotFound: "Content not found" }, proto: { initInline: function () { b.types.push(F), w(h + "." + F, function () { G() }) }, getInline: function (c, d) { if (G(), c.src) { var e = b.st.inline, f = a(c.src); if (f.length) { var g = f[0].parentNode; g && g.tagName && (D || (C = e.hiddenClass, D = x(C), C = "mfp-" + C), E = f.after(D).detach().removeClass(C)), b.updateStatus("ready") } else b.updateStatus("error", e.tNotFound), f = a("<div>"); return c.inlineElement = f, f } return b.updateStatus("ready"), b._parseMarkup(d, {}, c), d } } }); var H, I = "ajax", J = function () { H && a(document.body).removeClass(H) }, K = function () { J(), b.req && b.req.abort() }; a.magnificPopup.registerModule(I, { options: { settings: null, cursor: "mfp-ajax-cur", tError: '<a href="%url%">The content</a> could not be loaded.' }, proto: { initAjax: function () { b.types.push(I), H = b.st.ajax.cursor, w(h + "." + I, K), w("BeforeChange." + I, K) }, getAjax: function (c) { H && a(document.body).addClass(H), b.updateStatus("loading"); var d = a.extend({ url: c.src, success: function (d, e, f) { var g = { data: d, xhr: f }; y("ParseAjax", g), b.appendContent(a(g.data), I), c.finished = !0, J(), b._setFocus(), setTimeout(function () { b.wrap.addClass(q) }, 16), b.updateStatus("ready"), y("AjaxContentAdded") }, error: function () { J(), c.finished = c.loadError = !0, b.updateStatus("error", b.st.ajax.tError.replace("%url%", c.src)) } }, b.st.ajax.settings); return b.req = a.ajax(d), "" } } }); var L, M = function (c) { if (c.data && void 0 !== c.data.title) return c.data.title; var d = b.st.image.titleSrc; if (d) { if (a.isFunction(d)) return d.call(b, c); if (c.el) return c.el.attr(d) || "" } return "" }; a.magnificPopup.registerModule("image", { options: { markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>', cursor: "mfp-zoom-out-cur", titleSrc: "title", verticalFit: !0, tError: '<a href="%url%">The image</a> could not be loaded.' }, proto: { initImage: function () { var c = b.st.image, d = ".image"; b.types.push("image"), w(m + d, function () { "image" === b.currItem.type && c.cursor && a(document.body).addClass(c.cursor) }), w(h + d, function () { c.cursor && a(document.body).removeClass(c.cursor), v.off("resize" + p) }), w("Resize" + d, b.resizeImage), b.isLowIE && w("AfterChange", b.resizeImage) }, resizeImage: function () { var a = b.currItem; if (a && a.img && b.st.image.verticalFit) { var c = 0; b.isLowIE && (c = parseInt(a.img.css("padding-top"), 10) + parseInt(a.img.css("padding-bottom"), 10)), a.img.css("max-height", b.wH - c) } }, _onImageHasSize: function (a) { a.img && (a.hasSize = !0, L && clearInterval(L), a.isCheckingImgSize = !1, y("ImageHasSize", a), a.imgHidden && (b.content && b.content.removeClass("mfp-loading"), a.imgHidden = !1)) }, findImageSize: function (a) { var c = 0, d = a.img[0], e = function (f) { L && clearInterval(L), L = setInterval(function () { return d.naturalWidth > 0 ? void b._onImageHasSize(a) : (c > 200 && clearInterval(L), c++, void (3 === c ? e(10) : 40 === c ? e(50) : 100 === c && e(500))) }, f) }; e(1) }, getImage: function (c, d) { var e = 0, f = function () { c && (c.img[0].complete ? (c.img.off(".mfploader"), c === b.currItem && (b._onImageHasSize(c), b.updateStatus("ready")), c.hasSize = !0, c.loaded = !0, y("ImageLoadComplete")) : (e++, 200 > e ? setTimeout(f, 100) : g())) }, g = function () { c && (c.img.off(".mfploader"), c === b.currItem && (b._onImageHasSize(c), b.updateStatus("error", h.tError.replace("%url%", c.src))), c.hasSize = !0, c.loaded = !0, c.loadError = !0) }, h = b.st.image, i = d.find(".mfp-img"); if (i.length) { var j = document.createElement("img"); j.className = "mfp-img", c.el && c.el.find("img").length && (j.alt = c.el.find("img").attr("alt")), c.img = a(j).on("load.mfploader", f).on("error.mfploader", g), j.src = c.src, i.is("img") && (c.img = c.img.clone()), j = c.img[0], j.naturalWidth > 0 ? c.hasSize = !0 : j.width || (c.hasSize = !1) } return b._parseMarkup(d, { title: M(c), img_replaceWith: c.img }, c), b.resizeImage(), c.hasSize ? (L && clearInterval(L), c.loadError ? (d.addClass("mfp-loading"), b.updateStatus("error", h.tError.replace("%url%", c.src))) : (d.removeClass("mfp-loading"), b.updateStatus("ready")), d) : (b.updateStatus("loading"), c.loading = !0, c.hasSize || (c.imgHidden = !0, d.addClass("mfp-loading"), b.findImageSize(c)), d) } } }); var N, O = function () { return void 0 === N && (N = void 0 !== document.createElement("p").style.MozTransform), N }; a.magnificPopup.registerModule("zoom", { options: { enabled: !1, easing: "ease-in-out", duration: 300, opener: function (a) { return a.is("img") ? a : a.find("img") } }, proto: { initZoom: function () { var a, c = b.st.zoom, d = ".zoom"; if (c.enabled && b.supportsTransition) { var e, f, g = c.duration, j = function (a) { var b = a.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"), d = "all " + c.duration / 1e3 + "s " + c.easing, e = { position: "fixed", zIndex: 9999, left: 0, top: 0, "-webkit-backface-visibility": "hidden" }, f = "transition"; return e["-webkit-" + f] = e["-moz-" + f] = e["-o-" + f] = e[f] = d, b.css(e), b }, k = function () { b.content.css("visibility", "visible") }; w("BuildControls" + d, function () { if (b._allowZoom()) { if (clearTimeout(e), b.content.css("visibility", "hidden"), a = b._getItemToZoom(), !a) return void k(); f = j(a), f.css(b._getOffset()), b.wrap.append(f), e = setTimeout(function () { f.css(b._getOffset(!0)), e = setTimeout(function () { k(), setTimeout(function () { f.remove(), a = f = null, y("ZoomAnimationEnded") }, 16) }, g) }, 16) } }), w(i + d, function () { if (b._allowZoom()) { if (clearTimeout(e), b.st.removalDelay = g, !a) { if (a = b._getItemToZoom(), !a) return; f = j(a) } f.css(b._getOffset(!0)), b.wrap.append(f), b.content.css("visibility", "hidden"), setTimeout(function () { f.css(b._getOffset()) }, 16) } }), w(h + d, function () { b._allowZoom() && (k(), f && f.remove(), a = null) }) } }, _allowZoom: function () { return "image" === b.currItem.type }, _getItemToZoom: function () { return b.currItem.hasSize ? b.currItem.img : !1 }, _getOffset: function (c) { var d; d = c ? b.currItem.img : b.st.zoom.opener(b.currItem.el || b.currItem); var e = d.offset(), f = parseInt(d.css("padding-top"), 10), g = parseInt(d.css("padding-bottom"), 10); e.top -= a(window).scrollTop() - f; var h = { width: d.width(), height: (u ? d.innerHeight() : d[0].offsetHeight) - g - f }; return O() ? h["-moz-transform"] = h.transform = "translate(" + e.left + "px," + e.top + "px)" : (h.left = e.left, h.top = e.top), h } } }); var P = "iframe", Q = "//about:blank", R = function (a) { if (b.currTemplate[P]) { var c = b.currTemplate[P].find("iframe"); c.length && (a || (c[0].src = Q), b.isIE8 && c.css("display", a ? "block" : "none")) } }; a.magnificPopup.registerModule(P, { options: { markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>', srcAction: "iframe_src", patterns: { youtube: { index: "youtube.com", id: "v=", src: "//www.youtube.com/embed/%id%?autoplay=1" }, vimeo: { index: "vimeo.com/", id: "/", src: "//player.vimeo.com/video/%id%?autoplay=1" }, gmaps: { index: "//maps.google.", src: "%id%&output=embed" } } }, proto: { initIframe: function () { b.types.push(P), w("BeforeChange", function (a, b, c) { b !== c && (b === P ? R() : c === P && R(!0)) }), w(h + "." + P, function () { R() }) }, getIframe: function (c, d) { var e = c.src, f = b.st.iframe; a.each(f.patterns, function () { return e.indexOf(this.index) > -1 ? (this.id && (e = "string" == typeof this.id ? e.substr(e.lastIndexOf(this.id) + this.id.length, e.length) : this.id.call(this, e)), e = this.src.replace("%id%", e), !1) : void 0 }); var g = {}; return f.srcAction && (g[f.srcAction] = e), b._parseMarkup(d, g, c), b.updateStatus("ready"), d } } }); var S = function (a) { var c = b.items.length; return a > c - 1 ? a - c : 0 > a ? c + a : a }, T = function (a, b, c) { return a.replace(/%curr%/gi, b + 1).replace(/%total%/gi, c) }; a.magnificPopup.registerModule("gallery", { options: { enabled: !1, arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>', preload: [0, 2], navigateByImgClick: !0, arrows: !0, tPrev: "Previous (Left arrow key)", tNext: "Next (Right arrow key)", tCounter: "%curr% of %total%" }, proto: { initGallery: function () { var c = b.st.gallery, e = ".mfp-gallery"; return b.direction = !0, c && c.enabled ? (f += " mfp-gallery", w(m + e, function () { c.navigateByImgClick && b.wrap.on("click" + e, ".mfp-img", function () { return b.items.length > 1 ? (b.next(), !1) : void 0 }), d.on("keydown" + e, function (a) { 37 === a.keyCode ? b.prev() : 39 === a.keyCode && b.next() }) }), w("UpdateStatus" + e, function (a, c) { c.text && (c.text = T(c.text, b.currItem.index, b.items.length)) }), w(l + e, function (a, d, e, f) { var g = b.items.length; e.counter = g > 1 ? T(c.tCounter, f.index, g) : "" }), w("BuildControls" + e, function () { if (b.items.length > 1 && c.arrows && !b.arrowLeft) { var d = c.arrowMarkup, e = b.arrowLeft = a(d.replace(/%title%/gi, c.tPrev).replace(/%dir%/gi, "left")).addClass(s), f = b.arrowRight = a(d.replace(/%title%/gi, c.tNext).replace(/%dir%/gi, "right")).addClass(s); e.click(function () { b.prev() }), f.click(function () { b.next() }), b.container.append(e.add(f)) } }), w(n + e, function () { b._preloadTimeout && clearTimeout(b._preloadTimeout), b._preloadTimeout = setTimeout(function () { b.preloadNearbyImages(), b._preloadTimeout = null }, 16) }), void w(h + e, function () { d.off(e), b.wrap.off("click" + e), b.arrowRight = b.arrowLeft = null })) : !1 }, next: function () { b.direction = !0, b.index = S(b.index + 1), b.updateItemHTML() }, prev: function () { b.direction = !1, b.index = S(b.index - 1), b.updateItemHTML() }, goTo: function (a) { b.direction = a >= b.index, b.index = a, b.updateItemHTML() }, preloadNearbyImages: function () { var a, c = b.st.gallery.preload, d = Math.min(c[0], b.items.length), e = Math.min(c[1], b.items.length); for (a = 1; a <= (b.direction ? e : d); a++)b._preloadItem(b.index + a); for (a = 1; a <= (b.direction ? d : e); a++)b._preloadItem(b.index - a) }, _preloadItem: function (c) { if (c = S(c), !b.items[c].preloaded) { var d = b.items[c]; d.parsed || (d = b.parseEl(c)), y("LazyLoad", d), "image" === d.type && (d.img = a('<img class="mfp-img" />').on("load.mfploader", function () { d.hasSize = !0 }).on("error.mfploader", function () { d.hasSize = !0, d.loadError = !0, y("LazyLoadError", d) }).attr("src", d.src)), d.preloaded = !0 } } } }); var U = "retina"; a.magnificPopup.registerModule(U, { options: { replaceSrc: function (a) { return a.src.replace(/\.\w+$/, function (a) { return "@2x" + a }) }, ratio: 1 }, proto: { initRetina: function () { if (window.devicePixelRatio > 1) { var a = b.st.retina, c = a.ratio; c = isNaN(c) ? c() : c, c > 1 && (w("ImageHasSize." + U, function (a, b) { b.img.css({ "max-width": b.img[0].naturalWidth / c, width: "100%" }) }), w("ElementParse." + U, function (b, d) { d.src = a.replaceSrc(d, c) })) } } } }), A() }); !function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.AOS = t() : e.AOS = t() }(this, function () { return function (e) { function t(o) { if (n[o]) return n[o].exports; var i = n[o] = { exports: {}, id: o, loaded: !1 }; return e[o].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports } var n = {}; return t.m = e, t.c = n, t.p = "dist/", t(0) }([function (e, t, n) { "use strict"; function o(e) { return e && e.__esModule ? e : { default: e } } var i = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]) } return e }, r = n(1), a = (o(r), n(6)), u = o(a), c = n(7), f = o(c), s = n(8), d = o(s), l = n(9), p = o(l), m = n(10), b = o(m), v = n(11), y = o(v), g = n(14), h = o(g), w = [], k = !1, x = document.all && !window.atob, j = { offset: 120, delay: 0, easing: "ease", duration: 400, disable: !1, once: !1, startEvent: "DOMContentLoaded" }, O = function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (e && (k = !0), k) return w = (0, y.default)(w, j), (0, b.default)(w, j.once), w }, S = function () { w = (0, h.default)(), O() }, _ = function () { w.forEach(function (e, t) { e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay") }) }, E = function (e) { return e === !0 || "mobile" === e && p.default.mobile() || "phone" === e && p.default.phone() || "tablet" === e && p.default.tablet() || "function" == typeof e && e() === !0 }, z = function (e) { return j = i(j, e), w = (0, h.default)(), E(j.disable) || x ? _() : (document.querySelector("body").setAttribute("data-aos-easing", j.easing), document.querySelector("body").setAttribute("data-aos-duration", j.duration), document.querySelector("body").setAttribute("data-aos-delay", j.delay), "DOMContentLoaded" === j.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 ? O(!0) : "load" === j.startEvent ? window.addEventListener(j.startEvent, function () { O(!0) }) : document.addEventListener(j.startEvent, function () { O(!0) }), window.addEventListener("resize", (0, f.default)(O, 50, !0)), window.addEventListener("orientationchange", (0, f.default)(O, 50, !0)), window.addEventListener("scroll", (0, u.default)(function () { (0, b.default)(w, j.once) }, 99)), document.addEventListener("DOMNodeRemoved", function (e) { var t = e.target; t && 1 === t.nodeType && t.hasAttribute && t.hasAttribute("data-aos") && (0, f.default)(S, 50, !0) }), (0, d.default)("[data-aos]", S), w) }; e.exports = { init: z, refresh: O, refreshHard: S } }, function (e, t) { }, , , , , function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function o(t) { var n = b, o = v; return b = v = void 0, k = t, g = e.apply(o, n) } function r(e) { return k = e, h = setTimeout(s, t), S ? o(e) : g } function a(e) { var n = e - w, o = e - k, i = t - n; return _ ? j(i, y - o) : i } function c(e) { var n = e - w, o = e - k; return void 0 === w || n >= t || n < 0 || _ && o >= y } function s() { var e = O(); return c(e) ? d(e) : void (h = setTimeout(s, a(e))) } function d(e) { return h = void 0, E && b ? o(e) : (b = v = void 0, g) } function l() { void 0 !== h && clearTimeout(h), k = 0, b = w = v = h = void 0 } function p() { return void 0 === h ? g : d(O()) } function m() { var e = O(), n = c(e); if (b = arguments, v = this, w = e, n) { if (void 0 === h) return r(w); if (_) return h = setTimeout(s, t), o(w) } return void 0 === h && (h = setTimeout(s, t)), g } var b, v, y, g, h, w, k = 0, S = !1, _ = !1, E = !0; if ("function" != typeof e) throw new TypeError(f); return t = u(t) || 0, i(n) && (S = !!n.leading, _ = "maxWait" in n, y = _ ? x(u(n.maxWait) || 0, t) : y, E = "trailing" in n ? !!n.trailing : E), m.cancel = l, m.flush = p, m } function o(e, t, o) { var r = !0, a = !0; if ("function" != typeof e) throw new TypeError(f); return i(o) && (r = "leading" in o ? !!o.leading : r, a = "trailing" in o ? !!o.trailing : a), n(e, t, { leading: r, maxWait: t, trailing: a }) } function i(e) { var t = "undefined" == typeof e ? "undefined" : c(e); return !!e && ("object" == t || "function" == t) } function r(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : c(e)) } function a(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : c(e)) || r(e) && k.call(e) == d } function u(e) { if ("number" == typeof e) return e; if (a(e)) return s; if (i(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = i(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(l, ""); var n = m.test(e); return n || b.test(e) ? v(e.slice(2), n ? 2 : 8) : p.test(e) ? s : +e } var c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, f = "Expected a function", s = NaN, d = "[object Symbol]", l = /^\s+|\s+$/g, p = /^[-+]0x[0-9a-f]+$/i, m = /^0b[01]+$/i, b = /^0o[0-7]+$/i, v = parseInt, y = "object" == ("undefined" == typeof t ? "undefined" : c(t)) && t && t.Object === Object && t, g = "object" == ("undefined" == typeof self ? "undefined" : c(self)) && self && self.Object === Object && self, h = y || g || Function("return this")(), w = Object.prototype, k = w.toString, x = Math.max, j = Math.min, O = function () { return h.Date.now() }; e.exports = o }).call(t, function () { return this }()) }, function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function i(t) { var n = b, o = v; return b = v = void 0, O = t, g = e.apply(o, n) } function r(e) { return O = e, h = setTimeout(s, t), S ? i(e) : g } function u(e) { var n = e - w, o = e - O, i = t - n; return _ ? x(i, y - o) : i } function f(e) { var n = e - w, o = e - O; return void 0 === w || n >= t || n < 0 || _ && o >= y } function s() { var e = j(); return f(e) ? d(e) : void (h = setTimeout(s, u(e))) } function d(e) { return h = void 0, E && b ? i(e) : (b = v = void 0, g) } function l() { void 0 !== h && clearTimeout(h), O = 0, b = w = v = h = void 0 } function p() { return void 0 === h ? g : d(j()) } function m() { var e = j(), n = f(e); if (b = arguments, v = this, w = e, n) { if (void 0 === h) return r(w); if (_) return h = setTimeout(s, t), i(w) } return void 0 === h && (h = setTimeout(s, t)), g } var b, v, y, g, h, w, O = 0, S = !1, _ = !1, E = !0; if ("function" != typeof e) throw new TypeError(c); return t = a(t) || 0, o(n) && (S = !!n.leading, _ = "maxWait" in n, y = _ ? k(a(n.maxWait) || 0, t) : y, E = "trailing" in n ? !!n.trailing : E), m.cancel = l, m.flush = p, m } function o(e) { var t = "undefined" == typeof e ? "undefined" : u(e); return !!e && ("object" == t || "function" == t) } function i(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : u(e)) } function r(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : u(e)) || i(e) && w.call(e) == s } function a(e) { if ("number" == typeof e) return e; if (r(e)) return f; if (o(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = o(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(d, ""); var n = p.test(e); return n || m.test(e) ? b(e.slice(2), n ? 2 : 8) : l.test(e) ? f : +e } var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, c = "Expected a function", f = NaN, s = "[object Symbol]", d = /^\s+|\s+$/g, l = /^[-+]0x[0-9a-f]+$/i, p = /^0b[01]+$/i, m = /^0o[0-7]+$/i, b = parseInt, v = "object" == ("undefined" == typeof t ? "undefined" : u(t)) && t && t.Object === Object && t, y = "object" == ("undefined" == typeof self ? "undefined" : u(self)) && self && self.Object === Object && self, g = v || y || Function("return this")(), h = Object.prototype, w = h.toString, k = Math.max, x = Math.min, j = function () { return g.Date.now() }; e.exports = n }).call(t, function () { return this }()) }, function (e, t) { "use strict"; function n(e, t) { a.push({ selector: e, fn: t }), !u && r && (u = new r(o), u.observe(i.documentElement, { childList: !0, subtree: !0, removedNodes: !0 })), o() } function o() { for (var e, t, n = 0, o = a.length; n < o; n++) { e = a[n], t = i.querySelectorAll(e.selector); for (var r, u = 0, c = t.length; u < c; u++)r = t[u], r.ready || (r.ready = !0, e.fn.call(r, r)) } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = window.document, r = window.MutationObserver || window.WebKitMutationObserver, a = [], u = void 0; t.default = n }, function (e, t) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function o() { return navigator.userAgent || navigator.vendor || window.opera || "" } Object.defineProperty(t, "__esModule", { value: !0 }); var i = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var o = t[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } return function (t, n, o) { return n && e(t.prototype, n), o && e(t, o), t } }(), r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, u = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i, c = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, f = function () { function e() { n(this, e) } return i(e, [{ key: "phone", value: function () { var e = o(); return !(!r.test(e) && !a.test(e.substr(0, 4))) } }, { key: "mobile", value: function () { var e = o(); return !(!u.test(e) && !c.test(e.substr(0, 4))) } }, { key: "tablet", value: function () { return this.mobile() && !this.phone() } }]), e }(); t.default = new f }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e, t, n) { var o = e.node.getAttribute("data-aos-once"); t > e.position ? e.node.classList.add("aos-animate") : "undefined" != typeof o && ("false" === o || !n && "true" !== o) && e.node.classList.remove("aos-animate") }, o = function (e, t) { var o = window.pageYOffset, i = window.innerHeight; e.forEach(function (e, r) { n(e, i + o, t) }) }; t.default = o }, function (e, t, n) { "use strict"; function o(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(12), r = o(i), a = function (e, t) { return e.forEach(function (e, n) { e.node.classList.add("aos-init"), e.position = (0, r.default)(e.node, t.offset) }), e }; t.default = a }, function (e, t, n) { "use strict"; function o(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(13), r = o(i), a = function (e, t) { var n = 0, o = 0, i = window.innerHeight, a = { offset: e.getAttribute("data-aos-offset"), anchor: e.getAttribute("data-aos-anchor"), anchorPlacement: e.getAttribute("data-aos-anchor-placement") }; switch (a.offset && !isNaN(a.offset) && (o = parseInt(a.offset)), a.anchor && document.querySelectorAll(a.anchor) && (e = document.querySelectorAll(a.anchor)[0]), n = (0, r.default)(e).top, a.anchorPlacement) { case "top-bottom": break; case "center-bottom": n += e.offsetHeight / 2; break; case "bottom-bottom": n += e.offsetHeight; break; case "top-center": n += i / 2; break; case "bottom-center": n += i / 2 + e.offsetHeight; break; case "center-center": n += i / 2 + e.offsetHeight / 2; break; case "top-top": n += i; break; case "bottom-top": n += e.offsetHeight + i; break; case "center-top": n += e.offsetHeight / 2 + i }return a.anchorPlacement || a.offset || isNaN(t) || (o = t), n + o }; t.default = a }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);)t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent; return { top: n, left: t } }; t.default = n }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { e = e || document.querySelectorAll("[data-aos]"); var t = []; return [].forEach.call(e, function (e, n) { t.push({ node: e }) }), t }; t.default = n }]) });/*!
* Chart.js
* http://chartjs.org/
* Version: 2.7.2
*
* Copyright 2018 Chart.js Contributors
* Released under the MIT license
* https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
*/!function (t) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Chart = t() } }(function () { return function t(e, i, n) { function a(r, s) { if (!i[r]) { if (!e[r]) { var l = "function" == typeof require && require; if (!s && l) return l(r, !0); if (o) return o(r, !0); var u = new Error("Cannot find module '" + r + "'"); throw u.code = "MODULE_NOT_FOUND", u } var d = i[r] = { exports: {} }; e[r][0].call(d.exports, function (t) { var i = e[r][1][t]; return a(i || t) }, d, d.exports, t, e, i, n) } return i[r].exports } for (var o = "function" == typeof require && require, r = 0; r < n.length; r++)a(n[r]); return a }({ 1: [function (t, e, i) { }, {}], 2: [function (t, e, i) { var n = t(6); function a(t) { if (t) { var e = [0, 0, 0], i = 1, a = t.match(/^#([a-fA-F0-9]{3})$/i); if (a) { a = a[1]; for (var o = 0; o < e.length; o++)e[o] = parseInt(a[o] + a[o], 16) } else if (a = t.match(/^#([a-fA-F0-9]{6})$/i)) { a = a[1]; for (o = 0; o < e.length; o++)e[o] = parseInt(a.slice(2 * o, 2 * o + 2), 16) } else if (a = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = parseInt(a[o + 1]); i = parseFloat(a[4]) } else if (a = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = Math.round(2.55 * parseFloat(a[o + 1])); i = parseFloat(a[4]) } else if (a = t.match(/(\w+)/)) { if ("transparent" == a[1]) return [0, 0, 0, 0]; if (!(e = n[a[1]])) return } for (o = 0; o < e.length; o++)e[o] = d(e[o], 0, 255); return i = i || 0 == i ? d(i, 0, 1) : 1, e[3] = i, e } } function o(t) { if (t) { var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { var i = parseFloat(e[4]); return [d(parseInt(e[1]), 0, 360), d(parseFloat(e[2]), 0, 100), d(parseFloat(e[3]), 0, 100), d(isNaN(i) ? 1 : i, 0, 1)] } } } function r(t) { if (t) { var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { var i = parseFloat(e[4]); return [d(parseInt(e[1]), 0, 360), d(parseFloat(e[2]), 0, 100), d(parseFloat(e[3]), 0, 100), d(isNaN(i) ? 1 : i, 0, 1)] } } } function s(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")" } function l(t, e) { return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")" } function u(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")" } function d(t, e, i) { return Math.min(Math.max(e, t), i) } function c(t) { var e = t.toString(16).toUpperCase(); return e.length < 2 ? "0" + e : e } e.exports = { getRgba: a, getHsla: o, getRgb: function (t) { var e = a(t); return e && e.slice(0, 3) }, getHsl: function (t) { var e = o(t); return e && e.slice(0, 3) }, getHwb: r, getAlpha: function (t) { var e = a(t); { if (e) return e[3]; if (e = o(t)) return e[3]; if (e = r(t)) return e[3] } }, hexString: function (t) { return "#" + c(t[0]) + c(t[1]) + c(t[2]) }, rgbString: function (t, e) { if (e < 1 || t[3] && t[3] < 1) return s(t, e); return "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")" }, rgbaString: s, percentString: function (t, e) { if (e < 1 || t[3] && t[3] < 1) return l(t, e); var i = Math.round(t[0] / 255 * 100), n = Math.round(t[1] / 255 * 100), a = Math.round(t[2] / 255 * 100); return "rgb(" + i + "%, " + n + "%, " + a + "%)" }, percentaString: l, hslString: function (t, e) { if (e < 1 || t[3] && t[3] < 1) return u(t, e); return "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)" }, hslaString: u, hwbString: function (t, e) { void 0 === e && (e = void 0 !== t[3] ? t[3] : 1); return "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")" }, keyword: function (t) { return h[t.slice(0, 3)] } }; var h = {}; for (var f in n) h[n[f]] = f }, { 6: 6 }], 3: [function (t, e, i) { var n = t(5), a = t(2), o = function (t) { return t instanceof o ? t : this instanceof o ? (this.valid = !1, this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 }, void ("string" == typeof t ? (e = a.getRgba(t)) ? this.setValues("rgb", e) : (e = a.getHsla(t)) ? this.setValues("hsl", e) : (e = a.getHwb(t)) && this.setValues("hwb", e) : "object" == typeof t && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new o(t); var e }; o.prototype = { isValid: function () { return this.valid }, rgb: function () { return this.setSpace("rgb", arguments) }, hsl: function () { return this.setSpace("hsl", arguments) }, hsv: function () { return this.setSpace("hsv", arguments) }, hwb: function () { return this.setSpace("hwb", arguments) }, cmyk: function () { return this.setSpace("cmyk", arguments) }, rgbArray: function () { return this.values.rgb }, hslArray: function () { return this.values.hsl }, hsvArray: function () { return this.values.hsv }, hwbArray: function () { var t = this.values; return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb }, cmykArray: function () { return this.values.cmyk }, rgbaArray: function () { var t = this.values; return t.rgb.concat([t.alpha]) }, hslaArray: function () { var t = this.values; return t.hsl.concat([t.alpha]) }, alpha: function (t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this) }, red: function (t) { return this.setChannel("rgb", 0, t) }, green: function (t) { return this.setChannel("rgb", 1, t) }, blue: function (t) { return this.setChannel("rgb", 2, t) }, hue: function (t) { return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t) }, saturation: function (t) { return this.setChannel("hsl", 1, t) }, lightness: function (t) { return this.setChannel("hsl", 2, t) }, saturationv: function (t) { return this.setChannel("hsv", 1, t) }, whiteness: function (t) { return this.setChannel("hwb", 1, t) }, blackness: function (t) { return this.setChannel("hwb", 2, t) }, value: function (t) { return this.setChannel("hsv", 2, t) }, cyan: function (t) { return this.setChannel("cmyk", 0, t) }, magenta: function (t) { return this.setChannel("cmyk", 1, t) }, yellow: function (t) { return this.setChannel("cmyk", 2, t) }, black: function (t) { return this.setChannel("cmyk", 3, t) }, hexString: function () { return a.hexString(this.values.rgb) }, rgbString: function () { return a.rgbString(this.values.rgb, this.values.alpha) }, rgbaString: function () { return a.rgbaString(this.values.rgb, this.values.alpha) }, percentString: function () { return a.percentString(this.values.rgb, this.values.alpha) }, hslString: function () { return a.hslString(this.values.hsl, this.values.alpha) }, hslaString: function () { return a.hslaString(this.values.hsl, this.values.alpha) }, hwbString: function () { return a.hwbString(this.values.hwb, this.values.alpha) }, keyword: function () { return a.keyword(this.values.rgb, this.values.alpha) }, rgbNumber: function () { var t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2] }, luminosity: function () { for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) { var n = t[i] / 255; e[i] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4) } return .2126 * e[0] + .7152 * e[1] + .0722 * e[2] }, contrast: function (t) { var e = this.luminosity(), i = t.luminosity(); return e > i ? (e + .05) / (i + .05) : (i + .05) / (e + .05) }, level: function (t) { var e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : "" }, dark: function () { var t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128 }, light: function () { return !this.dark() }, negate: function () { for (var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this }, lighten: function (t) { var e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this }, darken: function (t) { var e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this }, saturate: function (t) { var e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this }, desaturate: function (t) { var e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this }, whiten: function (t) { var e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this }, blacken: function (t) { var e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this }, greyscale: function () { var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2]; return this.setValues("rgb", [e, e, e]), this }, clearer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e - e * t), this }, opaquer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e + e * t), this }, rotate: function (t) { var e = this.values.hsl, i = (e[0] + t) % 360; return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this }, mix: function (t, e) { var i = this, n = t, a = void 0 === e ? .5 : e, o = 2 * a - 1, r = i.alpha() - n.alpha(), s = ((o * r == -1 ? o : (o + r) / (1 + o * r)) + 1) / 2, l = 1 - s; return this.rgb(s * i.red() + l * n.red(), s * i.green() + l * n.green(), s * i.blue() + l * n.blue()).alpha(i.alpha() * a + n.alpha() * (1 - a)) }, toJSON: function () { return this.rgb() }, clone: function () { var t, e, i = new o, n = this.values, a = i.values; for (var r in n) n.hasOwnProperty(r) && (t = n[r], "[object Array]" === (e = {}.toString.call(t)) ? a[r] = t.slice(0) : "[object Number]" === e ? a[r] = t : console.error("unexpected color value:", t)); return i } }, o.prototype.spaces = { rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"] }, o.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] }, o.prototype.getValues = function (t) { for (var e = this.values, i = {}, n = 0; n < t.length; n++)i[t.charAt(n)] = e[t][n]; return 1 !== e.alpha && (i.a = e.alpha), i }, o.prototype.setValues = function (t, e) { var i, a, o = this.values, r = this.spaces, s = this.maxes, l = 1; if (this.valid = !0, "alpha" === t) l = e; else if (e.length) o[t] = e.slice(0, t.length), l = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (i = 0; i < t.length; i++)o[t][i] = e[t.charAt(i)]; l = e.a } else if (void 0 !== e[r[t][0]]) { var u = r[t]; for (i = 0; i < t.length; i++)o[t][i] = e[u[i]]; l = e.alpha } if (o.alpha = Math.max(0, Math.min(1, void 0 === l ? o.alpha : l)), "alpha" === t) return !1; for (i = 0; i < t.length; i++)a = Math.max(0, Math.min(s[t][i], o[t][i])), o[t][i] = Math.round(a); for (var d in r) d !== t && (o[d] = n[t][d](o[t])); return !0 }, o.prototype.setSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this) }, o.prototype.setChannel = function (t, e, i) { var n = this.values[t]; return void 0 === i ? n[e] : i === n[e] ? this : (n[e] = i, this.setValues(t, n), this) }, "undefined" != typeof window && (window.Color = o), e.exports = o }, { 2: 2, 5: 5 }], 4: [function (t, e, i) { function n(t) { var e, i, n = t[0] / 255, a = t[1] / 255, o = t[2] / 255, r = Math.min(n, a, o), s = Math.max(n, a, o), l = s - r; return s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (r + s) / 2, [e, 100 * (s == r ? 0 : i <= .5 ? l / (s + r) : l / (2 - s - r)), 100 * i] } function a(t) { var e, i, n = t[0], a = t[1], o = t[2], r = Math.min(n, a, o), s = Math.max(n, a, o), l = s - r; return i = 0 == s ? 0 : l / s * 1e3 / 10, s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, s / 255 * 1e3 / 10] } function o(t) { var e = t[0], i = t[1], a = t[2]; return [n(t)[0], 100 * (1 / 255 * Math.min(e, Math.min(i, a))), 100 * (a = 1 - 1 / 255 * Math.max(e, Math.max(i, a)))] } function s(t) { var e, i = t[0] / 255, n = t[1] / 255, a = t[2] / 255; return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - a))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * e] } function l(t) { return C[JSON.stringify(t)] } function u(t) { var e = t[0] / 255, i = t[1] / 255, n = t[2] / 255; return [100 * (.4124 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92)), 100 * (.2126 * e + .7152 * i + .0722 * n), 100 * (.0193 * e + .1192 * i + .9505 * n)] } function d(t) { var e = u(t), i = e[0], n = e[1], a = e[2]; return n /= 100, a /= 108.883, i = (i /= 95.047) > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))] } function c(t) { var e, i, n, a, o, r = t[0] / 360, s = t[1] / 100, l = t[2] / 100; if (0 == s) return [o = 255 * l, o, o]; e = 2 * l - (i = l < .5 ? l * (1 + s) : l + s - l * s), a = [0, 0, 0]; for (var u = 0; u < 3; u++)(n = r + 1 / 3 * -(u - 1)) < 0 && n++, n > 1 && n--, o = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, a[u] = 255 * o; return a } function h(t) { var e = t[0] / 60, i = t[1] / 100, n = t[2] / 100, a = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * n * (1 - i), s = 255 * n * (1 - i * o), l = 255 * n * (1 - i * (1 - o)); n *= 255; switch (a) { case 0: return [n, l, r]; case 1: return [s, n, r]; case 2: return [r, n, l]; case 3: return [r, s, n]; case 4: return [l, r, n]; case 5: return [n, r, s] } } function f(t) { var e, i, n, a, o = t[0] / 360, s = t[1] / 100, l = t[2] / 100, u = s + l; switch (u > 1 && (s /= u, l /= u), n = 6 * o - (e = Math.floor(6 * o)), 0 != (1 & e) && (n = 1 - n), a = s + n * ((i = 1 - l) - s), e) { default: case 6: case 0: r = i, g = a, b = s; break; case 1: r = a, g = i, b = s; break; case 2: r = s, g = i, b = a; break; case 3: r = s, g = a, b = i; break; case 4: r = a, g = s, b = i; break; case 5: r = i, g = s, b = a }return [255 * r, 255 * g, 255 * b] } function p(t) { var e = t[0] / 100, i = t[1] / 100, n = t[2] / 100, a = t[3] / 100; return [255 * (1 - Math.min(1, e * (1 - a) + a)), 255 * (1 - Math.min(1, i * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a))] } function m(t) { var e, i, n, a = t[0] / 100, o = t[1] / 100, r = t[2] / 100; return i = -.9689 * a + 1.8758 * o + .0415 * r, n = .0557 * a + -.204 * o + 1.057 * r, e = (e = 3.2406 * a + -1.5372 * o + -.4986 * r) > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i *= 12.92, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))] } function v(t) { var e = t[0], i = t[1], n = t[2]; return i /= 100, n /= 108.883, e = (e /= 95.047) > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))] } function x(t) { var e, i, n, a, o = t[0], r = t[1], s = t[2]; return o <= 8 ? a = (i = 100 * o / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * Math.pow((o + 16) / 116, 3), a = Math.pow(i / 100, 1 / 3)), [e = e / 95.047 <= .008856 ? e = 95.047 * (r / 500 + a - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + a, 3), i, n = n / 108.883 <= .008859 ? n = 108.883 * (a - s / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(a - s / 200, 3)] } function y(t) { var e, i = t[0], n = t[1], a = t[2]; return (e = 360 * Math.atan2(a, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + a * a), e] } function k(t) { return m(x(t)) } function M(t) { var e, i = t[0], n = t[1]; return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)] } function w(t) { return S[t] } e.exports = { rgb2hsl: n, rgb2hsv: a, rgb2hwb: o, rgb2cmyk: s, rgb2keyword: l, rgb2xyz: u, rgb2lab: d, rgb2lch: function (t) { return y(d(t)) }, hsl2rgb: c, hsl2hsv: function (t) { var e = t[0], i = t[1] / 100, n = t[2] / 100; if (0 === n) return [0, 0, 0]; return [e, 100 * (2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i)), 100 * ((n + i) / 2)] }, hsl2hwb: function (t) { return o(c(t)) }, hsl2cmyk: function (t) { return s(c(t)) }, hsl2keyword: function (t) { return l(c(t)) }, hsv2rgb: h, hsv2hsl: function (t) { var e, i, n = t[0], a = t[1] / 100, o = t[2] / 100; return e = a * o, [n, 100 * (e = (e /= (i = (2 - a) * o) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)] }, hsv2hwb: function (t) { return o(h(t)) }, hsv2cmyk: function (t) { return s(h(t)) }, hsv2keyword: function (t) { return l(h(t)) }, hwb2rgb: f, hwb2hsl: function (t) { return n(f(t)) }, hwb2hsv: function (t) { return a(f(t)) }, hwb2cmyk: function (t) { return s(f(t)) }, hwb2keyword: function (t) { return l(f(t)) }, cmyk2rgb: p, cmyk2hsl: function (t) { return n(p(t)) }, cmyk2hsv: function (t) { return a(p(t)) }, cmyk2hwb: function (t) { return o(p(t)) }, cmyk2keyword: function (t) { return l(p(t)) }, keyword2rgb: w, keyword2hsl: function (t) { return n(w(t)) }, keyword2hsv: function (t) { return a(w(t)) }, keyword2hwb: function (t) { return o(w(t)) }, keyword2cmyk: function (t) { return s(w(t)) }, keyword2lab: function (t) { return d(w(t)) }, keyword2xyz: function (t) { return u(w(t)) }, xyz2rgb: m, xyz2lab: v, xyz2lch: function (t) { return y(v(t)) }, lab2xyz: x, lab2rgb: k, lab2lch: y, lch2lab: M, lch2xyz: function (t) { return x(M(t)) }, lch2rgb: function (t) { return k(M(t)) } }; var S = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, C = {}; for (var _ in S) C[JSON.stringify(S[_])] = _ }, {}], 5: [function (t, e, i) { var n = t(4), a = function () { return new u }; for (var o in n) { a[o + "Raw"] = function (t) { return function (e) { return "number" == typeof e && (e = Array.prototype.slice.call(arguments)), n[t](e) } }(o); var r = /(\w+)2(\w+)/.exec(o), s = r[1], l = r[2]; (a[s] = a[s] || {})[l] = a[o] = function (t) { return function (e) { "number" == typeof e && (e = Array.prototype.slice.call(arguments)); var i = n[t](e); if ("string" == typeof i || void 0 === i) return i; for (var a = 0; a < i.length; a++)i[a] = Math.round(i[a]); return i } }(o) } var u = function () { this.convs = {} }; u.prototype.routeSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i)) }, u.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this }, u.prototype.getValues = function (t) { var e = this.convs[t]; if (!e) { var i = this.space, n = this.convs[i]; e = a[i][t](n), this.convs[t] = e } return e }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (t) { u.prototype[t] = function (e) { return this.routeSpace(t, arguments) } }), e.exports = a }, { 4: 4 }], 6: [function (t, e, i) { "use strict"; e.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] } }, {}], 7: [function (t, e, i) { var n = t(29)(); n.helpers = t(45), t(27)(n), n.defaults = t(25), n.Element = t(26), n.elements = t(40), n.Interaction = t(28), n.layouts = t(30), n.platform = t(48), n.plugins = t(31), n.Ticks = t(34), t(22)(n), t(23)(n), t(24)(n), t(33)(n), t(32)(n), t(35)(n), t(55)(n), t(53)(n), t(54)(n), t(56)(n), t(57)(n), t(58)(n), t(15)(n), t(16)(n), t(17)(n), t(18)(n), t(19)(n), t(20)(n), t(21)(n), t(8)(n), t(9)(n), t(10)(n), t(11)(n), t(12)(n), t(13)(n), t(14)(n); var a = t(49); for (var o in a) a.hasOwnProperty(o) && n.plugins.register(a[o]); n.platform.initialize(), e.exports = n, "undefined" != typeof window && (window.Chart = n), n.Legend = a.legend._element, n.Title = a.title._element, n.pluginService = n.plugins, n.PluginBase = n.Element.extend({}), n.canvasHelpers = n.helpers.canvas, n.layoutService = n.layouts }, { 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 40: 40, 45: 45, 48: 48, 49: 49, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 8: 8, 9: 9 }], 8: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Bar = function (e, i) { return i.type = "bar", new t(e, i) } } }, {}], 9: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Bubble = function (e, i) { return i.type = "bubble", new t(e, i) } } }, {}], 10: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Doughnut = function (e, i) { return i.type = "doughnut", new t(e, i) } } }, {}], 11: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Line = function (e, i) { return i.type = "line", new t(e, i) } } }, {}], 12: [function (t, e, i) { "use strict"; e.exports = function (t) { t.PolarArea = function (e, i) { return i.type = "polarArea", new t(e, i) } } }, {}], 13: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Radar = function (e, i) { return i.type = "radar", new t(e, i) } } }, {}], 14: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Scatter = function (e, i) { return i.type = "scatter", new t(e, i) } } }, {}], 15: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("bar", { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", categoryPercentage: .8, barPercentage: .9, offset: !0, gridLines: { offsetGridLines: !0 } }], yAxes: [{ type: "linear" }] } }), n._set("horizontalBar", { hover: { mode: "index", axis: "y" }, scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ position: "left", type: "category", categoryPercentage: .8, barPercentage: .9, offset: !0, gridLines: { offsetGridLines: !0 } }] }, elements: { rectangle: { borderSkipped: "left" } }, tooltips: { callbacks: { title: function (t, e) { var i = ""; return t.length > 0 && (t[0].yLabel ? i = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (i = e.labels[t[0].index])), i }, label: function (t, e) { return (e.datasets[t.datasetIndex].label || "") + ": " + t.xLabel } }, mode: "index", axis: "y" } }), e.exports = function (t) { t.controllers.bar = t.DatasetController.extend({ dataElementType: a.Rectangle, initialize: function () { var e; t.DatasetController.prototype.initialize.apply(this, arguments), (e = this.getMeta()).stack = this.getDataset().stack, e.bar = !0 }, update: function (t) { var e, i, n = this.getMeta().data; for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e)this.updateElement(n[e], e, t) }, updateElement: function (t, e, i) { var n = this, a = n.chart, r = n.getMeta(), s = n.getDataset(), l = t.custom || {}, u = a.options.elements.rectangle; t._xScale = n.getScaleForId(r.xAxisID), t._yScale = n.getScaleForId(r.yAxisID), t._datasetIndex = n.index, t._index = e, t._model = { datasetLabel: s.label, label: a.data.labels[e], borderSkipped: l.borderSkipped ? l.borderSkipped : u.borderSkipped, backgroundColor: l.backgroundColor ? l.backgroundColor : o.valueAtIndexOrDefault(s.backgroundColor, e, u.backgroundColor), borderColor: l.borderColor ? l.borderColor : o.valueAtIndexOrDefault(s.borderColor, e, u.borderColor), borderWidth: l.borderWidth ? l.borderWidth : o.valueAtIndexOrDefault(s.borderWidth, e, u.borderWidth) }, n.updateElementGeometry(t, e, i), t.pivot() }, updateElementGeometry: function (t, e, i) { var n = this, a = t._model, o = n.getValueScale(), r = o.getBasePixel(), s = o.isHorizontal(), l = n._ruler || n.getRuler(), u = n.calculateBarValuePixels(n.index, e), d = n.calculateBarIndexPixels(n.index, e, l); a.horizontal = s, a.base = i ? r : u.base, a.x = s ? i ? r : u.head : d.center, a.y = s ? d.center : i ? r : u.head, a.height = s ? d.size : void 0, a.width = s ? void 0 : d.size }, getValueScaleId: function () { return this.getMeta().yAxisID }, getIndexScaleId: function () { return this.getMeta().xAxisID }, getValueScale: function () { return this.getScaleForId(this.getValueScaleId()) }, getIndexScale: function () { return this.getScaleForId(this.getIndexScaleId()) }, _getStacks: function (t) { var e, i, n = this.chart, a = this.getIndexScale().options.stacked, o = void 0 === t ? n.data.datasets.length : t + 1, r = []; for (e = 0; e < o; ++e)(i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === a || !0 === a && -1 === r.indexOf(i.stack) || void 0 === a && (void 0 === i.stack || -1 === r.indexOf(i.stack))) && r.push(i.stack); return r }, getStackCount: function () { return this._getStacks().length }, getStackIndex: function (t, e) { var i = this._getStacks(t), n = void 0 !== e ? i.indexOf(e) : -1; return -1 === n ? i.length - 1 : n }, getRuler: function () { var t, e, i = this.getIndexScale(), n = this.getStackCount(), a = this.index, r = i.isHorizontal(), s = r ? i.left : i.top, l = s + (r ? i.width : i.height), u = []; for (t = 0, e = this.getMeta().data.length; t < e; ++t)u.push(i.getPixelForValue(null, t, a)); return { min: o.isNullOrUndef(i.options.barThickness) ? function (t, e) { var i, n, a, o, r = t.isHorizontal() ? t.width : t.height, s = t.getTicks(); for (a = 1, o = e.length; a < o; ++a)r = Math.min(r, e[a] - e[a - 1]); for (a = 0, o = s.length; a < o; ++a)n = t.getPixelForTick(a), r = a > 0 ? Math.min(r, n - i) : r, i = n; return r }(i, u) : -1, pixels: u, start: s, end: l, stackCount: n, scale: i } }, calculateBarValuePixels: function (t, e) { var i, n, a, o, r, s, l = this.chart, u = this.getMeta(), d = this.getValueScale(), c = l.data.datasets, h = d.getRightValue(c[t].data[e]), f = d.options.stacked, g = u.stack, p = 0; if (f || void 0 === f && void 0 !== g) for (i = 0; i < t; ++i)(n = l.getDatasetMeta(i)).bar && n.stack === g && n.controller.getValueScaleId() === d.id && l.isDatasetVisible(i) && (a = d.getRightValue(c[i].data[e]), (h < 0 && a < 0 || h >= 0 && a > 0) && (p += a)); return o = d.getPixelForValue(p), { size: s = ((r = d.getPixelForValue(p + h)) - o) / 2, base: o, head: r, center: r + s / 2 } }, calculateBarIndexPixels: function (t, e, i) { var n, a, r, s, l, u, d, c, h, f, g, p, m, v, b, x, y, k = i.scale.options, M = "flex" === k.barThickness ? (h = e, g = k, m = (f = i).pixels, v = m[h], b = h > 0 ? m[h - 1] : null, x = h < m.length - 1 ? m[h + 1] : null, y = g.categoryPercentage, null === b && (b = v - (null === x ? f.end - v : x - v)), null === x && (x = v + v - b), p = v - (v - b) / 2 * y, { chunk: (x - b) / 2 * y / f.stackCount, ratio: g.barPercentage, start: p }) : (n = e, a = i, u = (r = k).barThickness, d = a.stackCount, c = a.pixels[n], o.isNullOrUndef(u) ? (s = a.min * r.categoryPercentage, l = r.barPercentage) : (s = u * d, l = 1), { chunk: s / d, ratio: l, start: c - s / 2 }), w = this.getStackIndex(t, this.getMeta().stack), S = M.start + M.chunk * w + M.chunk / 2, C = Math.min(o.valueOrDefault(k.maxBarThickness, 1 / 0), M.chunk * M.ratio); return { base: S - C / 2, head: S + C / 2, center: S, size: C } }, draw: function () { var t = this.chart, e = this.getValueScale(), i = this.getMeta().data, n = this.getDataset(), a = i.length, r = 0; for (o.canvas.clipArea(t.ctx, t.chartArea); r < a; ++r)isNaN(e.getRightValue(n.data[r])) || i[r].draw(); o.canvas.unclipArea(t.ctx) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; a.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : o.valueAtIndexOrDefault(e.hoverBackgroundColor, i, o.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor ? n.hoverBorderColor : o.valueAtIndexOrDefault(e.hoverBorderColor, i, o.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : o.valueAtIndexOrDefault(e.hoverBorderWidth, i, a.borderWidth) }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model, r = this.chart.options.elements.rectangle; a.backgroundColor = n.backgroundColor ? n.backgroundColor : o.valueAtIndexOrDefault(e.backgroundColor, i, r.backgroundColor), a.borderColor = n.borderColor ? n.borderColor : o.valueAtIndexOrDefault(e.borderColor, i, r.borderColor), a.borderWidth = n.borderWidth ? n.borderWidth : o.valueAtIndexOrDefault(e.borderWidth, i, r.borderWidth) } }), t.controllers.horizontalBar = t.controllers.bar.extend({ getValueScaleId: function () { return this.getMeta().xAxisID }, getIndexScaleId: function () { return this.getMeta().yAxisID } }) } }, { 25: 25, 40: 40, 45: 45 }], 16: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("bubble", { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || "", n = e.datasets[t.datasetIndex].data[t.index]; return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")" } } } }), e.exports = function (t) { t.controllers.bubble = t.DatasetController.extend({ dataElementType: a.Point, update: function (t) { var e = this, i = e.getMeta().data; o.each(i, function (i, n) { e.updateElement(i, n, t) }) }, updateElement: function (t, e, i) { var n = this, a = n.getMeta(), o = t.custom || {}, r = n.getScaleForId(a.xAxisID), s = n.getScaleForId(a.yAxisID), l = n._resolveElementOptions(t, e), u = n.getDataset().data[e], d = n.index, c = i ? r.getPixelForDecimal(.5) : r.getPixelForValue("object" == typeof u ? u : NaN, e, d), h = i ? s.getBasePixel() : s.getPixelForValue(u, e, d); t._xScale = r, t._yScale = s, t._options = l, t._datasetIndex = d, t._index = e, t._model = { backgroundColor: l.backgroundColor, borderColor: l.borderColor, borderWidth: l.borderWidth, hitRadius: l.hitRadius, pointStyle: l.pointStyle, radius: i ? 0 : l.radius, skip: o.skip || isNaN(c) || isNaN(h), x: c, y: h }, t.pivot() }, setHoverStyle: function (t) { var e = t._model, i = t._options; e.backgroundColor = o.valueOrDefault(i.hoverBackgroundColor, o.getHoverColor(i.backgroundColor)), e.borderColor = o.valueOrDefault(i.hoverBorderColor, o.getHoverColor(i.borderColor)), e.borderWidth = o.valueOrDefault(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius }, removeHoverStyle: function (t) { var e = t._model, i = t._options; e.backgroundColor = i.backgroundColor, e.borderColor = i.borderColor, e.borderWidth = i.borderWidth, e.radius = i.radius }, _resolveElementOptions: function (t, e) { var i, n, a, r = this.chart, s = r.data.datasets[this.index], l = t.custom || {}, u = r.options.elements.point, d = o.options.resolve, c = s.data[e], h = {}, f = { chart: r, dataIndex: e, dataset: s, datasetIndex: this.index }, g = ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle"]; for (i = 0, n = g.length; i < n; ++i)h[a = g[i]] = d([l[a], s[a], u[a]], f, e); return h.radius = d([l.radius, c ? c.r : void 0, s.radius, u.radius], f, e), h } }) } }, { 25: 25, 40: 40, 45: 45 }], 17: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("doughnut", { animation: { animateRotate: !0, animateScale: !1 }, hover: { mode: "single" }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, a = i.labels; if (n.length) for (var o = 0; o < n[0].data.length; ++o)e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) { var a = t.getDatasetMeta(0), r = e.datasets[0], s = a.data[n], l = s && s.custom || {}, u = o.valueAtIndexOrDefault, d = t.options.elements.arc; return { text: i, fillStyle: l.backgroundColor ? l.backgroundColor : u(r.backgroundColor, n, d.backgroundColor), strokeStyle: l.borderColor ? l.borderColor : u(r.borderColor, n, d.borderColor), lineWidth: l.borderWidth ? l.borderWidth : u(r.borderWidth, n, d.borderWidth), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n } }) : [] } }, onClick: function (t, e) { var i, n, a, o = e.index, r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)(a = r.getDatasetMeta(i)).data[o] && (a.data[o].hidden = !a.data[o].hidden); r.update() } }, cutoutPercentage: 50, rotation: -.5 * Math.PI, circumference: 2 * Math.PI, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { var i = e.labels[t.index], n = ": " + e.datasets[t.datasetIndex].data[t.index]; return o.isArray(i) ? (i = i.slice())[0] += n : i += n, i } } } }), n._set("pie", o.clone(n.doughnut)), n._set("pie", { cutoutPercentage: 0 }), e.exports = function (t) { t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({ dataElementType: a.Arc, linkScales: o.noop, getRingIndex: function (t) { for (var e = 0, i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && ++e; return e }, update: function (t) { var e = this, i = e.chart, n = i.chartArea, a = i.options, r = a.elements.arc, s = n.right - n.left - r.borderWidth, l = n.bottom - n.top - r.borderWidth, u = Math.min(s, l), d = { x: 0, y: 0 }, c = e.getMeta(), h = a.cutoutPercentage, f = a.circumference; if (f < 2 * Math.PI) { var g = a.rotation % (2 * Math.PI), p = (g += 2 * Math.PI * (g >= Math.PI ? -1 : g < -Math.PI ? 1 : 0)) + f, m = Math.cos(g), v = Math.sin(g), b = Math.cos(p), x = Math.sin(p), y = g <= 0 && p >= 0 || g <= 2 * Math.PI && 2 * Math.PI <= p, k = g <= .5 * Math.PI && .5 * Math.PI <= p || g <= 2.5 * Math.PI && 2.5 * Math.PI <= p, M = g <= -Math.PI && -Math.PI <= p || g <= Math.PI && Math.PI <= p, w = g <= .5 * -Math.PI && .5 * -Math.PI <= p || g <= 1.5 * Math.PI && 1.5 * Math.PI <= p, S = h / 100, C = M ? -1 : Math.min(m * (m < 0 ? 1 : S), b * (b < 0 ? 1 : S)), _ = w ? -1 : Math.min(v * (v < 0 ? 1 : S), x * (x < 0 ? 1 : S)), D = y ? 1 : Math.max(m * (m > 0 ? 1 : S), b * (b > 0 ? 1 : S)), I = k ? 1 : Math.max(v * (v > 0 ? 1 : S), x * (x > 0 ? 1 : S)), P = .5 * (D - C), A = .5 * (I - _); u = Math.min(s / P, l / A), d = { x: -.5 * (D + C), y: -.5 * (I + _) } } i.borderWidth = e.getMaxBorderWidth(c.data), i.outerRadius = Math.max((u - i.borderWidth) / 2, 0), i.innerRadius = Math.max(h ? i.outerRadius / 100 * h : 0, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), i.offsetX = d.x * i.outerRadius, i.offsetY = d.y * i.outerRadius, c.total = e.calculateTotal(), e.outerRadius = i.outerRadius - i.radiusLength * e.getRingIndex(e.index), e.innerRadius = Math.max(e.outerRadius - i.radiusLength, 0), o.each(c.data, function (i, n) { e.updateElement(i, n, t) }) }, updateElement: function (t, e, i) { var n = this, a = n.chart, r = a.chartArea, s = a.options, l = s.animation, u = (r.left + r.right) / 2, d = (r.top + r.bottom) / 2, c = s.rotation, h = s.rotation, f = n.getDataset(), g = i && l.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(f.data[e]) * (s.circumference / (2 * Math.PI)), p = i && l.animateScale ? 0 : n.innerRadius, m = i && l.animateScale ? 0 : n.outerRadius, v = o.valueAtIndexOrDefault; o.extend(t, { _datasetIndex: n.index, _index: e, _model: { x: u + a.offsetX, y: d + a.offsetY, startAngle: c, endAngle: h, circumference: g, outerRadius: m, innerRadius: p, label: v(f.label, e, a.data.labels[e]) } }); var b = t._model; this.removeHoverStyle(t), i && l.animateRotate || (b.startAngle = 0 === e ? s.rotation : n.getMeta().data[e - 1]._model.endAngle, b.endAngle = b.startAngle + b.circumference), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, calculateTotal: function () { var t, e = this.getDataset(), i = this.getMeta(), n = 0; return o.each(i.data, function (i, a) { t = e.data[a], isNaN(t) || i.hidden || (n += Math.abs(t)) }), n }, calculateCircumference: function (t) { var e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0 }, getMaxBorderWidth: function (t) { for (var e, i, n = 0, a = this.index, o = t.length, r = 0; r < o; r++)e = t[r]._model ? t[r]._model.borderWidth : 0, n = (i = t[r]._chart ? t[r]._chart.config.data.datasets[a].hoverBorderWidth : 0) > (n = e > n ? e : n) ? i : n; return n } }) } }, { 25: 25, 40: 40, 45: 45 }], 18: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("line", { showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } }), e.exports = function (t) { function e(t, e) { return o.valueOrDefault(t.showLine, e.showLines) } t.controllers.line = t.DatasetController.extend({ datasetElementType: a.Line, dataElementType: a.Point, update: function (t) { var i, n, a, r = this, s = r.getMeta(), l = s.dataset, u = s.data || [], d = r.chart.options, c = d.elements.line, h = r.getScaleForId(s.yAxisID), f = r.getDataset(), g = e(f, d); for (g && (a = l.custom || {}, void 0 !== f.tension && void 0 === f.lineTension && (f.lineTension = f.tension), l._scale = h, l._datasetIndex = r.index, l._children = u, l._model = { spanGaps: f.spanGaps ? f.spanGaps : d.spanGaps, tension: a.tension ? a.tension : o.valueOrDefault(f.lineTension, c.tension), backgroundColor: a.backgroundColor ? a.backgroundColor : f.backgroundColor || c.backgroundColor, borderWidth: a.borderWidth ? a.borderWidth : f.borderWidth || c.borderWidth, borderColor: a.borderColor ? a.borderColor : f.borderColor || c.borderColor, borderCapStyle: a.borderCapStyle ? a.borderCapStyle : f.borderCapStyle || c.borderCapStyle, borderDash: a.borderDash ? a.borderDash : f.borderDash || c.borderDash, borderDashOffset: a.borderDashOffset ? a.borderDashOffset : f.borderDashOffset || c.borderDashOffset, borderJoinStyle: a.borderJoinStyle ? a.borderJoinStyle : f.borderJoinStyle || c.borderJoinStyle, fill: a.fill ? a.fill : void 0 !== f.fill ? f.fill : c.fill, steppedLine: a.steppedLine ? a.steppedLine : o.valueOrDefault(f.steppedLine, c.stepped), cubicInterpolationMode: a.cubicInterpolationMode ? a.cubicInterpolationMode : o.valueOrDefault(f.cubicInterpolationMode, c.cubicInterpolationMode) }, l.pivot()), i = 0, n = u.length; i < n; ++i)r.updateElement(u[i], i, t); for (g && 0 !== l._model.tension && r.updateBezierControlPoints(), i = 0, n = u.length; i < n; ++i)u[i].pivot() }, getPointBackgroundColor: function (t, e) { var i = this.chart.options.elements.point.backgroundColor, n = this.getDataset(), a = t.custom || {}; return a.backgroundColor ? i = a.backgroundColor : n.pointBackgroundColor ? i = o.valueAtIndexOrDefault(n.pointBackgroundColor, e, i) : n.backgroundColor && (i = n.backgroundColor), i }, getPointBorderColor: function (t, e) { var i = this.chart.options.elements.point.borderColor, n = this.getDataset(), a = t.custom || {}; return a.borderColor ? i = a.borderColor : n.pointBorderColor ? i = o.valueAtIndexOrDefault(n.pointBorderColor, e, i) : n.borderColor && (i = n.borderColor), i }, getPointBorderWidth: function (t, e) { var i = this.chart.options.elements.point.borderWidth, n = this.getDataset(), a = t.custom || {}; return isNaN(a.borderWidth) ? !isNaN(n.pointBorderWidth) || o.isArray(n.pointBorderWidth) ? i = o.valueAtIndexOrDefault(n.pointBorderWidth, e, i) : isNaN(n.borderWidth) || (i = n.borderWidth) : i = a.borderWidth, i }, updateElement: function (t, e, i) { var n, a, r = this, s = r.getMeta(), l = t.custom || {}, u = r.getDataset(), d = r.index, c = u.data[e], h = r.getScaleForId(s.yAxisID), f = r.getScaleForId(s.xAxisID), g = r.chart.options.elements.point; void 0 !== u.radius && void 0 === u.pointRadius && (u.pointRadius = u.radius), void 0 !== u.hitRadius && void 0 === u.pointHitRadius && (u.pointHitRadius = u.hitRadius), n = f.getPixelForValue("object" == typeof c ? c : NaN, e, d), a = i ? h.getBasePixel() : r.calculatePointY(c, e, d), t._xScale = f, t._yScale = h, t._datasetIndex = d, t._index = e, t._model = { x: n, y: a, skip: l.skip || isNaN(n) || isNaN(a), radius: l.radius || o.valueAtIndexOrDefault(u.pointRadius, e, g.radius), pointStyle: l.pointStyle || o.valueAtIndexOrDefault(u.pointStyle, e, g.pointStyle), backgroundColor: r.getPointBackgroundColor(t, e), borderColor: r.getPointBorderColor(t, e), borderWidth: r.getPointBorderWidth(t, e), tension: s.dataset._model ? s.dataset._model.tension : 0, steppedLine: !!s.dataset._model && s.dataset._model.steppedLine, hitRadius: l.hitRadius || o.valueAtIndexOrDefault(u.pointHitRadius, e, g.hitRadius) } }, calculatePointY: function (t, e, i) { var n, a, o, r = this.chart, s = this.getMeta(), l = this.getScaleForId(s.yAxisID), u = 0, d = 0; if (l.options.stacked) { for (n = 0; n < i; n++)if (a = r.data.datasets[n], "line" === (o = r.getDatasetMeta(n)).type && o.yAxisID === l.id && r.isDatasetVisible(n)) { var c = Number(l.getRightValue(a.data[e])); c < 0 ? d += c || 0 : u += c || 0 } var h = Number(l.getRightValue(t)); return h < 0 ? l.getPixelForValue(d + h) : l.getPixelForValue(u + h) } return l.getPixelForValue(t) }, updateBezierControlPoints: function () { var t, e, i, n, a = this.getMeta(), r = this.chart.chartArea, s = a.data || []; function l(t, e, i) { return Math.max(Math.min(t, i), e) } if (a.dataset._model.spanGaps && (s = s.filter(function (t) { return !t._model.skip })), "monotone" === a.dataset._model.cubicInterpolationMode) o.splineCurveMonotone(s); else for (t = 0, e = s.length; t < e; ++t)i = s[t]._model, n = o.splineCurve(o.previousItem(s, t)._model, i, o.nextItem(s, t)._model, a.dataset._model.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y; if (this.chart.options.elements.line.capBezierPoints) for (t = 0, e = s.length; t < e; ++t)(i = s[t]._model).controlPointPreviousX = l(i.controlPointPreviousX, r.left, r.right), i.controlPointPreviousY = l(i.controlPointPreviousY, r.top, r.bottom), i.controlPointNextX = l(i.controlPointNextX, r.left, r.right), i.controlPointNextY = l(i.controlPointNextY, r.top, r.bottom) }, draw: function () { var t = this.chart, i = this.getMeta(), n = i.data || [], a = t.chartArea, r = n.length, s = 0; for (o.canvas.clipArea(t.ctx, a), e(this.getDataset(), t.options) && i.dataset.draw(), o.canvas.unclipArea(t.ctx); s < r; ++s)n[s].draw(a) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; a.radius = n.hoverRadius || o.valueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), a.backgroundColor = n.hoverBackgroundColor || o.valueAtIndexOrDefault(e.pointHoverBackgroundColor, i, o.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor || o.valueAtIndexOrDefault(e.pointHoverBorderColor, i, o.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth || o.valueAtIndexOrDefault(e.pointHoverBorderWidth, i, a.borderWidth) }, removeHoverStyle: function (t) { var e = this, i = e.chart.data.datasets[t._datasetIndex], n = t._index, a = t.custom || {}, r = t._model; void 0 !== i.radius && void 0 === i.pointRadius && (i.pointRadius = i.radius), r.radius = a.radius || o.valueAtIndexOrDefault(i.pointRadius, n, e.chart.options.elements.point.radius), r.backgroundColor = e.getPointBackgroundColor(t, n), r.borderColor = e.getPointBorderColor(t, n), r.borderWidth = e.getPointBorderWidth(t, n) } }) } }, { 25: 25, 40: 40, 45: 45 }], 19: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("polarArea", { scale: { type: "radialLinear", angleLines: { display: !1 }, gridLines: { circular: !0 }, pointLabels: { display: !1 }, ticks: { beginAtZero: !0 } }, animation: { animateRotate: !0, animateScale: !0 }, startAngle: -.5 * Math.PI, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, a = i.labels; if (n.length) for (var o = 0; o < n[0].data.length; ++o)e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) { var a = t.getDatasetMeta(0), r = e.datasets[0], s = a.data[n].custom || {}, l = o.valueAtIndexOrDefault, u = t.options.elements.arc; return { text: i, fillStyle: s.backgroundColor ? s.backgroundColor : l(r.backgroundColor, n, u.backgroundColor), strokeStyle: s.borderColor ? s.borderColor : l(r.borderColor, n, u.borderColor), lineWidth: s.borderWidth ? s.borderWidth : l(r.borderWidth, n, u.borderWidth), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n } }) : [] } }, onClick: function (t, e) { var i, n, a, o = e.index, r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)(a = r.getDatasetMeta(i)).data[o].hidden = !a.data[o].hidden; r.update() } }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { return e.labels[t.index] + ": " + t.yLabel } } } }), e.exports = function (t) { t.controllers.polarArea = t.DatasetController.extend({ dataElementType: a.Arc, linkScales: o.noop, update: function (t) { var e = this, i = e.chart, n = i.chartArea, a = e.getMeta(), r = i.options, s = r.elements.arc, l = Math.min(n.right - n.left, n.bottom - n.top); i.outerRadius = Math.max((l - s.borderWidth / 2) / 2, 0), i.innerRadius = Math.max(r.cutoutPercentage ? i.outerRadius / 100 * r.cutoutPercentage : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), e.outerRadius = i.outerRadius - i.radiusLength * e.index, e.innerRadius = e.outerRadius - i.radiusLength, a.count = e.countVisibleElements(), o.each(a.data, function (i, n) { e.updateElement(i, n, t) }) }, updateElement: function (t, e, i) { for (var n = this, a = n.chart, r = n.getDataset(), s = a.options, l = s.animation, u = a.scale, d = a.data.labels, c = n.calculateCircumference(r.data[e]), h = u.xCenter, f = u.yCenter, g = 0, p = n.getMeta(), m = 0; m < e; ++m)isNaN(r.data[m]) || p.data[m].hidden || ++g; var v = s.startAngle, b = t.hidden ? 0 : u.getDistanceFromCenterForValue(r.data[e]), x = v + c * g, y = x + (t.hidden ? 0 : c), k = l.animateScale ? 0 : u.getDistanceFromCenterForValue(r.data[e]); o.extend(t, { _datasetIndex: n.index, _index: e, _scale: u, _model: { x: h, y: f, innerRadius: 0, outerRadius: i ? k : b, startAngle: i && l.animateRotate ? v : x, endAngle: i && l.animateRotate ? v : y, label: o.valueAtIndexOrDefault(d, e, d[e]) } }), n.removeHoverStyle(t), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, countVisibleElements: function () { var t = this.getDataset(), e = this.getMeta(), i = 0; return o.each(e.data, function (e, n) { isNaN(t.data[n]) || e.hidden || i++ }), i }, calculateCircumference: function (t) { var e = this.getMeta().count; return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0 } }) } }, { 25: 25, 40: 40, 45: 45 }], 20: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("radar", { scale: { type: "radialLinear" }, elements: { line: { tension: 0 } } }), e.exports = function (t) { t.controllers.radar = t.DatasetController.extend({ datasetElementType: a.Line, dataElementType: a.Point, linkScales: o.noop, update: function (t) { var e = this, i = e.getMeta(), n = i.dataset, a = i.data, r = n.custom || {}, s = e.getDataset(), l = e.chart.options.elements.line, u = e.chart.scale; void 0 !== s.tension && void 0 === s.lineTension && (s.lineTension = s.tension), o.extend(i.dataset, { _datasetIndex: e.index, _scale: u, _children: a, _loop: !0, _model: { tension: r.tension ? r.tension : o.valueOrDefault(s.lineTension, l.tension), backgroundColor: r.backgroundColor ? r.backgroundColor : s.backgroundColor || l.backgroundColor, borderWidth: r.borderWidth ? r.borderWidth : s.borderWidth || l.borderWidth, borderColor: r.borderColor ? r.borderColor : s.borderColor || l.borderColor, fill: r.fill ? r.fill : void 0 !== s.fill ? s.fill : l.fill, borderCapStyle: r.borderCapStyle ? r.borderCapStyle : s.borderCapStyle || l.borderCapStyle, borderDash: r.borderDash ? r.borderDash : s.borderDash || l.borderDash, borderDashOffset: r.borderDashOffset ? r.borderDashOffset : s.borderDashOffset || l.borderDashOffset, borderJoinStyle: r.borderJoinStyle ? r.borderJoinStyle : s.borderJoinStyle || l.borderJoinStyle } }), i.dataset.pivot(), o.each(a, function (i, n) { e.updateElement(i, n, t) }, e), e.updateBezierControlPoints() }, updateElement: function (t, e, i) { var n = this, a = t.custom || {}, r = n.getDataset(), s = n.chart.scale, l = n.chart.options.elements.point, u = s.getPointPositionForValue(e, r.data[e]); void 0 !== r.radius && void 0 === r.pointRadius && (r.pointRadius = r.radius), void 0 !== r.hitRadius && void 0 === r.pointHitRadius && (r.pointHitRadius = r.hitRadius), o.extend(t, { _datasetIndex: n.index, _index: e, _scale: s, _model: { x: i ? s.xCenter : u.x, y: i ? s.yCenter : u.y, tension: a.tension ? a.tension : o.valueOrDefault(r.lineTension, n.chart.options.elements.line.tension), radius: a.radius ? a.radius : o.valueAtIndexOrDefault(r.pointRadius, e, l.radius), backgroundColor: a.backgroundColor ? a.backgroundColor : o.valueAtIndexOrDefault(r.pointBackgroundColor, e, l.backgroundColor), borderColor: a.borderColor ? a.borderColor : o.valueAtIndexOrDefault(r.pointBorderColor, e, l.borderColor), borderWidth: a.borderWidth ? a.borderWidth : o.valueAtIndexOrDefault(r.pointBorderWidth, e, l.borderWidth), pointStyle: a.pointStyle ? a.pointStyle : o.valueAtIndexOrDefault(r.pointStyle, e, l.pointStyle), hitRadius: a.hitRadius ? a.hitRadius : o.valueAtIndexOrDefault(r.pointHitRadius, e, l.hitRadius) } }), t._model.skip = a.skip ? a.skip : isNaN(t._model.x) || isNaN(t._model.y) }, updateBezierControlPoints: function () { var t = this.chart.chartArea, e = this.getMeta(); o.each(e.data, function (i, n) { var a = i._model, r = o.splineCurve(o.previousItem(e.data, n, !0)._model, a, o.nextItem(e.data, n, !0)._model, a.tension); a.controlPointPreviousX = Math.max(Math.min(r.previous.x, t.right), t.left), a.controlPointPreviousY = Math.max(Math.min(r.previous.y, t.bottom), t.top), a.controlPointNextX = Math.max(Math.min(r.next.x, t.right), t.left), a.controlPointNextY = Math.max(Math.min(r.next.y, t.bottom), t.top), i.pivot() }) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, a = t._model; a.radius = i.hoverRadius ? i.hoverRadius : o.valueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), a.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : o.valueAtIndexOrDefault(e.pointHoverBackgroundColor, n, o.getHoverColor(a.backgroundColor)), a.borderColor = i.hoverBorderColor ? i.hoverBorderColor : o.valueAtIndexOrDefault(e.pointHoverBorderColor, n, o.getHoverColor(a.borderColor)), a.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : o.valueAtIndexOrDefault(e.pointHoverBorderWidth, n, a.borderWidth) }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, a = t._model, r = this.chart.options.elements.point; a.radius = i.radius ? i.radius : o.valueAtIndexOrDefault(e.pointRadius, n, r.radius), a.backgroundColor = i.backgroundColor ? i.backgroundColor : o.valueAtIndexOrDefault(e.pointBackgroundColor, n, r.backgroundColor), a.borderColor = i.borderColor ? i.borderColor : o.valueAtIndexOrDefault(e.pointBorderColor, n, r.borderColor), a.borderWidth = i.borderWidth ? i.borderWidth : o.valueAtIndexOrDefault(e.pointBorderWidth, n, r.borderWidth) } }) } }, { 25: 25, 40: 40, 45: 45 }], 21: [function (t, e, i) { "use strict"; t(25)._set("scatter", { hover: { mode: "single" }, scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] }, showLines: !1, tooltips: { callbacks: { title: function () { return "" }, label: function (t) { return "(" + t.xLabel + ", " + t.yLabel + ")" } } } }), e.exports = function (t) { t.controllers.scatter = t.controllers.line } }, { 25: 25 }], 22: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { animation: { duration: 1e3, easing: "easeOutQuart", onProgress: o.noop, onComplete: o.noop } }), e.exports = function (t) { t.Animation = a.extend({ chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null }), t.animationService = { frameDuration: 17, animations: [], dropFrames: 0, request: null, addAnimation: function (t, e, i, n) { var a, o, r = this.animations; for (e.chart = t, n || (t.animating = !0), a = 0, o = r.length; a < o; ++a)if (r[a].chart === t) return void (r[a] = e); r.push(e), 1 === r.length && this.requestAnimationFrame() }, cancelAnimation: function (t) { var e = o.findIndex(this.animations, function (e) { return e.chart === t }); -1 !== e && (this.animations.splice(e, 1), t.animating = !1) }, requestAnimationFrame: function () { var t = this; null === t.request && (t.request = o.requestAnimFrame.call(window, function () { t.request = null, t.startDigest() })) }, startDigest: function () { var t = this, e = Date.now(), i = 0; t.dropFrames > 1 && (i = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1), t.advance(1 + i); var n = Date.now(); t.dropFrames += (n - e) / t.frameDuration, t.animations.length > 0 && t.requestAnimationFrame() }, advance: function (t) { for (var e, i, n = this.animations, a = 0; a < n.length;)i = (e = n[a]).chart, e.currentStep = (e.currentStep || 0) + t, e.currentStep = Math.min(e.currentStep, e.numSteps), o.callback(e.render, [i, e], i), o.callback(e.onAnimationProgress, [e], i), e.currentStep >= e.numSteps ? (o.callback(e.onAnimationComplete, [e], i), i.animating = !1, n.splice(a, 1)) : ++a } }, Object.defineProperty(t.Animation.prototype, "animationObject", { get: function () { return this } }), Object.defineProperty(t.Animation.prototype, "chartInstance", { get: function () { return this.chart }, set: function (t) { this.chart = t } }) } }, { 25: 25, 26: 26, 45: 45 }], 23: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(28), r = t(30), s = t(48), l = t(31); e.exports = function (t) { function e(t) { return "top" === t || "bottom" === t } t.types = {}, t.instances = {}, t.controllers = {}, a.extend(t.prototype, { construct: function (e, i) { var o, r, l = this; (r = (o = (o = i) || {}).data = o.data || {}).datasets = r.datasets || [], r.labels = r.labels || [], o.options = a.configMerge(n.global, n[o.type], o.options || {}), i = o; var u = s.acquireContext(e, i), d = u && u.canvas, c = d && d.height, h = d && d.width; l.id = a.uid(), l.ctx = u, l.canvas = d, l.config = i, l.width = h, l.height = c, l.aspectRatio = c ? h / c : null, l.options = i.options, l._bufferedRender = !1, l.chart = l, l.controller = l, t.instances[l.id] = l, Object.defineProperty(l, "data", { get: function () { return l.config.data }, set: function (t) { l.config.data = t } }), u && d ? (l.initialize(), l.update()) : console.error("Failed to create chart: can't acquire context from the given item") }, initialize: function () { var t = this; return l.notify(t, "beforeInit"), a.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.initToolTip(), l.notify(t, "afterInit"), t }, clear: function () { return a.canvas.clear(this), this }, stop: function () { return t.animationService.cancelAnimation(this), this }, resize: function (t) { var e = this, i = e.options, n = e.canvas, o = i.maintainAspectRatio && e.aspectRatio || null, r = Math.max(0, Math.floor(a.getMaximumWidth(n))), s = Math.max(0, Math.floor(o ? r / o : a.getMaximumHeight(n))); if ((e.width !== r || e.height !== s) && (n.width = e.width = r, n.height = e.height = s, n.style.width = r + "px", n.style.height = s + "px", a.retinaScale(e, i.devicePixelRatio), !t)) { var u = { width: r, height: s }; l.notify(e, "resize", [u]), e.options.onResize && e.options.onResize(e, u), e.stop(), e.update(e.options.responsiveAnimationDuration) } }, ensureScalesHaveIDs: function () { var t = this.options, e = t.scales || {}, i = t.scale; a.each(e.xAxes, function (t, e) { t.id = t.id || "x-axis-" + e }), a.each(e.yAxes, function (t, e) { t.id = t.id || "y-axis-" + e }), i && (i.id = i.id || "scale") }, buildOrUpdateScales: function () { var i = this, n = i.options, o = i.scales || {}, r = [], s = Object.keys(o).reduce(function (t, e) { return t[e] = !1, t }, {}); n.scales && (r = r.concat((n.scales.xAxes || []).map(function (t) { return { options: t, dtype: "category", dposition: "bottom" } }), (n.scales.yAxes || []).map(function (t) { return { options: t, dtype: "linear", dposition: "left" } }))), n.scale && r.push({ options: n.scale, dtype: "radialLinear", isDefault: !0, dposition: "chartArea" }), a.each(r, function (n) { var r = n.options, l = r.id, u = a.valueOrDefault(r.type, n.dtype); e(r.position) !== e(n.dposition) && (r.position = n.dposition), s[l] = !0; var d = null; if (l in o && o[l].type === u) (d = o[l]).options = r, d.ctx = i.ctx, d.chart = i; else { var c = t.scaleService.getScaleConstructor(u); if (!c) return; d = new c({ id: l, type: u, options: r, ctx: i.ctx, chart: i }), o[d.id] = d } d.mergeTicksOptions(), n.isDefault && (i.scale = d) }), a.each(s, function (t, e) { t || delete o[e] }), i.scales = o, t.scaleService.addScalesToLayout(this) }, buildOrUpdateControllers: function () { var e = this, i = [], n = []; return a.each(e.data.datasets, function (a, o) { var r = e.getDatasetMeta(o), s = a.type || e.config.type; if (r.type && r.type !== s && (e.destroyDatasetMeta(o), r = e.getDatasetMeta(o)), r.type = s, i.push(r.type), r.controller) r.controller.updateIndex(o), r.controller.linkScales(); else { var l = t.controllers[r.type]; if (void 0 === l) throw new Error('"' + r.type + '" is not a chart type.'); r.controller = new l(e, o), n.push(r.controller) } }, e), n }, resetElements: function () { var t = this; a.each(t.data.datasets, function (e, i) { t.getDatasetMeta(i).controller.reset() }, t) }, reset: function () { this.resetElements(), this.tooltip.initialize() }, update: function (e) { var i, n, o = this; if (e && "object" == typeof e || (e = { duration: e, lazy: arguments[1] }), n = (i = o).options, a.each(i.scales, function (t) { r.removeBox(i, t) }), n = a.configMerge(t.defaults.global, t.defaults[i.config.type], n), i.options = i.config.options = n, i.ensureScalesHaveIDs(), i.buildOrUpdateScales(), i.tooltip._options = n.tooltips, i.tooltip.initialize(), l._invalidate(o), !1 !== l.notify(o, "beforeUpdate")) { o.tooltip._data = o.data; var s = o.buildOrUpdateControllers(); a.each(o.data.datasets, function (t, e) { o.getDatasetMeta(e).controller.buildOrUpdateElements() }, o), o.updateLayout(), o.options.animation && o.options.animation.duration && a.each(s, function (t) { t.reset() }), o.updateDatasets(), o.tooltip.initialize(), o.lastActive = [], l.notify(o, "afterUpdate"), o._bufferedRender ? o._bufferedRequest = { duration: e.duration, easing: e.easing, lazy: e.lazy } : o.render(e) } }, updateLayout: function () { !1 !== l.notify(this, "beforeLayout") && (r.update(this, this.width, this.height), l.notify(this, "afterScaleUpdate"), l.notify(this, "afterLayout")) }, updateDatasets: function () { if (!1 !== l.notify(this, "beforeDatasetsUpdate")) { for (var t = 0, e = this.data.datasets.length; t < e; ++t)this.updateDataset(t); l.notify(this, "afterDatasetsUpdate") } }, updateDataset: function (t) { var e = this.getDatasetMeta(t), i = { meta: e, index: t }; !1 !== l.notify(this, "beforeDatasetUpdate", [i]) && (e.controller.update(), l.notify(this, "afterDatasetUpdate", [i])) }, render: function (e) { var i = this; e && "object" == typeof e || (e = { duration: e, lazy: arguments[1] }); var n = e.duration, o = e.lazy; if (!1 !== l.notify(i, "beforeRender")) { var r = i.options.animation, s = function (t) { l.notify(i, "afterRender"), a.callback(r && r.onComplete, [t], i) }; if (r && (void 0 !== n && 0 !== n || void 0 === n && 0 !== r.duration)) { var u = new t.Animation({ numSteps: (n || r.duration) / 16.66, easing: e.easing || r.easing, render: function (t, e) { var i = a.easing.effects[e.easing], n = e.currentStep, o = n / e.numSteps; t.draw(i(o), o, n) }, onAnimationProgress: r.onProgress, onAnimationComplete: s }); t.animationService.addAnimation(i, u, n, o) } else i.draw(), s(new t.Animation({ numSteps: 0, chart: i })); return i } }, draw: function (t) { var e = this; e.clear(), a.isNullOrUndef(t) && (t = 1), e.transition(t), !1 !== l.notify(e, "beforeDraw", [t]) && (a.each(e.boxes, function (t) { t.draw(e.chartArea) }, e), e.scale && e.scale.draw(), e.drawDatasets(t), e._drawTooltip(t), l.notify(e, "afterDraw", [t])) }, transition: function (t) { for (var e = 0, i = (this.data.datasets || []).length; e < i; ++e)this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t); this.tooltip.transition(t) }, drawDatasets: function (t) { var e = this; if (!1 !== l.notify(e, "beforeDatasetsDraw", [t])) { for (var i = (e.data.datasets || []).length - 1; i >= 0; --i)e.isDatasetVisible(i) && e.drawDataset(i, t); l.notify(e, "afterDatasetsDraw", [t]) } }, drawDataset: function (t, e) { var i = this.getDatasetMeta(t), n = { meta: i, index: t, easingValue: e }; !1 !== l.notify(this, "beforeDatasetDraw", [n]) && (i.controller.draw(e), l.notify(this, "afterDatasetDraw", [n])) }, _drawTooltip: function (t) { var e = this.tooltip, i = { tooltip: e, easingValue: t }; !1 !== l.notify(this, "beforeTooltipDraw", [i]) && (e.draw(), l.notify(this, "afterTooltipDraw", [i])) }, getElementAtEvent: function (t) { return o.modes.single(this, t) }, getElementsAtEvent: function (t) { return o.modes.label(this, t, { intersect: !0 }) }, getElementsAtXAxis: function (t) { return o.modes["x-axis"](this, t, { intersect: !0 }) }, getElementsAtEventForMode: function (t, e, i) { var n = o.modes[e]; return "function" == typeof n ? n(this, t, i) : [] }, getDatasetAtEvent: function (t) { return o.modes.dataset(this, t, { intersect: !0 }) }, getDatasetMeta: function (t) { var e = this.data.datasets[t]; e._meta || (e._meta = {}); var i = e._meta[this.id]; return i || (i = e._meta[this.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null }), i }, getVisibleDatasetCount: function () { for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e)this.isDatasetVisible(e) && t++; return t }, isDatasetVisible: function (t) { var e = this.getDatasetMeta(t); return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden }, generateLegend: function () { return this.options.legendCallback(this) }, destroyDatasetMeta: function (t) { var e = this.id, i = this.data.datasets[t], n = i._meta && i._meta[e]; n && (n.controller.destroy(), delete i._meta[e]) }, destroy: function () { var e, i, n = this, o = n.canvas; for (n.stop(), e = 0, i = n.data.datasets.length; e < i; ++e)n.destroyDatasetMeta(e); o && (n.unbindEvents(), a.canvas.clear(n), s.releaseContext(n.ctx), n.canvas = null, n.ctx = null), l.notify(n, "destroy"), delete t.instances[n.id] }, toBase64Image: function () { return this.canvas.toDataURL.apply(this.canvas, arguments) }, initToolTip: function () { var e = this; e.tooltip = new t.Tooltip({ _chart: e, _chartInstance: e, _data: e.data, _options: e.options.tooltips }, e) }, bindEvents: function () { var t = this, e = t._listeners = {}, i = function () { t.eventHandler.apply(t, arguments) }; a.each(t.options.events, function (n) { s.addEventListener(t, n, i), e[n] = i }), t.options.responsive && (i = function () { t.resize() }, s.addEventListener(t, "resize", i), e.resize = i) }, unbindEvents: function () { var t = this, e = t._listeners; e && (delete t._listeners, a.each(e, function (e, i) { s.removeEventListener(t, i, e) })) }, updateHoverStyle: function (t, e, i) { var n, a, o, r = i ? "setHoverStyle" : "removeHoverStyle"; for (a = 0, o = t.length; a < o; ++a)(n = t[a]) && this.getDatasetMeta(n._datasetIndex).controller[r](n) }, eventHandler: function (t) { var e = this, i = e.tooltip; if (!1 !== l.notify(e, "beforeEvent", [t])) { e._bufferedRender = !0, e._bufferedRequest = null; var n = e.handleEvent(t); i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), l.notify(e, "afterEvent", [t]); var a = e._bufferedRequest; return a ? e.render(a) : n && !e.animating && (e.stop(), e.render(e.options.hover.animationDuration, !0)), e._bufferedRender = !1, e._bufferedRequest = null, e } }, handleEvent: function (t) { var e, i = this, n = i.options || {}, o = n.hover; return i.lastActive = i.lastActive || [], "mouseout" === t.type ? i.active = [] : i.active = i.getElementsAtEventForMode(t, o.mode, o), a.callback(n.onHover || n.hover.onHover, [t.native, i.active], i), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, o.mode, !1), i.active.length && o.mode && i.updateHoverStyle(i.active, o.mode, !0), e = !a.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, e } }), t.Controller = t } }, { 25: 25, 28: 28, 30: 30, 31: 31, 45: 45, 48: 48 }], 24: [function (t, e, i) { "use strict"; var n = t(45); e.exports = function (t) { var e = ["push", "pop", "shift", "splice", "unshift"]; function i(t, i) { var n = t._chartjs; if (n) { var a = n.listeners, o = a.indexOf(i); -1 !== o && a.splice(o, 1), a.length > 0 || (e.forEach(function (e) { delete t[e] }), delete t._chartjs) } } t.DatasetController = function (t, e) { this.initialize(t, e) }, n.extend(t.DatasetController.prototype, { datasetElementType: null, dataElementType: null, initialize: function (t, e) { this.chart = t, this.index = e, this.linkScales(), this.addElements() }, updateIndex: function (t) { this.index = t }, linkScales: function () { var t = this, e = t.getMeta(), i = t.getDataset(); null !== e.xAxisID && e.xAxisID in t.chart.scales || (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id), null !== e.yAxisID && e.yAxisID in t.chart.scales || (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id) }, getDataset: function () { return this.chart.data.datasets[this.index] }, getMeta: function () { return this.chart.getDatasetMeta(this.index) }, getScaleForId: function (t) { return this.chart.scales[t] }, reset: function () { this.update(!0) }, destroy: function () { this._data && i(this._data, this) }, createMetaDataset: function () { var t = this.datasetElementType; return t && new t({ _chart: this.chart, _datasetIndex: this.index }) }, createMetaData: function (t) { var e = this.dataElementType; return e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t }) }, addElements: function () { var t, e, i = this.getMeta(), n = this.getDataset().data || [], a = i.data; for (t = 0, e = n.length; t < e; ++t)a[t] = a[t] || this.createMetaData(t); i.dataset = i.dataset || this.createMetaDataset() }, addElementAndReset: function (t) { var e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0) }, buildOrUpdateElements: function () { var t, a, o = this, r = o.getDataset(), s = r.data || (r.data = []); o._data !== s && (o._data && i(o._data, o), a = o, (t = s)._chartjs ? t._chartjs.listeners.push(a) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [a] } }), e.forEach(function (e) { var i = "onData" + e.charAt(0).toUpperCase() + e.slice(1), a = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: function () { var e = Array.prototype.slice.call(arguments), o = a.apply(this, e); return n.each(t._chartjs.listeners, function (t) { "function" == typeof t[i] && t[i].apply(t, e) }), o } }) })), o._data = s), o.resyncElements() }, update: n.noop, transition: function (t) { for (var e = this.getMeta(), i = e.data || [], n = i.length, a = 0; a < n; ++a)i[a].transition(t); e.dataset && e.dataset.transition(t) }, draw: function () { var t = this.getMeta(), e = t.data || [], i = e.length, n = 0; for (t.dataset && t.dataset.draw(); n < i; ++n)e[n].draw() }, removeHoverStyle: function (t, e) { var i = this.chart.data.datasets[t._datasetIndex], a = t._index, o = t.custom || {}, r = n.valueAtIndexOrDefault, s = t._model; s.backgroundColor = o.backgroundColor ? o.backgroundColor : r(i.backgroundColor, a, e.backgroundColor), s.borderColor = o.borderColor ? o.borderColor : r(i.borderColor, a, e.borderColor), s.borderWidth = o.borderWidth ? o.borderWidth : r(i.borderWidth, a, e.borderWidth) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, a = t.custom || {}, o = n.valueAtIndexOrDefault, r = n.getHoverColor, s = t._model; s.backgroundColor = a.hoverBackgroundColor ? a.hoverBackgroundColor : o(e.hoverBackgroundColor, i, r(s.backgroundColor)), s.borderColor = a.hoverBorderColor ? a.hoverBorderColor : o(e.hoverBorderColor, i, r(s.borderColor)), s.borderWidth = a.hoverBorderWidth ? a.hoverBorderWidth : o(e.hoverBorderWidth, i, s.borderWidth) }, resyncElements: function () { var t = this.getMeta(), e = this.getDataset().data, i = t.data.length, n = e.length; n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i) }, insertElements: function (t, e) { for (var i = 0; i < e; ++i)this.addElementAndReset(t + i) }, onDataPush: function () { this.insertElements(this.getDataset().data.length - 1, arguments.length) }, onDataPop: function () { this.getMeta().data.pop() }, onDataShift: function () { this.getMeta().data.shift() }, onDataSplice: function (t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2) }, onDataUnshift: function () { this.insertElements(0, arguments.length) } }), t.DatasetController.extend = n.inherits } }, { 45: 45 }], 25: [function (t, e, i) { "use strict"; var n = t(45); e.exports = { _set: function (t, e) { return n.merge(this[t] || (this[t] = {}), e) } } }, { 45: 45 }], 26: [function (t, e, i) { "use strict"; var n = t(3), a = t(45); var o = function (t) { a.extend(this, t), this.initialize.apply(this, arguments) }; a.extend(o.prototype, { initialize: function () { this.hidden = !1 }, pivot: function () { var t = this; return t._view || (t._view = a.clone(t._model)), t._start = {}, t }, transition: function (t) { var e = this, i = e._model, a = e._start, o = e._view; return i && 1 !== t ? (o || (o = e._view = {}), a || (a = e._start = {}), function (t, e, i, a) { var o, r, s, l, u, d, c, h, f, g = Object.keys(i); for (o = 0, r = g.length; o < r; ++o)if (d = i[s = g[o]], e.hasOwnProperty(s) || (e[s] = d), (l = e[s]) !== d && "_" !== s[0]) { if (t.hasOwnProperty(s) || (t[s] = l), (c = typeof d) == typeof (u = t[s])) if ("string" === c) { if ((h = n(u)).valid && (f = n(d)).valid) { e[s] = f.mix(h, a).rgbString(); continue } } else if ("number" === c && isFinite(u) && isFinite(d)) { e[s] = u + (d - u) * a; continue } e[s] = d } }(a, o, i, t), e) : (e._view = i, e._start = null, e) }, tooltipPosition: function () { return { x: this._model.x, y: this._model.y } }, hasValue: function () { return a.isNumber(this._model.x) && a.isNumber(this._model.y) } }), o.extend = a.inherits, e.exports = o }, { 3: 3, 45: 45 }], 27: [function (t, e, i) { "use strict"; var n = t(3), a = t(25), o = t(45); e.exports = function (t) { function e(t, e, i) { var n; return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n } function i(t) { return null != t && "none" !== t } function r(t, n, a) { var o = document.defaultView, r = t.parentNode, s = o.getComputedStyle(t)[n], l = o.getComputedStyle(r)[n], u = i(s), d = i(l), c = Number.POSITIVE_INFINITY; return u || d ? Math.min(u ? e(s, t, a) : c, d ? e(l, r, a) : c) : "none" } o.configMerge = function () { return o.merge(o.clone(arguments[0]), [].slice.call(arguments, 1), { merger: function (e, i, n, a) { var r = i[e] || {}, s = n[e]; "scales" === e ? i[e] = o.scaleMerge(r, s) : "scale" === e ? i[e] = o.merge(r, [t.scaleService.getScaleDefaults(s.type), s]) : o._merger(e, i, n, a) } }) }, o.scaleMerge = function () { return o.merge(o.clone(arguments[0]), [].slice.call(arguments, 1), { merger: function (e, i, n, a) { if ("xAxes" === e || "yAxes" === e) { var r, s, l, u = n[e].length; for (i[e] || (i[e] = []), r = 0; r < u; ++r)l = n[e][r], s = o.valueOrDefault(l.type, "xAxes" === e ? "category" : "linear"), r >= i[e].length && i[e].push({}), !i[e][r].type || l.type && l.type !== i[e][r].type ? o.merge(i[e][r], [t.scaleService.getScaleDefaults(s), l]) : o.merge(i[e][r], l) } else o._merger(e, i, n, a) } }) }, o.where = function (t, e) { if (o.isArray(t) && Array.prototype.filter) return t.filter(e); var i = []; return o.each(t, function (t) { e(t) && i.push(t) }), i }, o.findIndex = Array.prototype.findIndex ? function (t, e, i) { return t.findIndex(e, i) } : function (t, e, i) { i = void 0 === i ? t : i; for (var n = 0, a = t.length; n < a; ++n)if (e.call(i, t[n], n, t)) return n; return -1 }, o.findNextWhere = function (t, e, i) { o.isNullOrUndef(i) && (i = -1); for (var n = i + 1; n < t.length; n++) { var a = t[n]; if (e(a)) return a } }, o.findPreviousWhere = function (t, e, i) { o.isNullOrUndef(i) && (i = t.length); for (var n = i - 1; n >= 0; n--) { var a = t[n]; if (e(a)) return a } }, o.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t) }, o.almostEquals = function (t, e, i) { return Math.abs(t - e) < i }, o.almostWhole = function (t, e) { var i = Math.round(t); return i - e < t && i + e > t }, o.max = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.max(t, e) }, Number.NEGATIVE_INFINITY) }, o.min = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.min(t, e) }, Number.POSITIVE_INFINITY) }, o.sign = Math.sign ? function (t) { return Math.sign(t) } : function (t) { return 0 === (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1 }, o.log10 = Math.log10 ? function (t) { return Math.log10(t) } : function (t) { var e = Math.log(t) * Math.LOG10E, i = Math.round(e); return t === Math.pow(10, i) ? i : e }, o.toRadians = function (t) { return t * (Math.PI / 180) }, o.toDegrees = function (t) { return t * (180 / Math.PI) }, o.getAngleFromPoint = function (t, e) { var i = e.x - t.x, n = e.y - t.y, a = Math.sqrt(i * i + n * n), o = Math.atan2(n, i); return o < -.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: a } }, o.distanceBetweenPoints = function (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) }, o.aliasPixel = function (t) { return t % 2 == 0 ? 0 : .5 }, o.splineCurve = function (t, e, i, n) { var a = t.skip ? e : t, o = e, r = i.skip ? e : i, s = Math.sqrt(Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2)), l = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)), u = s / (s + l), d = l / (s + l), c = n * (u = isNaN(u) ? 0 : u), h = n * (d = isNaN(d) ? 0 : d); return { previous: { x: o.x - c * (r.x - a.x), y: o.y - c * (r.y - a.y) }, next: { x: o.x + h * (r.x - a.x), y: o.y + h * (r.y - a.y) } } }, o.EPSILON = Number.EPSILON || 1e-14, o.splineCurveMonotone = function (t) { var e, i, n, a, r, s, l, u, d, c = (t || []).map(function (t) { return { model: t._model, deltaK: 0, mK: 0 } }), h = c.length; for (e = 0; e < h; ++e)if (!(n = c[e]).model.skip) { if (i = e > 0 ? c[e - 1] : null, (a = e < h - 1 ? c[e + 1] : null) && !a.model.skip) { var f = a.model.x - n.model.x; n.deltaK = 0 !== f ? (a.model.y - n.model.y) / f : 0 } !i || i.model.skip ? n.mK = n.deltaK : !a || a.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2 } for (e = 0; e < h - 1; ++e)n = c[e], a = c[e + 1], n.model.skip || a.model.skip || (o.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = a.mK = 0 : (r = n.mK / n.deltaK, s = a.mK / n.deltaK, (u = Math.pow(r, 2) + Math.pow(s, 2)) <= 9 || (l = 3 / Math.sqrt(u), n.mK = r * l * n.deltaK, a.mK = s * l * n.deltaK))); for (e = 0; e < h; ++e)(n = c[e]).model.skip || (i = e > 0 ? c[e - 1] : null, a = e < h - 1 ? c[e + 1] : null, i && !i.model.skip && (d = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - d, n.model.controlPointPreviousY = n.model.y - d * n.mK), a && !a.model.skip && (d = (a.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + d, n.model.controlPointNextY = n.model.y + d * n.mK)) }, o.nextItem = function (t, e, i) { return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1] }, o.previousItem = function (t, e, i) { return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1] }, o.niceNum = function (t, e) { var i = Math.floor(o.log10(t)), n = t / Math.pow(10, i); return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, i) }, o.requestAnimFrame = "undefined" == typeof window ? function (t) { t() } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60) }, o.getRelativePosition = function (t, e) { var i, n, a = t.originalEvent || t, r = t.currentTarget || t.srcElement, s = r.getBoundingClientRect(), l = a.touches; l && l.length > 0 ? (i = l[0].clientX, n = l[0].clientY) : (i = a.clientX, n = a.clientY); var u = parseFloat(o.getStyle(r, "padding-left")), d = parseFloat(o.getStyle(r, "padding-top")), c = parseFloat(o.getStyle(r, "padding-right")), h = parseFloat(o.getStyle(r, "padding-bottom")), f = s.right - s.left - u - c, g = s.bottom - s.top - d - h; return { x: i = Math.round((i - s.left - u) / f * r.width / e.currentDevicePixelRatio), y: n = Math.round((n - s.top - d) / g * r.height / e.currentDevicePixelRatio) } }, o.getConstraintWidth = function (t) { return r(t, "max-width", "clientWidth") }, o.getConstraintHeight = function (t) { return r(t, "max-height", "clientHeight") }, o.getMaximumWidth = function (t) { var e = t.parentNode; if (!e) return t.clientWidth; var i = parseInt(o.getStyle(e, "padding-left"), 10), n = parseInt(o.getStyle(e, "padding-right"), 10), a = e.clientWidth - i - n, r = o.getConstraintWidth(t); return isNaN(r) ? a : Math.min(a, r) }, o.getMaximumHeight = function (t) { var e = t.parentNode; if (!e) return t.clientHeight; var i = parseInt(o.getStyle(e, "padding-top"), 10), n = parseInt(o.getStyle(e, "padding-bottom"), 10), a = e.clientHeight - i - n, r = o.getConstraintHeight(t); return isNaN(r) ? a : Math.min(a, r) }, o.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e) }, o.retinaScale = function (t, e) { var i = t.currentDevicePixelRatio = e || window.devicePixelRatio || 1; if (1 !== i) { var n = t.canvas, a = t.height, o = t.width; n.height = a * i, n.width = o * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = a + "px", n.style.width = o + "px") } }, o.fontString = function (t, e, i) { return e + " " + t + "px " + i }, o.longestText = function (t, e, i, n) { var a = (n = n || {}).data = n.data || {}, r = n.garbageCollect = n.garbageCollect || []; n.font !== e && (a = n.data = {}, r = n.garbageCollect = [], n.font = e), t.font = e; var s = 0; o.each(i, function (e) { null != e && !0 !== o.isArray(e) ? s = o.measureText(t, a, r, s, e) : o.isArray(e) && o.each(e, function (e) { null == e || o.isArray(e) || (s = o.measureText(t, a, r, s, e)) }) }); var l = r.length / 2; if (l > i.length) { for (var u = 0; u < l; u++)delete a[r[u]]; r.splice(0, l) } return s }, o.measureText = function (t, e, i, n, a) { var o = e[a]; return o || (o = e[a] = t.measureText(a).width, i.push(a)), o > n && (n = o), n }, o.numberOfLabelLines = function (t) { var e = 1; return o.each(t, function (t) { o.isArray(t) && t.length > e && (e = t.length) }), e }, o.color = n ? function (t) { return t instanceof CanvasGradient && (t = a.global.defaultColor), n(t) } : function (t) { return console.error("Color.js not found!"), t }, o.getHoverColor = function (t) { return t instanceof CanvasPattern ? t : o.color(t).saturate(.5).darken(.1).rgbString() } } }, { 25: 25, 3: 3, 45: 45 }], 28: [function (t, e, i) { "use strict"; var n = t(45); function a(t, e) { return t.native ? { x: t.x, y: t.y } : n.getRelativePosition(t, e) } function o(t, e) { var i, n, a, o, r; for (n = 0, o = t.data.datasets.length; n < o; ++n)if (t.isDatasetVisible(n)) for (a = 0, r = (i = t.getDatasetMeta(n)).data.length; a < r; ++a) { var s = i.data[a]; s._view.skip || e(s) } } function r(t, e) { var i = []; return o(t, function (t) { t.inRange(e.x, e.y) && i.push(t) }), i } function s(t, e, i, n) { var a = Number.POSITIVE_INFINITY, r = []; return o(t, function (t) { if (!i || t.inRange(e.x, e.y)) { var o = t.getCenterPoint(), s = n(e, o); s < a ? (r = [t], a = s) : s === a && r.push(t) } }), r } function l(t) { var e = -1 !== t.indexOf("x"), i = -1 !== t.indexOf("y"); return function (t, n) { var a = e ? Math.abs(t.x - n.x) : 0, o = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2)) } } function u(t, e, i) { var n = a(e, t); i.axis = i.axis || "x"; var o = l(i.axis), u = i.intersect ? r(t, n) : s(t, n, !1, o), d = []; return u.length ? (t.data.datasets.forEach(function (e, i) { if (t.isDatasetVisible(i)) { var n = t.getDatasetMeta(i).data[u[0]._index]; n && !n._view.skip && d.push(n) } }), d) : [] } e.exports = { modes: { single: function (t, e) { var i = a(e, t), n = []; return o(t, function (t) { if (t.inRange(i.x, i.y)) return n.push(t), n }), n.slice(0, 1) }, label: u, index: u, dataset: function (t, e, i) { var n = a(e, t); i.axis = i.axis || "xy"; var o = l(i.axis), u = i.intersect ? r(t, n) : s(t, n, !1, o); return u.length > 0 && (u = t.getDatasetMeta(u[0]._datasetIndex).data), u }, "x-axis": function (t, e) { return u(t, e, { intersect: !1 }) }, point: function (t, e) { return r(t, a(e, t)) }, nearest: function (t, e, i) { var n = a(e, t); i.axis = i.axis || "xy"; var o = l(i.axis), r = s(t, n, i.intersect, o); return r.length > 1 && r.sort(function (t, e) { var i = t.getArea() - e.getArea(); return 0 === i && (i = t._datasetIndex - e._datasetIndex), i }), r.slice(0, 1) }, x: function (t, e, i) { var n = a(e, t), r = [], s = !1; return o(t, function (t) { t.inXRange(n.x) && r.push(t), t.inRange(n.x, n.y) && (s = !0) }), i.intersect && !s && (r = []), r }, y: function (t, e, i) { var n = a(e, t), r = [], s = !1; return o(t, function (t) { t.inYRange(n.y) && r.push(t), t.inRange(n.x, n.y) && (s = !0) }), i.intersect && !s && (r = []), r } } } }, { 45: 45 }], 29: [function (t, e, i) { "use strict"; t(25)._set("global", { responsive: !0, responsiveAnimationDuration: 0, maintainAspectRatio: !0, events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"], hover: { onHover: null, mode: "nearest", intersect: !0, animationDuration: 400 }, onClick: null, defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", showLines: !0, elements: {}, layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } } }), e.exports = function () { var t = function (t, e) { return this.construct(t, e), this }; return t.Chart = t, t } }, { 25: 25 }], 30: [function (t, e, i) { "use strict"; var n = t(45); function a(t, e) { return n.where(t, function (t) { return t.position === e }) } function o(t, e) { t.forEach(function (t, e) { return t._tmpIndex_ = e, t }), t.sort(function (t, i) { var n = e ? i : t, a = e ? t : i; return n.weight === a.weight ? n._tmpIndex_ - a._tmpIndex_ : n.weight - a.weight }), t.forEach(function (t) { delete t._tmpIndex_ }) } e.exports = { defaults: {}, addBox: function (t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e) }, removeBox: function (t, e) { var i = t.boxes ? t.boxes.indexOf(e) : -1; -1 !== i && t.boxes.splice(i, 1) }, configure: function (t, e, i) { for (var n, a = ["fullWidth", "position", "weight"], o = a.length, r = 0; r < o; ++r)n = a[r], i.hasOwnProperty(n) && (e[n] = i[n]) }, update: function (t, e, i) { if (t) { var r = t.options.layout || {}, s = n.options.toPadding(r.padding), l = s.left, u = s.right, d = s.top, c = s.bottom, h = a(t.boxes, "left"), f = a(t.boxes, "right"), g = a(t.boxes, "top"), p = a(t.boxes, "bottom"), m = a(t.boxes, "chartArea"); o(h, !0), o(f, !1), o(g, !0), o(p, !1); var v = e - l - u, b = i - d - c, x = b / 2, y = (e - v / 2) / (h.length + f.length), k = (i - x) / (g.length + p.length), M = v, w = b, S = []; n.each(h.concat(f, g, p), function (t) { var e, i = t.isHorizontal(); i ? (e = t.update(t.fullWidth ? v : M, k), w -= e.height) : (e = t.update(y, w), M -= e.width), S.push({ horizontal: i, minSize: e, box: t }) }); var C = 0, _ = 0, D = 0, I = 0; n.each(g.concat(p), function (t) { if (t.getPadding) { var e = t.getPadding(); C = Math.max(C, e.left), _ = Math.max(_, e.right) } }), n.each(h.concat(f), function (t) { if (t.getPadding) { var e = t.getPadding(); D = Math.max(D, e.top), I = Math.max(I, e.bottom) } }); var P = l, A = u, T = d, F = c; n.each(h.concat(f), N), n.each(h, function (t) { P += t.width }), n.each(f, function (t) { A += t.width }), n.each(g.concat(p), N), n.each(g, function (t) { T += t.height }), n.each(p, function (t) { F += t.height }), n.each(h.concat(f), function (t) { var e = n.findNextWhere(S, function (e) { return e.box === t }), i = { left: 0, right: 0, top: T, bottom: F }; e && t.update(e.minSize.width, w, i) }), P = l, A = u, T = d, F = c, n.each(h, function (t) { P += t.width }), n.each(f, function (t) { A += t.width }), n.each(g, function (t) { T += t.height }), n.each(p, function (t) { F += t.height }); var O = Math.max(C - P, 0); P += O, A += Math.max(_ - A, 0); var R = Math.max(D - T, 0); T += R, F += Math.max(I - F, 0); var L = i - T - F, z = e - P - A; z === M && L === w || (n.each(h, function (t) { t.height = L }), n.each(f, function (t) { t.height = L }), n.each(g, function (t) { t.fullWidth || (t.width = z) }), n.each(p, function (t) { t.fullWidth || (t.width = z) }), w = L, M = z); var B = l + O, W = d + R; n.each(h.concat(g), V), B += M, W += w, n.each(f, V), n.each(p, V), t.chartArea = { left: P, top: T, right: P + M, bottom: T + w }, n.each(m, function (e) { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(M, w) }) } function N(t) { var e = n.findNextWhere(S, function (e) { return e.box === t }); if (e) if (t.isHorizontal()) { var i = { left: Math.max(P, C), right: Math.max(A, _), top: 0, bottom: 0 }; t.update(t.fullWidth ? v : M, b / 2, i) } else t.update(e.minSize.width, w) } function V(t) { t.isHorizontal() ? (t.left = t.fullWidth ? l : P, t.right = t.fullWidth ? e - u : P + M, t.top = W, t.bottom = W + t.height, W = t.bottom) : (t.left = B, t.right = B + t.width, t.top = T, t.bottom = T + w, B = t.right) } } } }, { 45: 45 }], 31: [function (t, e, i) { "use strict"; var n = t(25), a = t(45); n._set("global", { plugins: {} }), e.exports = { _plugins: [], _cacheId: 0, register: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { -1 === e.indexOf(t) && e.push(t) }), this._cacheId++ }, unregister: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { var i = e.indexOf(t); -1 !== i && e.splice(i, 1) }), this._cacheId++ }, clear: function () { this._plugins = [], this._cacheId++ }, count: function () { return this._plugins.length }, getAll: function () { return this._plugins }, notify: function (t, e, i) { var n, a, o, r, s, l = this.descriptors(t), u = l.length; for (n = 0; n < u; ++n)if ("function" == typeof (s = (o = (a = l[n]).plugin)[e]) && ((r = [t].concat(i || [])).push(a.options), !1 === s.apply(o, r))) return !1; return !0 }, descriptors: function (t) { var e = t.$plugins || (t.$plugins = {}); if (e.id === this._cacheId) return e.descriptors; var i = [], o = [], r = t && t.config || {}, s = r.options && r.options.plugins || {}; return this._plugins.concat(r.plugins || []).forEach(function (t) { if (-1 === i.indexOf(t)) { var e = t.id, r = s[e]; !1 !== r && (!0 === r && (r = a.clone(n.global.plugins[e])), i.push(t), o.push({ plugin: t, options: r || {} })) } }), e.descriptors = o, e.id = this._cacheId, o }, _invalidate: function (t) { delete t.$plugins } } }, { 25: 25, 45: 45 }], 32: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = t(34); function s(t) { var e, i, n = []; for (e = 0, i = t.length; e < i; ++e)n.push(t[e].label); return n } function l(t, e, i) { var n = t.getPixelForTick(e); return i && (n -= 0 === e ? (t.getPixelForTick(1) - n) / 2 : (n - t.getPixelForTick(e - 1)) / 2), n } n._set("scale", { display: !0, position: "left", offset: !1, gridLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: !1, borderDash: [], borderDashOffset: 0 }, scaleLabel: { display: !1, labelString: "", lineHeight: 1.2, padding: { top: 4, bottom: 4 } }, ticks: { beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: r.formatters.values, minor: {}, major: {} } }), e.exports = function (t) { function e(t, e, i) { return o.isArray(e) ? o.longestText(t, i, e) : t.measureText(e).width } function i(t) { var e = o.valueOrDefault, i = n.global, a = e(t.fontSize, i.defaultFontSize), r = e(t.fontStyle, i.defaultFontStyle), s = e(t.fontFamily, i.defaultFontFamily); return { size: a, style: r, family: s, font: o.fontString(a, r, s) } } function r(t) { return o.options.toLineHeight(o.valueOrDefault(t.lineHeight, 1.2), o.valueOrDefault(t.fontSize, n.global.defaultFontSize)) } t.Scale = a.extend({ getPadding: function () { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } }, getTicks: function () { return this._ticks }, mergeTicksOptions: function () { var t = this.options.ticks; for (var e in !1 === t.minor && (t.minor = { display: !1 }), !1 === t.major && (t.major = { display: !1 }), t) "major" !== e && "minor" !== e && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e])) }, beforeUpdate: function () { o.callback(this.options.beforeUpdate, [this]) }, update: function (t, e, i) { var n, a, r, s, l, u, d = this; for (d.beforeUpdate(), d.maxWidth = t, d.maxHeight = e, d.margins = o.extend({ left: 0, right: 0, top: 0, bottom: 0 }, i), d.longestTextCache = d.longestTextCache || {}, d.beforeSetDimensions(), d.setDimensions(), d.afterSetDimensions(), d.beforeDataLimits(), d.determineDataLimits(), d.afterDataLimits(), d.beforeBuildTicks(), l = d.buildTicks() || [], d.afterBuildTicks(), d.beforeTickToLabelConversion(), r = d.convertTicksToLabels(l) || d.ticks, d.afterTickToLabelConversion(), d.ticks = r, n = 0, a = r.length; n < a; ++n)s = r[n], (u = l[n]) ? u.label = s : l.push(u = { label: s, major: !1 }); return d._ticks = l, d.beforeCalculateTickRotation(), d.calculateTickRotation(), d.afterCalculateTickRotation(), d.beforeFit(), d.fit(), d.afterFit(), d.afterUpdate(), d.minSize }, afterUpdate: function () { o.callback(this.options.afterUpdate, [this]) }, beforeSetDimensions: function () { o.callback(this.options.beforeSetDimensions, [this]) }, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0 }, afterSetDimensions: function () { o.callback(this.options.afterSetDimensions, [this]) }, beforeDataLimits: function () { o.callback(this.options.beforeDataLimits, [this]) }, determineDataLimits: o.noop, afterDataLimits: function () { o.callback(this.options.afterDataLimits, [this]) }, beforeBuildTicks: function () { o.callback(this.options.beforeBuildTicks, [this]) }, buildTicks: o.noop, afterBuildTicks: function () { o.callback(this.options.afterBuildTicks, [this]) }, beforeTickToLabelConversion: function () { o.callback(this.options.beforeTickToLabelConversion, [this]) }, convertTicksToLabels: function () { var t = this.options.ticks; this.ticks = this.ticks.map(t.userCallback || t.callback, this) }, afterTickToLabelConversion: function () { o.callback(this.options.afterTickToLabelConversion, [this]) }, beforeCalculateTickRotation: function () { o.callback(this.options.beforeCalculateTickRotation, [this]) }, calculateTickRotation: function () { var t = this, e = t.ctx, n = t.options.ticks, a = s(t._ticks), r = i(n); e.font = r.font; var l = n.minRotation || 0; if (a.length && t.options.display && t.isHorizontal()) for (var u, d = o.longestText(e, r.font, a, t.longestTextCache), c = d, h = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; c > h && l < n.maxRotation;) { var f = o.toRadians(l); if (u = Math.cos(f), Math.sin(f) * d > t.maxHeight) { l--; break } l++, c = u * d } t.labelRotation = l }, afterCalculateTickRotation: function () { o.callback(this.options.afterCalculateTickRotation, [this]) }, beforeFit: function () { o.callback(this.options.beforeFit, [this]) }, fit: function () { var t = this, n = t.minSize = { width: 0, height: 0 }, a = s(t._ticks), l = t.options, u = l.ticks, d = l.scaleLabel, c = l.gridLines, h = l.display, f = t.isHorizontal(), g = i(u), p = l.gridLines.tickMarkLength; if (n.width = f ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : h && c.drawTicks ? p : 0, n.height = f ? h && c.drawTicks ? p : 0 : t.maxHeight, d.display && h) { var m = r(d) + o.options.toPadding(d.padding).height; f ? n.height += m : n.width += m } if (u.display && h) { var v = o.longestText(t.ctx, g.font, a, t.longestTextCache), b = o.numberOfLabelLines(a), x = .5 * g.size, y = t.options.ticks.padding; if (f) { t.longestLabelWidth = v; var k = o.toRadians(t.labelRotation), M = Math.cos(k), w = Math.sin(k) * v + g.size * b + x * (b - 1) + x; n.height = Math.min(t.maxHeight, n.height + w + y), t.ctx.font = g.font; var S = e(t.ctx, a[0], g.font), C = e(t.ctx, a[a.length - 1], g.font); 0 !== t.labelRotation ? (t.paddingLeft = "bottom" === l.position ? M * S + 3 : M * x + 3, t.paddingRight = "bottom" === l.position ? M * x + 3 : M * C + 3) : (t.paddingLeft = S / 2 + 3, t.paddingRight = C / 2 + 3) } else u.mirror ? v = 0 : v += y + x, n.width = Math.min(t.maxWidth, n.width + v), t.paddingTop = g.size / 2, t.paddingBottom = g.size / 2 } t.handleMargins(), t.width = n.width, t.height = n.height }, handleMargins: function () { var t = this; t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)) }, afterFit: function () { o.callback(this.options.afterFit, [this]) }, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, isFullWidth: function () { return this.options.fullWidth }, getRightValue: function (t) { if (o.isNullOrUndef(t)) return NaN; if ("number" == typeof t && !isFinite(t)) return NaN; if (t) if (this.isHorizontal()) { if (void 0 !== t.x) return this.getRightValue(t.x) } else if (void 0 !== t.y) return this.getRightValue(t.y); return t }, getLabelForIndex: o.noop, getPixelForValue: o.noop, getValueForPixel: o.noop, getPixelForTick: function (t) { var e = this, i = e.options.offset; if (e.isHorizontal()) { var n = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (i ? 0 : 1), 1), a = n * t + e.paddingLeft; i && (a += n / 2); var o = e.left + Math.round(a); return o += e.isFullWidth() ? e.margins.left : 0 } var r = e.height - (e.paddingTop + e.paddingBottom); return e.top + t * (r / (e._ticks.length - 1)) }, getPixelForDecimal: function (t) { var e = this; if (e.isHorizontal()) { var i = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft, n = e.left + Math.round(i); return n += e.isFullWidth() ? e.margins.left : 0 } return e.top + t * e.height }, getBasePixel: function () { return this.getPixelForValue(this.getBaseValue()) }, getBaseValue: function () { var t = this.min, e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 }, _autoSkip: function (t) { var e, i, n, a, r = this, s = r.isHorizontal(), l = r.options.ticks.minor, u = t.length, d = o.toRadians(r.labelRotation), c = Math.cos(d), h = r.longestLabelWidth * c, f = []; for (l.maxTicksLimit && (a = l.maxTicksLimit), s && (e = !1, (h + l.autoSkipPadding) * u > r.width - (r.paddingLeft + r.paddingRight) && (e = 1 + Math.floor((h + l.autoSkipPadding) * u / (r.width - (r.paddingLeft + r.paddingRight)))), a && u > a && (e = Math.max(e, Math.floor(u / a)))), i = 0; i < u; i++)n = t[i], (e > 1 && i % e > 0 || i % e == 0 && i + e >= u) && i !== u - 1 && delete n.label, f.push(n); return f }, draw: function (t) { var e = this, a = e.options; if (a.display) { var s = e.ctx, u = n.global, d = a.ticks.minor, c = a.ticks.major || d, h = a.gridLines, f = a.scaleLabel, g = 0 !== e.labelRotation, p = e.isHorizontal(), m = d.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(), v = o.valueOrDefault(d.fontColor, u.defaultFontColor), b = i(d), x = o.valueOrDefault(c.fontColor, u.defaultFontColor), y = i(c), k = h.drawTicks ? h.tickMarkLength : 0, M = o.valueOrDefault(f.fontColor, u.defaultFontColor), w = i(f), S = o.options.toPadding(f.padding), C = o.toRadians(e.labelRotation), _ = [], D = e.options.gridLines.lineWidth, I = "right" === a.position ? e.right : e.right - D - k, P = "right" === a.position ? e.right + k : e.right, A = "bottom" === a.position ? e.top + D : e.bottom - k - D, T = "bottom" === a.position ? e.top + D + k : e.bottom + D; if (o.each(m, function (i, n) { if (!o.isNullOrUndef(i.label)) { var r, s, c, f, v, b, x, y, M, w, S, F, O, R, L = i.label; n === e.zeroLineIndex && a.offset === h.offsetGridLines ? (r = h.zeroLineWidth, s = h.zeroLineColor, c = h.zeroLineBorderDash, f = h.zeroLineBorderDashOffset) : (r = o.valueAtIndexOrDefault(h.lineWidth, n), s = o.valueAtIndexOrDefault(h.color, n), c = o.valueOrDefault(h.borderDash, u.borderDash), f = o.valueOrDefault(h.borderDashOffset, u.borderDashOffset)); var z = "middle", B = "middle", W = d.padding; if (p) { var N = k + W; "bottom" === a.position ? (B = g ? "middle" : "top", z = g ? "right" : "center", R = e.top + N) : (B = g ? "middle" : "bottom", z = g ? "left" : "center", R = e.bottom - N); var V = l(e, n, h.offsetGridLines && m.length > 1); V < e.left && (s = "rgba(0,0,0,0)"), V += o.aliasPixel(r), O = e.getPixelForTick(n) + d.labelOffset, v = x = M = S = V, b = A, y = T, w = t.top, F = t.bottom + D } else { var E, H = "left" === a.position; d.mirror ? (z = H ? "left" : "right", E = W) : (z = H ? "right" : "left", E = k + W), O = H ? e.right - E : e.left + E; var j = l(e, n, h.offsetGridLines && m.length > 1); j < e.top && (s = "rgba(0,0,0,0)"), j += o.aliasPixel(r), R = e.getPixelForTick(n) + d.labelOffset, v = I, x = P, M = t.left, S = t.right + D, b = y = w = F = j } _.push({ tx1: v, ty1: b, tx2: x, ty2: y, x1: M, y1: w, x2: S, y2: F, labelX: O, labelY: R, glWidth: r, glColor: s, glBorderDash: c, glBorderDashOffset: f, rotation: -1 * C, label: L, major: i.major, textBaseline: B, textAlign: z }) } }), o.each(_, function (t) { if (h.display && (s.save(), s.lineWidth = t.glWidth, s.strokeStyle = t.glColor, s.setLineDash && (s.setLineDash(t.glBorderDash), s.lineDashOffset = t.glBorderDashOffset), s.beginPath(), h.drawTicks && (s.moveTo(t.tx1, t.ty1), s.lineTo(t.tx2, t.ty2)), h.drawOnChartArea && (s.moveTo(t.x1, t.y1), s.lineTo(t.x2, t.y2)), s.stroke(), s.restore()), d.display) { s.save(), s.translate(t.labelX, t.labelY), s.rotate(t.rotation), s.font = t.major ? y.font : b.font, s.fillStyle = t.major ? x : v, s.textBaseline = t.textBaseline, s.textAlign = t.textAlign; var i = t.label; if (o.isArray(i)) for (var n = i.length, a = 1.5 * b.size, r = e.isHorizontal() ? 0 : -a * (n - 1) / 2, l = 0; l < n; ++l)s.fillText("" + i[l], 0, r), r += a; else s.fillText(i, 0, 0); s.restore() } }), f.display) { var F, O, R = 0, L = r(f) / 2; if (p) F = e.left + (e.right - e.left) / 2, O = "bottom" === a.position ? e.bottom - L - S.bottom : e.top + L + S.top; else { var z = "left" === a.position; F = z ? e.left + L + S.top : e.right - L - S.top, O = e.top + (e.bottom - e.top) / 2, R = z ? -.5 * Math.PI : .5 * Math.PI } s.save(), s.translate(F, O), s.rotate(R), s.textAlign = "center", s.textBaseline = "middle", s.fillStyle = M, s.font = w.font, s.fillText(f.labelString, 0, 0), s.restore() } if (h.drawBorder) { s.lineWidth = o.valueAtIndexOrDefault(h.lineWidth, 0), s.strokeStyle = o.valueAtIndexOrDefault(h.color, 0); var B = e.left, W = e.right + D, N = e.top, V = e.bottom + D, E = o.aliasPixel(s.lineWidth); p ? (N = V = "top" === a.position ? e.bottom : e.top, N += E, V += E) : (B = W = "left" === a.position ? e.right : e.left, B += E, W += E), s.beginPath(), s.moveTo(B, N), s.lineTo(W, V), s.stroke() } } } }) } }, { 25: 25, 26: 26, 34: 34, 45: 45 }], 33: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(30); e.exports = function (t) { t.scaleService = { constructors: {}, defaults: {}, registerScaleType: function (t, e, i) { this.constructors[t] = e, this.defaults[t] = a.clone(i) }, getScaleConstructor: function (t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0 }, getScaleDefaults: function (t) { return this.defaults.hasOwnProperty(t) ? a.merge({}, [n.scale, this.defaults[t]]) : {} }, updateScaleDefaults: function (t, e) { this.defaults.hasOwnProperty(t) && (this.defaults[t] = a.extend(this.defaults[t], e)) }, addScalesToLayout: function (t) { a.each(t.scales, function (e) { e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, o.addBox(t, e) }) } } } }, { 25: 25, 30: 30, 45: 45 }], 34: [function (t, e, i) { "use strict"; var n = t(45); e.exports = { formatters: { values: function (t) { return n.isArray(t) ? t : "" + t }, linear: function (t, e, i) { var a = i.length > 3 ? i[2] - i[1] : i[1] - i[0]; Math.abs(a) > 1 && t !== Math.floor(t) && (a = t - Math.floor(t)); var o = n.log10(Math.abs(a)), r = ""; if (0 !== t) { var s = -1 * Math.floor(o); s = Math.max(Math.min(s, 20), 0), r = t.toFixed(s) } else r = "0"; return r }, logarithmic: function (t, e, i) { var a = t / Math.pow(10, Math.floor(n.log10(t))); return 0 === t ? "0" : 1 === a || 2 === a || 5 === a || 0 === e || e === i.length - 1 ? t.toExponential() : "" } } } }, { 45: 45 }], 35: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { tooltips: { enabled: !0, custom: null, mode: "nearest", position: "average", intersect: !0, backgroundColor: "rgba(0,0,0,0.8)", titleFontStyle: "bold", titleSpacing: 2, titleMarginBottom: 6, titleFontColor: "#fff", titleAlign: "left", bodySpacing: 2, bodyFontColor: "#fff", bodyAlign: "left", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor: "#fff", footerAlign: "left", yPadding: 6, xPadding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, multiKeyBackground: "#fff", displayColors: !0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, callbacks: { beforeTitle: o.noop, title: function (t, e) { var i = "", n = e.labels, a = n ? n.length : 0; if (t.length > 0) { var o = t[0]; o.xLabel ? i = o.xLabel : a > 0 && o.index < a && (i = n[o.index]) } return i }, afterTitle: o.noop, beforeBody: o.noop, beforeLabel: o.noop, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || ""; return i && (i += ": "), i += t.yLabel }, labelColor: function (t, e) { var i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: i.borderColor, backgroundColor: i.backgroundColor } }, labelTextColor: function () { return this._options.bodyFontColor }, afterLabel: o.noop, afterBody: o.noop, beforeFooter: o.noop, footer: o.noop, afterFooter: o.noop } } }), e.exports = function (t) { function e(t, e) { var i = o.color(t); return i.alpha(e * i.alpha()).rgbaString() } function i(t, e) { return e && (o.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function r(t) { var e = n.global, i = o.valueOrDefault; return { xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, bodyFontColor: t.bodyFontColor, _bodyFontFamily: i(t.bodyFontFamily, e.defaultFontFamily), _bodyFontStyle: i(t.bodyFontStyle, e.defaultFontStyle), _bodyAlign: t.bodyAlign, bodyFontSize: i(t.bodyFontSize, e.defaultFontSize), bodySpacing: t.bodySpacing, titleFontColor: t.titleFontColor, _titleFontFamily: i(t.titleFontFamily, e.defaultFontFamily), _titleFontStyle: i(t.titleFontStyle, e.defaultFontStyle), titleFontSize: i(t.titleFontSize, e.defaultFontSize), _titleAlign: t.titleAlign, titleSpacing: t.titleSpacing, titleMarginBottom: t.titleMarginBottom, footerFontColor: t.footerFontColor, _footerFontFamily: i(t.footerFontFamily, e.defaultFontFamily), _footerFontStyle: i(t.footerFontStyle, e.defaultFontStyle), footerFontSize: i(t.footerFontSize, e.defaultFontSize), _footerAlign: t.footerAlign, footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, cornerRadius: t.cornerRadius, backgroundColor: t.backgroundColor, opacity: 0, legendColorBackground: t.multiKeyBackground, displayColors: t.displayColors, borderColor: t.borderColor, borderWidth: t.borderWidth } } t.Tooltip = a.extend({ initialize: function () { this._model = r(this._options), this._lastActive = [] }, getTitle: function () { var t = this._options.callbacks, e = t.beforeTitle.apply(this, arguments), n = t.title.apply(this, arguments), a = t.afterTitle.apply(this, arguments), o = []; return o = i(o = i(o = i(o, e), n), a) }, getBeforeBody: function () { var t = this._options.callbacks.beforeBody.apply(this, arguments); return o.isArray(t) ? t : void 0 !== t ? [t] : [] }, getBody: function (t, e) { var n = this, a = n._options.callbacks, r = []; return o.each(t, function (t) { var o = { before: [], lines: [], after: [] }; i(o.before, a.beforeLabel.call(n, t, e)), i(o.lines, a.label.call(n, t, e)), i(o.after, a.afterLabel.call(n, t, e)), r.push(o) }), r }, getAfterBody: function () { var t = this._options.callbacks.afterBody.apply(this, arguments); return o.isArray(t) ? t : void 0 !== t ? [t] : [] }, getFooter: function () { var t = this._options.callbacks, e = t.beforeFooter.apply(this, arguments), n = t.footer.apply(this, arguments), a = t.afterFooter.apply(this, arguments), o = []; return o = i(o = i(o = i(o, e), n), a) }, update: function (e) { var i, n, a, s, l, u, d, c, h, f, g, p, m, v, b, x, y, k, M, w, S = this, C = S._options, _ = S._model, D = S._model = r(C), I = S._active, P = S._data, A = { xAlign: _.xAlign, yAlign: _.yAlign }, T = { x: _.x, y: _.y }, F = { width: _.width, height: _.height }, O = { x: _.caretX, y: _.caretY }; if (I.length) { D.opacity = 1; var R = [], L = []; O = t.Tooltip.positioners[C.position].call(S, I, S._eventPosition); var z = []; for (i = 0, n = I.length; i < n; ++i)z.push((x = I[i], y = void 0, k = void 0, void 0, void 0, y = x._xScale, k = x._yScale || x._scale, M = x._index, w = x._datasetIndex, { xLabel: y ? y.getLabelForIndex(M, w) : "", yLabel: k ? k.getLabelForIndex(M, w) : "", index: M, datasetIndex: w, x: x._model.x, y: x._model.y })); C.filter && (z = z.filter(function (t) { return C.filter(t, P) })), C.itemSort && (z = z.sort(function (t, e) { return C.itemSort(t, e, P) })), o.each(z, function (t) { R.push(C.callbacks.labelColor.call(S, t, S._chart)), L.push(C.callbacks.labelTextColor.call(S, t, S._chart)) }), D.title = S.getTitle(z, P), D.beforeBody = S.getBeforeBody(z, P), D.body = S.getBody(z, P), D.afterBody = S.getAfterBody(z, P), D.footer = S.getFooter(z, P), D.x = Math.round(O.x), D.y = Math.round(O.y), D.caretPadding = C.caretPadding, D.labelColors = R, D.labelTextColors = L, D.dataPoints = z, A = function (t, e) { var i, n, a, o, r, s = t._model, l = t._chart, u = t._chart.chartArea, d = "center", c = "center"; s.y < e.height ? c = "top" : s.y > l.height - e.height && (c = "bottom"); var h = (u.left + u.right) / 2, f = (u.top + u.bottom) / 2; "center" === c ? (i = function (t) { return t <= h }, n = function (t) { return t > h }) : (i = function (t) { return t <= e.width / 2 }, n = function (t) { return t >= l.width - e.width / 2 }), a = function (t) { return t + e.width + s.caretSize + s.caretPadding > l.width }, o = function (t) { return t - e.width - s.caretSize - s.caretPadding < 0 }, r = function (t) { return t <= f ? "top" : "bottom" }, i(s.x) ? (d = "left", a(s.x) && (d = "center", c = r(s.y))) : n(s.x) && (d = "right", o(s.x) && (d = "center", c = r(s.y))); var g = t._options; return { xAlign: g.xAlign ? g.xAlign : d, yAlign: g.yAlign ? g.yAlign : c } }(this, F = function (t, e) { var i = t._chart.ctx, n = 2 * e.yPadding, a = 0, r = e.body, s = r.reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length }, 0); s += e.beforeBody.length + e.afterBody.length; var l = e.title.length, u = e.footer.length, d = e.titleFontSize, c = e.bodyFontSize, h = e.footerFontSize; n += l * d, n += l ? (l - 1) * e.titleSpacing : 0, n += l ? e.titleMarginBottom : 0, n += s * c, n += s ? (s - 1) * e.bodySpacing : 0, n += u ? e.footerMarginTop : 0, n += u * h, n += u ? (u - 1) * e.footerSpacing : 0; var f = 0, g = function (t) { a = Math.max(a, i.measureText(t).width + f) }; return i.font = o.fontString(d, e._titleFontStyle, e._titleFontFamily), o.each(e.title, g), i.font = o.fontString(c, e._bodyFontStyle, e._bodyFontFamily), o.each(e.beforeBody.concat(e.afterBody), g), f = e.displayColors ? c + 2 : 0, o.each(r, function (t) { o.each(t.before, g), o.each(t.lines, g), o.each(t.after, g) }), f = 0, i.font = o.fontString(h, e._footerFontStyle, e._footerFontFamily), o.each(e.footer, g), { width: a += 2 * e.xPadding, height: n } }(this, D)), a = D, s = F, l = A, u = S._chart, d = a.x, c = a.y, h = a.caretSize, f = a.caretPadding, g = a.cornerRadius, p = l.xAlign, m = l.yAlign, v = h + f, b = g + f, "right" === p ? d -= s.width : "center" === p && ((d -= s.width / 2) + s.width > u.width && (d = u.width - s.width), d < 0 && (d = 0)), "top" === m ? c += v : c -= "bottom" === m ? s.height + v : s.height / 2, "center" === m ? "left" === p ? d += v : "right" === p && (d -= v) : "left" === p ? d -= b : "right" === p && (d += b), T = { x: d, y: c } } else D.opacity = 0; return D.xAlign = A.xAlign, D.yAlign = A.yAlign, D.x = T.x, D.y = T.y, D.width = F.width, D.height = F.height, D.caretX = O.x, D.caretY = O.y, S._model = D, e && C.custom && C.custom.call(S, D), S }, drawCaret: function (t, e) { var i = this._chart.ctx, n = this._view, a = this.getCaretPosition(t, e, n); i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3) }, getCaretPosition: function (t, e, i) { var n, a, o, r, s, l, u = i.caretSize, d = i.cornerRadius, c = i.xAlign, h = i.yAlign, f = t.x, g = t.y, p = e.width, m = e.height; if ("center" === h) s = g + m / 2, "left" === c ? (a = (n = f) - u, o = n, r = s + u, l = s - u) : (a = (n = f + p) + u, o = n, r = s - u, l = s + u); else if ("left" === c ? (n = (a = f + d + u) - u, o = a + u) : "right" === c ? (n = (a = f + p - d - u) - u, o = a + u) : (n = (a = i.caretX) - u, o = a + u), "top" === h) s = (r = g) - u, l = r; else { s = (r = g + m) + u, l = r; var v = o; o = n, n = v } return { x1: n, x2: a, x3: o, y1: r, y2: s, y3: l } }, drawTitle: function (t, i, n, a) { var r = i.title; if (r.length) { n.textAlign = i._titleAlign, n.textBaseline = "top"; var s, l, u = i.titleFontSize, d = i.titleSpacing; for (n.fillStyle = e(i.titleFontColor, a), n.font = o.fontString(u, i._titleFontStyle, i._titleFontFamily), s = 0, l = r.length; s < l; ++s)n.fillText(r[s], t.x, t.y), t.y += u + d, s + 1 === r.length && (t.y += i.titleMarginBottom - d) } }, drawBody: function (t, i, n, a) { var r = i.bodyFontSize, s = i.bodySpacing, l = i.body; n.textAlign = i._bodyAlign, n.textBaseline = "top", n.font = o.fontString(r, i._bodyFontStyle, i._bodyFontFamily); var u = 0, d = function (e) { n.fillText(e, t.x + u, t.y), t.y += r + s }; n.fillStyle = e(i.bodyFontColor, a), o.each(i.beforeBody, d); var c = i.displayColors; u = c ? r + 2 : 0, o.each(l, function (s, l) { var u = e(i.labelTextColors[l], a); n.fillStyle = u, o.each(s.before, d), o.each(s.lines, function (o) { c && (n.fillStyle = e(i.legendColorBackground, a), n.fillRect(t.x, t.y, r, r), n.lineWidth = 1, n.strokeStyle = e(i.labelColors[l].borderColor, a), n.strokeRect(t.x, t.y, r, r), n.fillStyle = e(i.labelColors[l].backgroundColor, a), n.fillRect(t.x + 1, t.y + 1, r - 2, r - 2), n.fillStyle = u), d(o) }), o.each(s.after, d) }), u = 0, o.each(i.afterBody, d), t.y -= s }, drawFooter: function (t, i, n, a) { var r = i.footer; r.length && (t.y += i.footerMarginTop, n.textAlign = i._footerAlign, n.textBaseline = "top", n.fillStyle = e(i.footerFontColor, a), n.font = o.fontString(i.footerFontSize, i._footerFontStyle, i._footerFontFamily), o.each(r, function (e) { n.fillText(e, t.x, t.y), t.y += i.footerFontSize + i.footerSpacing })) }, drawBackground: function (t, i, n, a, o) { n.fillStyle = e(i.backgroundColor, o), n.strokeStyle = e(i.borderColor, o), n.lineWidth = i.borderWidth; var r = i.xAlign, s = i.yAlign, l = t.x, u = t.y, d = a.width, c = a.height, h = i.cornerRadius; n.beginPath(), n.moveTo(l + h, u), "top" === s && this.drawCaret(t, a), n.lineTo(l + d - h, u), n.quadraticCurveTo(l + d, u, l + d, u + h), "center" === s && "right" === r && this.drawCaret(t, a), n.lineTo(l + d, u + c - h), n.quadraticCurveTo(l + d, u + c, l + d - h, u + c), "bottom" === s && this.drawCaret(t, a), n.lineTo(l + h, u + c), n.quadraticCurveTo(l, u + c, l, u + c - h), "center" === s && "left" === r && this.drawCaret(t, a), n.lineTo(l, u + h), n.quadraticCurveTo(l, u, l + h, u), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke() }, draw: function () { var t = this._chart.ctx, e = this._view; if (0 !== e.opacity) { var i = { width: e.width, height: e.height }, n = { x: e.x, y: e.y }, a = Math.abs(e.opacity < .001) ? 0 : e.opacity, o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; this._options.enabled && o && (this.drawBackground(n, e, t, i, a), n.x += e.xPadding, n.y += e.yPadding, this.drawTitle(n, e, t, a), this.drawBody(n, e, t, a), this.drawFooter(n, e, t, a)) } }, handleEvent: function (t) { var e, i = this, n = i._options; return i._lastActive = i._lastActive || [], "mouseout" === t.type ? i._active = [] : i._active = i._chart.getElementsAtEventForMode(t, n.mode, n), (e = !o.arrayEquals(i._active, i._lastActive)) && (i._lastActive = i._active, (n.enabled || n.custom) && (i._eventPosition = { x: t.x, y: t.y }, i.update(!0), i.pivot())), e } }), t.Tooltip.positioners = { average: function (t) { if (!t.length) return !1; var e, i, n = 0, a = 0, o = 0; for (e = 0, i = t.length; e < i; ++e) { var r = t[e]; if (r && r.hasValue()) { var s = r.tooltipPosition(); n += s.x, a += s.y, ++o } } return { x: Math.round(n / o), y: Math.round(a / o) } }, nearest: function (t, e) { var i, n, a, r = e.x, s = e.y, l = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { var u = t[i]; if (u && u.hasValue()) { var d = u.getCenterPoint(), c = o.distanceBetweenPoints(e, d); c < l && (l = c, a = u) } } if (a) { var h = a.tooltipPosition(); r = h.x, s = h.y } return { x: r, y: s } } } } }, { 25: 25, 26: 26, 45: 45 }], 36: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { elements: { arc: { backgroundColor: n.global.defaultColor, borderColor: "#fff", borderWidth: 2 } } }), e.exports = a.extend({ inLabelRange: function (t) { var e = this._view; return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2) }, inRange: function (t, e) { var i = this._view; if (i) { for (var n = o.getAngleFromPoint(i, { x: t, y: e }), a = n.angle, r = n.distance, s = i.startAngle, l = i.endAngle; l < s;)l += 2 * Math.PI; for (; a > l;)a -= 2 * Math.PI; for (; a < s;)a += 2 * Math.PI; var u = a >= s && a <= l, d = r >= i.innerRadius && r <= i.outerRadius; return u && d } return !1 }, getCenterPoint: function () { var t = this._view, e = (t.startAngle + t.endAngle) / 2, i = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i } }, getArea: function () { var t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2)) }, tooltipPosition: function () { var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i } }, draw: function () { var t = this._chart.ctx, e = this._view, i = e.startAngle, n = e.endAngle; t.beginPath(), t.arc(e.x, e.y, e.outerRadius, i, n), t.arc(e.x, e.y, e.innerRadius, n, i, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = "bevel", e.borderWidth && t.stroke() } }) }, { 25: 25, 26: 26, 45: 45 }], 37: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = n.global; n._set("global", { elements: { line: { tension: .4, backgroundColor: r.defaultColor, borderWidth: 3, borderColor: r.defaultColor, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0 } } }), e.exports = a.extend({ draw: function () { var t, e, i, n, a = this._view, s = this._chart.ctx, l = a.spanGaps, u = this._children.slice(), d = r.elements.line, c = -1; for (this._loop && u.length && u.push(u[0]), s.save(), s.lineCap = a.borderCapStyle || d.borderCapStyle, s.setLineDash && s.setLineDash(a.borderDash || d.borderDash), s.lineDashOffset = a.borderDashOffset || d.borderDashOffset, s.lineJoin = a.borderJoinStyle || d.borderJoinStyle, s.lineWidth = a.borderWidth || d.borderWidth, s.strokeStyle = a.borderColor || r.defaultColor, s.beginPath(), c = -1, t = 0; t < u.length; ++t)e = u[t], i = o.previousItem(u, t), n = e._view, 0 === t ? n.skip || (s.moveTo(n.x, n.y), c = t) : (i = -1 === c ? i : u[c], n.skip || (c !== t - 1 && !l || -1 === c ? s.moveTo(n.x, n.y) : o.canvas.lineTo(s, i._view, e._view), c = t)); s.stroke(), s.restore() } }) }, { 25: 25, 26: 26, 45: 45 }], 38: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = n.global.defaultColor; function s(t) { var e = this._view; return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius } n._set("global", { elements: { point: { radius: 3, pointStyle: "circle", backgroundColor: r, borderColor: r, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 } } }), e.exports = a.extend({ inRange: function (t, e) { var i = this._view; return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2) }, inLabelRange: s, inXRange: s, inYRange: function (t) { var e = this._view; return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius }, getCenterPoint: function () { var t = this._view; return { x: t.x, y: t.y } }, getArea: function () { return Math.PI * Math.pow(this._view.radius, 2) }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth } }, draw: function (t) { var e = this._view, i = this._model, a = this._chart.ctx, s = e.pointStyle, l = e.radius, u = e.x, d = e.y, c = o.color, h = 0; e.skip || (a.strokeStyle = e.borderColor || r, a.lineWidth = o.valueOrDefault(e.borderWidth, n.global.elements.point.borderWidth), a.fillStyle = e.backgroundColor || r, void 0 !== t && (i.x < t.left || 1.01 * t.right < i.x || i.y < t.top || 1.01 * t.bottom < i.y) && (i.x < t.left ? h = (u - i.x) / (t.left - i.x) : 1.01 * t.right < i.x ? h = (i.x - u) / (i.x - t.right) : i.y < t.top ? h = (d - i.y) / (t.top - i.y) : 1.01 * t.bottom < i.y && (h = (i.y - d) / (i.y - t.bottom)), h = Math.round(100 * h) / 100, a.strokeStyle = c(a.strokeStyle).alpha(h).rgbString(), a.fillStyle = c(a.fillStyle).alpha(h).rgbString()), o.canvas.drawPoint(a, s, l, u, d)) } }) }, { 25: 25, 26: 26, 45: 45 }], 39: [function (t, e, i) { "use strict"; var n = t(25), a = t(26); function o(t) { return void 0 !== t._view.width } function r(t) { var e, i, n, a, r = t._view; if (o(t)) { var s = r.width / 2; e = r.x - s, i = r.x + s, n = Math.min(r.y, r.base), a = Math.max(r.y, r.base) } else { var l = r.height / 2; e = Math.min(r.x, r.base), i = Math.max(r.x, r.base), n = r.y - l, a = r.y + l } return { left: e, top: n, right: i, bottom: a } } n._set("global", { elements: { rectangle: { backgroundColor: n.global.defaultColor, borderColor: n.global.defaultColor, borderSkipped: "bottom", borderWidth: 0 } } }), e.exports = a.extend({ draw: function () { var t, e, i, n, a, o, r, s = this._chart.ctx, l = this._view, u = l.borderWidth; if (l.horizontal ? (t = l.base, e = l.x, i = l.y - l.height / 2, n = l.y + l.height / 2, a = e > t ? 1 : -1, o = 1, r = l.borderSkipped || "left") : (t = l.x - l.width / 2, e = l.x + l.width / 2, i = l.y, a = 1, o = (n = l.base) > i ? 1 : -1, r = l.borderSkipped || "bottom"), u) { var d = Math.min(Math.abs(t - e), Math.abs(i - n)), c = (u = u > d ? d : u) / 2, h = t + ("left" !== r ? c * a : 0), f = e + ("right" !== r ? -c * a : 0), g = i + ("top" !== r ? c * o : 0), p = n + ("bottom" !== r ? -c * o : 0); h !== f && (i = g, n = p), g !== p && (t = h, e = f) } s.beginPath(), s.fillStyle = l.backgroundColor, s.strokeStyle = l.borderColor, s.lineWidth = u; var m = [[t, n], [t, i], [e, i], [e, n]], v = ["bottom", "left", "top", "right"].indexOf(r, 0); function b(t) { return m[(v + t) % 4] } -1 === v && (v = 0); var x = b(0); s.moveTo(x[0], x[1]); for (var y = 1; y < 4; y++)x = b(y), s.lineTo(x[0], x[1]); s.fill(), u && s.stroke() }, height: function () { var t = this._view; return t.base - t.y }, inRange: function (t, e) { var i = !1; if (this._view) { var n = r(this); i = t >= n.left && t <= n.right && e >= n.top && e <= n.bottom } return i }, inLabelRange: function (t, e) { if (!this._view) return !1; var i = r(this); return o(this) ? t >= i.left && t <= i.right : e >= i.top && e <= i.bottom }, inXRange: function (t) { var e = r(this); return t >= e.left && t <= e.right }, inYRange: function (t) { var e = r(this); return t >= e.top && t <= e.bottom }, getCenterPoint: function () { var t, e, i = this._view; return o(this) ? (t = i.x, e = (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, e = i.y), { x: t, y: e } }, getArea: function () { var t = this._view; return t.width * Math.abs(t.y - t.base) }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y } } }) }, { 25: 25, 26: 26 }], 40: [function (t, e, i) { "use strict"; e.exports = {}, e.exports.Arc = t(36), e.exports.Line = t(37), e.exports.Point = t(38), e.exports.Rectangle = t(39) }, { 36: 36, 37: 37, 38: 38, 39: 39 }], 41: [function (t, e, i) { "use strict"; var n = t(42); i = e.exports = { clear: function (t) { t.ctx.clearRect(0, 0, t.width, t.height) }, roundedRect: function (t, e, i, n, a, o) { if (o) { var r = Math.min(o, n / 2), s = Math.min(o, a / 2); t.moveTo(e + r, i), t.lineTo(e + n - r, i), t.quadraticCurveTo(e + n, i, e + n, i + s), t.lineTo(e + n, i + a - s), t.quadraticCurveTo(e + n, i + a, e + n - r, i + a), t.lineTo(e + r, i + a), t.quadraticCurveTo(e, i + a, e, i + a - s), t.lineTo(e, i + s), t.quadraticCurveTo(e, i, e + r, i) } else t.rect(e, i, n, a) }, drawPoint: function (t, e, i, n, a) { var o, r, s, l, u, d; if (!e || "object" != typeof e || "[object HTMLImageElement]" !== (o = e.toString()) && "[object HTMLCanvasElement]" !== o) { if (!(isNaN(i) || i <= 0)) { switch (e) { default: t.beginPath(), t.arc(n, a, i, 0, 2 * Math.PI), t.closePath(), t.fill(); break; case "triangle": t.beginPath(), u = (r = 3 * i / Math.sqrt(3)) * Math.sqrt(3) / 2, t.moveTo(n - r / 2, a + u / 3), t.lineTo(n + r / 2, a + u / 3), t.lineTo(n, a - 2 * u / 3), t.closePath(), t.fill(); break; case "rect": d = 1 / Math.SQRT2 * i, t.beginPath(), t.fillRect(n - d, a - d, 2 * d, 2 * d), t.strokeRect(n - d, a - d, 2 * d, 2 * d); break; case "rectRounded": var c = i / Math.SQRT2, h = n - c, f = a - c, g = Math.SQRT2 * i; t.beginPath(), this.roundedRect(t, h, f, g, g, i / 2), t.closePath(), t.fill(); break; case "rectRot": d = 1 / Math.SQRT2 * i, t.beginPath(), t.moveTo(n - d, a), t.lineTo(n, a + d), t.lineTo(n + d, a), t.lineTo(n, a - d), t.closePath(), t.fill(); break; case "cross": t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath(); break; case "crossRot": t.beginPath(), s = Math.cos(Math.PI / 4) * i, l = Math.sin(Math.PI / 4) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n - s, a + l), t.lineTo(n + s, a - l), t.closePath(); break; case "star": t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), s = Math.cos(Math.PI / 4) * i, l = Math.sin(Math.PI / 4) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n - s, a + l), t.lineTo(n + s, a - l), t.closePath(); break; case "line": t.beginPath(), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath(); break; case "dash": t.beginPath(), t.moveTo(n, a), t.lineTo(n + i, a), t.closePath() }t.stroke() } } else t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height) }, clipArea: function (t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() }, unclipArea: function (t) { t.restore() }, lineTo: function (t, e, i, n) { if (i.steppedLine) return "after" === i.steppedLine && !n || "after" !== i.steppedLine && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y), void t.lineTo(i.x, i.y); i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y) } }; n.clear = i.clear, n.drawRoundedRectangle = function (t) { t.beginPath(), i.roundedRect.apply(i, arguments), t.closePath() } }, { 42: 42 }], 42: [function (t, e, i) { "use strict"; var n, a = { noop: function () { }, uid: (n = 0, function () { return n++ }), isNullOrUndef: function (t) { return null == t }, isArray: Array.isArray ? Array.isArray : function (t) { return "[object Array]" === Object.prototype.toString.call(t) }, isObject: function (t) { return null !== t && "[object Object]" === Object.prototype.toString.call(t) }, valueOrDefault: function (t, e) { return void 0 === t ? e : t }, valueAtIndexOrDefault: function (t, e, i) { return a.valueOrDefault(a.isArray(t) ? t[e] : t, i) }, callback: function (t, e, i) { if (t && "function" == typeof t.call) return t.apply(i, e) }, each: function (t, e, i, n) { var o, r, s; if (a.isArray(t)) if (r = t.length, n) for (o = r - 1; o >= 0; o--)e.call(i, t[o], o); else for (o = 0; o < r; o++)e.call(i, t[o], o); else if (a.isObject(t)) for (r = (s = Object.keys(t)).length, o = 0; o < r; o++)e.call(i, t[s[o]], s[o]) }, arrayEquals: function (t, e) { var i, n, o, r; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i)if (o = t[i], r = e[i], o instanceof Array && r instanceof Array) { if (!a.arrayEquals(o, r)) return !1 } else if (o !== r) return !1; return !0 }, clone: function (t) { if (a.isArray(t)) return t.map(a.clone); if (a.isObject(t)) { for (var e = {}, i = Object.keys(t), n = i.length, o = 0; o < n; ++o)e[i[o]] = a.clone(t[i[o]]); return e } return t }, _merger: function (t, e, i, n) { var o = e[t], r = i[t]; a.isObject(o) && a.isObject(r) ? a.merge(o, r, n) : e[t] = a.clone(r) }, _mergerIf: function (t, e, i) { var n = e[t], o = i[t]; a.isObject(n) && a.isObject(o) ? a.mergeIf(n, o) : e.hasOwnProperty(t) || (e[t] = a.clone(o)) }, merge: function (t, e, i) { var n, o, r, s, l, u = a.isArray(e) ? e : [e], d = u.length; if (!a.isObject(t)) return t; for (n = (i = i || {}).merger || a._merger, o = 0; o < d; ++o)if (e = u[o], a.isObject(e)) for (l = 0, s = (r = Object.keys(e)).length; l < s; ++l)n(r[l], t, e, i); return t }, mergeIf: function (t, e) { return a.merge(t, e, { merger: a._mergerIf }) }, extend: function (t) { for (var e = function (e, i) { t[i] = e }, i = 1, n = arguments.length; i < n; ++i)a.each(arguments[i], e); return t }, inherits: function (t) { var e = this, i = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments) }, n = function () { this.constructor = i }; return n.prototype = e.prototype, i.prototype = new n, i.extend = a.inherits, t && a.extend(i.prototype, t), i.__super__ = e.prototype, i } }; e.exports = a, a.callCallback = a.callback, a.indexOf = function (t, e, i) { return Array.prototype.indexOf.call(t, e, i) }, a.getValueOrDefault = a.valueOrDefault, a.getValueAtIndexOrDefault = a.valueAtIndexOrDefault }, {}], 43: [function (t, e, i) { "use strict"; var n = t(42), a = { linear: function (t) { return t }, easeInQuad: function (t) { return t * t }, easeOutQuad: function (t) { return -t * (t - 2) }, easeInOutQuad: function (t) { return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) }, easeInCubic: function (t) { return t * t * t }, easeOutCubic: function (t) { return (t -= 1) * t * t + 1 }, easeInOutCubic: function (t) { return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, easeInQuart: function (t) { return t * t * t * t }, easeOutQuart: function (t) { return -((t -= 1) * t * t * t - 1) }, easeInOutQuart: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint: function (t) { return t * t * t * t * t }, easeOutQuint: function (t) { return (t -= 1) * t * t * t * t + 1 }, easeInOutQuint: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine: function (t) { return 1 - Math.cos(t * (Math.PI / 2)) }, easeOutSine: function (t) { return Math.sin(t * (Math.PI / 2)) }, easeInOutSine: function (t) { return -.5 * (Math.cos(Math.PI * t) - 1) }, easeInExpo: function (t) { return 0 === t ? 0 : Math.pow(2, 10 * (t - 1)) }, easeOutExpo: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, easeInOutExpo: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t)) }, easeInCirc: function (t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1) }, easeOutCirc: function (t) { return Math.sqrt(1 - (t -= 1) * t) }, easeInOutCirc: function (t) { return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)) }, easeOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1) }, easeInOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = .45), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * .5 + 1) }, easeInBack: function (t) { return t * t * (2.70158 * t - 1.70158) }, easeOutBack: function (t) { return (t -= 1) * t * (2.70158 * t + 1.70158) + 1 }, easeInOutBack: function (t) { var e = 1.70158; return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce: function (t) { return 1 - a.easeOutBounce(1 - t) }, easeOutBounce: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: function (t) { return t < .5 ? .5 * a.easeInBounce(2 * t) : .5 * a.easeOutBounce(2 * t - 1) + .5 } }; e.exports = { effects: a }, n.easingEffects = a }, { 42: 42 }], 44: [function (t, e, i) { "use strict"; var n = t(42); e.exports = { toLineHeight: function (t, e) { var i = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!i || "normal" === i[1]) return 1.2 * e; switch (t = +i[2], i[3]) { case "px": return t; case "%": t /= 100 }return e * t }, toPadding: function (t) { var e, i, a, o; return n.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, a = +t.bottom || 0, o = +t.left || 0) : e = i = a = o = +t || 0, { top: e, right: i, bottom: a, left: o, height: e + a, width: o + i } }, resolve: function (t, e, i) { var a, o, r; for (a = 0, o = t.length; a < o; ++a)if (void 0 !== (r = t[a]) && (void 0 !== e && "function" == typeof r && (r = r(e)), void 0 !== i && n.isArray(r) && (r = r[i]), void 0 !== r)) return r } } }, { 42: 42 }], 45: [function (t, e, i) { "use strict"; e.exports = t(42), e.exports.easing = t(43), e.exports.canvas = t(41), e.exports.options = t(44) }, { 41: 41, 42: 42, 43: 43, 44: 44 }], 46: [function (t, e, i) { e.exports = { acquireContext: function (t) { return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null } } }, {}], 47: [function (t, e, i) { "use strict"; var n = t(45), a = "$chartjs", o = "chartjs-", r = o + "render-monitor", s = o + "render-animation", l = ["animationstart", "webkitAnimationStart"], u = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }; function d(t, e) { var i = n.getStyle(t, e), a = i && i.match(/^(\d+)(\.\d+)?px$/); return a ? Number(a[1]) : void 0 } var c = !!function () { var t = !1; try { var e = Object.defineProperty({}, "passive", { get: function () { t = !0 } }); window.addEventListener("e", null, e) } catch (t) { } return t }() && { passive: !0 }; function h(t, e, i) { t.addEventListener(e, i, c) } function f(t, e, i) { t.removeEventListener(e, i, c) } function g(t, e, i, n, a) { return { type: t, chart: e, native: a || null, x: void 0 !== i ? i : null, y: void 0 !== n ? n : null } } function p(t, e, i) { var u, d, c, f, p, m, v, b, x = t[a] || (t[a] = {}), y = x.resizer = function (t) { var e = document.createElement("div"), i = o + "size-monitor", n = "position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;"; e.style.cssText = n, e.className = i, e.innerHTML = '<div class="' + i + '-expand" style="' + n + '"><div style="position:absolute;width:1000000px;height:1000000px;left:0;top:0"></div></div><div class="' + i + '-shrink" style="' + n + '"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>'; var a = e.childNodes[0], r = e.childNodes[1]; e._reset = function () { a.scrollLeft = 1e6, a.scrollTop = 1e6, r.scrollLeft = 1e6, r.scrollTop = 1e6 }; var s = function () { e._reset(), t() }; return h(a, "scroll", s.bind(a, "expand")), h(r, "scroll", s.bind(r, "shrink")), e }((u = function () { if (x.resizer) return e(g("resize", i)) }, c = !1, f = [], function () { f = Array.prototype.slice.call(arguments), d = d || this, c || (c = !0, n.requestAnimFrame.call(window, function () { c = !1, u.apply(d, f) })) })); m = function () { if (x.resizer) { var e = t.parentNode; e && e !== y.parentNode && e.insertBefore(y, e.firstChild), y._reset() } }, v = (p = t)[a] || (p[a] = {}), b = v.renderProxy = function (t) { t.animationName === s && m() }, n.each(l, function (t) { h(p, t, b) }), v.reflow = !!p.offsetParent, p.classList.add(r) } function m(t) { var e, i, o, s = t[a] || {}, u = s.resizer; delete s.resizer, i = (e = t)[a] || {}, (o = i.renderProxy) && (n.each(l, function (t) { f(e, t, o) }), delete i.renderProxy), e.classList.remove(r), u && u.parentNode && u.parentNode.removeChild(u) } e.exports = { _enabled: "undefined" != typeof window && "undefined" != typeof document, initialize: function () { var t, e, i, n = "from{opacity:0.99}to{opacity:1}"; e = "@-webkit-keyframes " + s + "{" + n + "}@keyframes " + s + "{" + n + "}." + r + "{-webkit-animation:" + s + " 0.001s;animation:" + s + " 0.001s;}", i = (t = this)._style || document.createElement("style"), t._style || (t._style = i, e = "/* Chart.js */\n" + e, i.setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(i)), i.appendChild(document.createTextNode(e)) }, acquireContext: function (t, e) { "string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas); var i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (function (t, e) { var i = t.style, n = t.getAttribute("height"), o = t.getAttribute("width"); if (t[a] = { initial: { height: n, width: o, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || "block", null === o || "" === o) { var r = d(t, "width"); void 0 !== r && (t.width = r) } if (null === n || "" === n) if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2); else { var s = d(t, "height"); void 0 !== r && (t.height = s) } }(t, e), i) : null }, releaseContext: function (t) { var e = t.canvas; if (e[a]) { var i = e[a].initial;["height", "width"].forEach(function (t) { var a = i[t]; n.isNullOrUndef(a) ? e.removeAttribute(t) : e.setAttribute(t, a) }), n.each(i.style || {}, function (t, i) { e.style[i] = t }), e.width = e.width, delete e[a] } }, addEventListener: function (t, e, i) { var o = t.canvas; if ("resize" !== e) { var r = i[a] || (i[a] = {}); h(o, e, (r.proxies || (r.proxies = {}))[t.id + "_" + e] = function (e) { var a, o, r, s; i((o = t, r = u[(a = e).type] || a.type, s = n.getRelativePosition(a, o), g(r, o, s.x, s.y, a))) }) } else p(o, i, t) }, removeEventListener: function (t, e, i) { var n = t.canvas; if ("resize" !== e) { var o = ((i[a] || {}).proxies || {})[t.id + "_" + e]; o && f(n, e, o) } else m(n) } }, n.addEvent = h, n.removeEvent = f }, { 45: 45 }], 48: [function (t, e, i) { "use strict"; var n = t(45), a = t(46), o = t(47), r = o._enabled ? o : a; e.exports = n.extend({ initialize: function () { }, acquireContext: function () { }, releaseContext: function () { }, addEventListener: function () { }, removeEventListener: function () { } }, r) }, { 45: 45, 46: 46, 47: 47 }], 49: [function (t, e, i) { "use strict"; e.exports = {}, e.exports.filler = t(50), e.exports.legend = t(51), e.exports.title = t(52) }, { 50: 50, 51: 51, 52: 52 }], 50: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("global", { plugins: { filler: { propagate: !0 } } }); var r = { dataset: function (t) { var e = t.fill, i = t.chart, n = i.getDatasetMeta(e), a = n && i.isDatasetVisible(e) && n.dataset._children || [], o = a.length || 0; return o ? function (t, e) { return e < o && a[e]._view || null } : null }, boundary: function (t) { var e = t.boundary, i = e ? e.x : null, n = e ? e.y : null; return function (t) { return { x: null === i ? t.x : i, y: null === n ? t.y : n } } } }; function s(t, e, i) { var n, a = t._model || {}, o = a.fill; if (void 0 === o && (o = !!a.backgroundColor), !1 === o || null === o) return !1; if (!0 === o) return "origin"; if (n = parseFloat(o, 10), isFinite(n) && Math.floor(n) === n) return "-" !== o[0] && "+" !== o[0] || (n = e + n), !(n === e || n < 0 || n >= i) && n; switch (o) { case "bottom": return "start"; case "top": return "end"; case "zero": return "origin"; case "origin": case "start": case "end": return o; default: return !1 } } function l(t) { var e, i = t.el._model || {}, n = t.el._scale || {}, a = t.fill, o = null; if (isFinite(a)) return null; if ("start" === a ? o = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : "end" === a ? o = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? o = i.scaleZero : n.getBasePosition ? o = n.getBasePosition() : n.getBasePixel && (o = n.getBasePixel()), null != o) { if (void 0 !== o.x && void 0 !== o.y) return o; if ("number" == typeof o && isFinite(o)) return { x: (e = n.isHorizontal()) ? o : null, y: e ? null : o } } return null } function u(t, e, i) { var n, a = t[e].fill, o = [e]; if (!i) return a; for (; !1 !== a && -1 === o.indexOf(a);) { if (!isFinite(a)) return a; if (!(n = t[a])) return !1; if (n.visible) return a; o.push(a), a = n.fill } return !1 } function d(t) { return t && !t.skip } function c(t, e, i, n, a) { var r; if (n && a) { for (t.moveTo(e[0].x, e[0].y), r = 1; r < n; ++r)o.canvas.lineTo(t, e[r - 1], e[r]); for (t.lineTo(i[a - 1].x, i[a - 1].y), r = a - 1; r > 0; --r)o.canvas.lineTo(t, i[r], i[r - 1], !0) } } e.exports = { id: "filler", afterDatasetsUpdate: function (t, e) { var i, n, o, d, c, h, f, g = (t.data.datasets || []).length, p = e.propagate, m = []; for (n = 0; n < g; ++n)d = null, (o = (i = t.getDatasetMeta(n)).dataset) && o._model && o instanceof a.Line && (d = { visible: t.isDatasetVisible(n), fill: s(o, n, g), chart: t, el: o }), i.$filler = d, m.push(d); for (n = 0; n < g; ++n)(d = m[n]) && (d.fill = u(m, n, p), d.boundary = l(d), d.mapper = (void 0, f = void 0, h = (c = d).fill, f = "dataset", !1 === h ? null : (isFinite(h) || (f = "boundary"), r[f](c)))) }, beforeDatasetDraw: function (t, e) { var i = e.meta.$filler; if (i) { var a = t.ctx, r = i.el, s = r._view, l = r._children || [], u = i.mapper, h = s.backgroundColor || n.global.defaultColor; u && h && l.length && (o.canvas.clipArea(a, t.chartArea), function (t, e, i, n, a, o) { var r, s, l, u, h, f, g, p = e.length, m = n.spanGaps, v = [], b = [], x = 0, y = 0; for (t.beginPath(), r = 0, s = p + !!o; r < s; ++r)h = i(u = e[l = r % p]._view, l, n), f = d(u), g = d(h), f && g ? (x = v.push(u), y = b.push(h)) : x && y && (m ? (f && v.push(u), g && b.push(h)) : (c(t, v, b, x, y), x = y = 0, v = [], b = [])); c(t, v, b, x, y), t.closePath(), t.fillStyle = a, t.fill() }(a, l, u, s, h, r._loop), o.canvas.unclipArea(a)) } } } }, { 25: 25, 40: 40, 45: 45 }], 51: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = t(30), s = o.noop; function l(t, e) { return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth } n._set("global", { legend: { display: !0, position: "top", fullWidth: !0, reverse: !1, weight: 1e3, onClick: function (t, e) { var i = e.datasetIndex, n = this.chart, a = n.getDatasetMeta(i); a.hidden = null === a.hidden ? !n.data.datasets[i].hidden : null, n.update() }, onHover: null, labels: { boxWidth: 40, padding: 10, generateLabels: function (t) { var e = t.data; return o.isArray(e.datasets) ? e.datasets.map(function (e, i) { return { text: e.label, fillStyle: o.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: e.borderCapStyle, lineDash: e.borderDash, lineDashOffset: e.borderDashOffset, lineJoin: e.borderJoinStyle, lineWidth: e.borderWidth, strokeStyle: e.borderColor, pointStyle: e.pointStyle, datasetIndex: i } }, this) : [] } } }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); for (var i = 0; i < t.data.datasets.length; i++)e.push('<li><span style="background-color:' + t.data.datasets[i].backgroundColor + '"></span>'), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>"); return e.push("</ul>"), e.join("") } }); var u = a.extend({ initialize: function (t) { o.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1 }, beforeUpdate: s, update: function (t, e, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize }, afterUpdate: s, beforeSetDimensions: s, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 } }, afterSetDimensions: s, beforeBuildLabels: s, buildLabels: function () { var t = this, e = t.options.labels || {}, i = o.callback(e.generateLabels, [t.chart], t) || []; e.filter && (i = i.filter(function (i) { return e.filter(i, t.chart.data) })), t.options.reverse && i.reverse(), t.legendItems = i }, afterBuildLabels: s, beforeFit: s, fit: function () { var t = this, e = t.options, i = e.labels, a = e.display, r = t.ctx, s = n.global, u = o.valueOrDefault, d = u(i.fontSize, s.defaultFontSize), c = u(i.fontStyle, s.defaultFontStyle), h = u(i.fontFamily, s.defaultFontFamily), f = o.fontString(d, c, h), g = t.legendHitBoxes = [], p = t.minSize, m = t.isHorizontal(); if (m ? (p.width = t.maxWidth, p.height = a ? 10 : 0) : (p.width = a ? 10 : 0, p.height = t.maxHeight), a) if (r.font = f, m) { var v = t.lineWidths = [0], b = t.legendItems.length ? d + i.padding : 0; r.textAlign = "left", r.textBaseline = "top", o.each(t.legendItems, function (e, n) { var a = l(i, d) + d / 2 + r.measureText(e.text).width; v[v.length - 1] + a + i.padding >= t.width && (b += d + i.padding, v[v.length] = t.left), g[n] = { left: 0, top: 0, width: a, height: d }, v[v.length - 1] += a + i.padding }), p.height += b } else { var x = i.padding, y = t.columnWidths = [], k = i.padding, M = 0, w = 0, S = d + x; o.each(t.legendItems, function (t, e) { var n = l(i, d) + d / 2 + r.measureText(t.text).width; w + S > p.height && (k += M + i.padding, y.push(M), M = 0, w = 0), M = Math.max(M, n), w += S, g[e] = { left: 0, top: 0, width: n, height: d } }), k += M, y.push(M), p.width += k } t.width = p.width, t.height = p.height }, afterFit: s, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, draw: function () { var t = this, e = t.options, i = e.labels, a = n.global, r = a.elements.line, s = t.width, u = t.lineWidths; if (e.display) { var d, c = t.ctx, h = o.valueOrDefault, f = h(i.fontColor, a.defaultFontColor), g = h(i.fontSize, a.defaultFontSize), p = h(i.fontStyle, a.defaultFontStyle), m = h(i.fontFamily, a.defaultFontFamily), v = o.fontString(g, p, m); c.textAlign = "left", c.textBaseline = "middle", c.lineWidth = .5, c.strokeStyle = f, c.fillStyle = f, c.font = v; var b = l(i, g), x = t.legendHitBoxes, y = t.isHorizontal(); d = y ? { x: t.left + (s - u[0]) / 2, y: t.top + i.padding, line: 0 } : { x: t.left + i.padding, y: t.top + i.padding, line: 0 }; var k = g + i.padding; o.each(t.legendItems, function (n, l) { var f, p, m, v, M, w = c.measureText(n.text).width, S = b + g / 2 + w, C = d.x, _ = d.y; y ? C + S >= s && (_ = d.y += k, d.line++, C = d.x = t.left + (s - u[d.line]) / 2) : _ + k > t.bottom && (C = d.x = C + t.columnWidths[d.line] + i.padding, _ = d.y = t.top + i.padding, d.line++), function (t, i, n) { if (!(isNaN(b) || b <= 0)) { c.save(), c.fillStyle = h(n.fillStyle, a.defaultColor), c.lineCap = h(n.lineCap, r.borderCapStyle), c.lineDashOffset = h(n.lineDashOffset, r.borderDashOffset), c.lineJoin = h(n.lineJoin, r.borderJoinStyle), c.lineWidth = h(n.lineWidth, r.borderWidth), c.strokeStyle = h(n.strokeStyle, a.defaultColor); var s = 0 === h(n.lineWidth, r.borderWidth); if (c.setLineDash && c.setLineDash(h(n.lineDash, r.borderDash)), e.labels && e.labels.usePointStyle) { var l = g * Math.SQRT2 / 2, u = l / Math.SQRT2, d = t + u, f = i + u; o.canvas.drawPoint(c, n.pointStyle, l, d, f) } else s || c.strokeRect(t, i, b, g), c.fillRect(t, i, b, g); c.restore() } }(C, _, n), x[l].left = C, x[l].top = _, f = n, p = w, v = b + (m = g / 2) + C, M = _ + m, c.fillText(f.text, v, M), f.hidden && (c.beginPath(), c.lineWidth = 2, c.moveTo(v, M), c.lineTo(v + p, M), c.stroke()), y ? d.x += S + i.padding : d.y += k }) } }, handleEvent: function (t) { var e = this, i = e.options, n = "mouseup" === t.type ? "click" : t.type, a = !1; if ("mousemove" === n) { if (!i.onHover) return } else { if ("click" !== n) return; if (!i.onClick) return } var o = t.x, r = t.y; if (o >= e.left && o <= e.right && r >= e.top && r <= e.bottom) for (var s = e.legendHitBoxes, l = 0; l < s.length; ++l) { var u = s[l]; if (o >= u.left && o <= u.left + u.width && r >= u.top && r <= u.top + u.height) { if ("click" === n) { i.onClick.call(e, t.native, e.legendItems[l]), a = !0; break } if ("mousemove" === n) { i.onHover.call(e, t.native, e.legendItems[l]), a = !0; break } } } return a } }); function d(t, e) { var i = new u({ ctx: t.ctx, options: e, chart: t }); r.configure(t, i, e), r.addBox(t, i), t.legend = i } e.exports = { id: "legend", _element: u, beforeInit: function (t) { var e = t.options.legend; e && d(t, e) }, beforeUpdate: function (t) { var e = t.options.legend, i = t.legend; e ? (o.mergeIf(e, n.global.legend), i ? (r.configure(t, i, e), i.options = e) : d(t, e)) : i && (r.removeBox(t, i), delete t.legend) }, afterEvent: function (t, e) { var i = t.legend; i && i.handleEvent(e) } } }, { 25: 25, 26: 26, 30: 30, 45: 45 }], 52: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = t(30), s = o.noop; n._set("global", { title: { display: !1, fontStyle: "bold", fullWidth: !0, lineHeight: 1.2, padding: 10, position: "top", text: "", weight: 2e3 } }); var l = a.extend({ initialize: function (t) { o.extend(this, t), this.legendHitBoxes = [] }, beforeUpdate: s, update: function (t, e, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize }, afterUpdate: s, beforeSetDimensions: s, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 } }, afterSetDimensions: s, beforeBuildLabels: s, buildLabels: s, afterBuildLabels: s, beforeFit: s, fit: function () { var t = this, e = o.valueOrDefault, i = t.options, a = i.display, r = e(i.fontSize, n.global.defaultFontSize), s = t.minSize, l = o.isArray(i.text) ? i.text.length : 1, u = o.options.toLineHeight(i.lineHeight, r), d = a ? l * u + 2 * i.padding : 0; t.isHorizontal() ? (s.width = t.maxWidth, s.height = d) : (s.width = d, s.height = t.maxHeight), t.width = s.width, t.height = s.height }, afterFit: s, isHorizontal: function () { var t = this.options.position; return "top" === t || "bottom" === t }, draw: function () { var t = this, e = t.ctx, i = o.valueOrDefault, a = t.options, r = n.global; if (a.display) { var s, l, u, d = i(a.fontSize, r.defaultFontSize), c = i(a.fontStyle, r.defaultFontStyle), h = i(a.fontFamily, r.defaultFontFamily), f = o.fontString(d, c, h), g = o.options.toLineHeight(a.lineHeight, d), p = g / 2 + a.padding, m = 0, v = t.top, b = t.left, x = t.bottom, y = t.right; e.fillStyle = i(a.fontColor, r.defaultFontColor), e.font = f, t.isHorizontal() ? (l = b + (y - b) / 2, u = v + p, s = y - b) : (l = "left" === a.position ? b + p : y - p, u = v + (x - v) / 2, s = x - v, m = Math.PI * ("left" === a.position ? -.5 : .5)), e.save(), e.translate(l, u), e.rotate(m), e.textAlign = "center", e.textBaseline = "middle"; var k = a.text; if (o.isArray(k)) for (var M = 0, w = 0; w < k.length; ++w)e.fillText(k[w], 0, M, s), M += g; else e.fillText(k, 0, 0, s); e.restore() } } }); function u(t, e) { var i = new l({ ctx: t.ctx, options: e, chart: t }); r.configure(t, i, e), r.addBox(t, i), t.titleBlock = i } e.exports = { id: "title", _element: l, beforeInit: function (t) { var e = t.options.title; e && u(t, e) }, beforeUpdate: function (t) { var e = t.options.title, i = t.titleBlock; e ? (o.mergeIf(e, n.global.title), i ? (r.configure(t, i, e), i.options = e) : u(t, e)) : i && (r.removeBox(t, i), delete t.titleBlock) } } }, { 25: 25, 26: 26, 30: 30, 45: 45 }], 53: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.Scale.extend({ getLabels: function () { var t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels }, determineDataLimits: function () { var t, e = this, i = e.getLabels(); e.minIndex = 0, e.maxIndex = i.length - 1, void 0 !== e.options.ticks.min && (t = i.indexOf(e.options.ticks.min), e.minIndex = -1 !== t ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = i.indexOf(e.options.ticks.max), e.maxIndex = -1 !== t ? t : e.maxIndex), e.min = i[e.minIndex], e.max = i[e.maxIndex] }, buildTicks: function () { var t = this, e = t.getLabels(); t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1) }, getLabelForIndex: function (t, e) { var i = this, n = i.chart.data, a = i.isHorizontal(); return n.yLabels && !a ? i.getRightValue(n.datasets[e].data[t]) : i.ticks[t - i.minIndex] }, getPixelForValue: function (t, e) { var i, n = this, a = n.options.offset, o = Math.max(n.maxIndex + 1 - n.minIndex - (a ? 0 : 1), 1); if (null != t && (i = n.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) { t = i || t; var r = n.getLabels().indexOf(t); e = -1 !== r ? r : e } if (n.isHorizontal()) { var s = n.width / o, l = s * (e - n.minIndex); return a && (l += s / 2), n.left + Math.round(l) } var u = n.height / o, d = u * (e - n.minIndex); return a && (d += u / 2), n.top + Math.round(d) }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null) }, getValueForPixel: function (t) { var e = this, i = e.options.offset, n = Math.max(e._ticks.length - (i ? 0 : 1), 1), a = e.isHorizontal(), o = (a ? e.width : e.height) / n; return t -= a ? e.left : e.top, i && (t -= o / 2), (t <= 0 ? 0 : Math.round(t / o)) + e.minIndex }, getBasePixel: function () { return this.bottom } }); t.scaleService.registerScaleType("category", e, { position: "bottom" }) } }, {}], 54: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(34); e.exports = function (t) { var e = { position: "left", ticks: { callback: o.formatters.linear } }, i = t.LinearScaleBase.extend({ determineDataLimits: function () { var t = this, e = t.options, i = t.chart, n = i.data.datasets, o = t.isHorizontal(); function r(e) { return o ? e.xAxisID === t.id : e.yAxisID === t.id } t.min = null, t.max = null; var s = e.stacked; if (void 0 === s && a.each(n, function (t, e) { if (!s) { var n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (s = !0) } }), e.stacked || s) { var l = {}; a.each(n, function (n, o) { var s = i.getDatasetMeta(o), u = [s.type, void 0 === e.stacked && void 0 === s.stack ? o : "", s.stack].join("."); void 0 === l[u] && (l[u] = { positiveValues: [], negativeValues: [] }); var d = l[u].positiveValues, c = l[u].negativeValues; i.isDatasetVisible(o) && r(s) && a.each(n.data, function (i, n) { var a = +t.getRightValue(i); isNaN(a) || s.data[n].hidden || (d[n] = d[n] || 0, c[n] = c[n] || 0, e.relativePoints ? d[n] = 100 : a < 0 ? c[n] += a : d[n] += a) }) }), a.each(l, function (e) { var i = e.positiveValues.concat(e.negativeValues), n = a.min(i), o = a.max(i); t.min = null === t.min ? n : Math.min(t.min, n), t.max = null === t.max ? o : Math.max(t.max, o) }) } else a.each(n, function (e, n) { var o = i.getDatasetMeta(n); i.isDatasetVisible(n) && r(o) && a.each(e.data, function (e, i) { var n = +t.getRightValue(e); isNaN(n) || o.data[i].hidden || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n)) }) }); t.min = isFinite(t.min) && !isNaN(t.min) ? t.min : 0, t.max = isFinite(t.max) && !isNaN(t.max) ? t.max : 1, this.handleTickRangeOptions() }, getTickLimit: function () { var t, e = this.options.ticks; if (this.isHorizontal()) t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.width / 50)); else { var i = a.valueOrDefault(e.fontSize, n.global.defaultFontSize); t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.height / (2 * i))) } return t }, handleDirectionalChanges: function () { this.isHorizontal() || this.ticks.reverse() }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForValue: function (t) { var e = this, i = e.start, n = +e.getRightValue(t), a = e.end - i; return e.isHorizontal() ? e.left + e.width / a * (n - i) : e.bottom - e.height / a * (n - i) }, getValueForPixel: function (t) { var e = this, i = e.isHorizontal(), n = i ? e.width : e.height, a = (i ? t - e.left : e.bottom - t) / n; return e.start + (e.end - e.start) * a }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticksAsNumbers[t]) } }); t.scaleService.registerScaleType("linear", i, e) } }, { 25: 25, 34: 34, 45: 45 }], 55: [function (t, e, i) { "use strict"; var n = t(45); e.exports = function (t) { var e = n.noop; t.LinearScaleBase = t.Scale.extend({ getRightValue: function (e) { return "string" == typeof e ? +e : t.Scale.prototype.getRightValue.call(this, e) }, handleTickRangeOptions: function () { var t = this, e = t.options.ticks; if (e.beginAtZero) { var i = n.sign(t.min), a = n.sign(t.max); i < 0 && a < 0 ? t.max = 0 : i > 0 && a > 0 && (t.min = 0) } var o = void 0 !== e.min || void 0 !== e.suggestedMin, r = void 0 !== e.max || void 0 !== e.suggestedMax; void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (null === t.min ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (null === t.max ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), o !== r && t.min >= t.max && (o ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--) }, getTickLimit: e, handleDirectionalChanges: e, buildTicks: function () { var t = this, e = t.options.ticks, i = t.getTickLimit(), a = { maxTicks: i = Math.max(2, i), min: e.min, max: e.max, stepSize: n.valueOrDefault(e.fixedStepSize, e.stepSize) }, o = t.ticks = function (t, e) { var i, a = []; if (t.stepSize && t.stepSize > 0) i = t.stepSize; else { var o = n.niceNum(e.max - e.min, !1); i = n.niceNum(o / (t.maxTicks - 1), !0) } var r = Math.floor(e.min / i) * i, s = Math.ceil(e.max / i) * i; t.min && t.max && t.stepSize && n.almostWhole((t.max - t.min) / t.stepSize, i / 1e3) && (r = t.min, s = t.max); var l = (s - r) / i; l = n.almostEquals(l, Math.round(l), i / 1e3) ? Math.round(l) : Math.ceil(l); var u = 1; i < 1 && (u = Math.pow(10, i.toString().length - 2), r = Math.round(r * u) / u, s = Math.round(s * u) / u), a.push(void 0 !== t.min ? t.min : r); for (var d = 1; d < l; ++d)a.push(Math.round((r + d * i) * u) / u); return a.push(void 0 !== t.max ? t.max : s), a }(a, t); t.handleDirectionalChanges(), t.max = n.max(o), t.min = n.min(o), e.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max) }, convertTicksToLabels: function () { var e = this; e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e) } }) } }, { 45: 45 }], 56: [function (t, e, i) { "use strict"; var n = t(45), a = t(34); e.exports = function (t) { var e = { position: "left", ticks: { callback: a.formatters.logarithmic } }, i = t.Scale.extend({ determineDataLimits: function () { var t = this, e = t.options, i = t.chart, a = i.data.datasets, o = t.isHorizontal(); function r(e) { return o ? e.xAxisID === t.id : e.yAxisID === t.id } t.min = null, t.max = null, t.minNotZero = null; var s = e.stacked; if (void 0 === s && n.each(a, function (t, e) { if (!s) { var n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (s = !0) } }), e.stacked || s) { var l = {}; n.each(a, function (a, o) { var s = i.getDatasetMeta(o), u = [s.type, void 0 === e.stacked && void 0 === s.stack ? o : "", s.stack].join("."); i.isDatasetVisible(o) && r(s) && (void 0 === l[u] && (l[u] = []), n.each(a.data, function (e, i) { var n = l[u], a = +t.getRightValue(e); isNaN(a) || s.data[i].hidden || a < 0 || (n[i] = n[i] || 0, n[i] += a) })) }), n.each(l, function (e) { if (e.length > 0) { var i = n.min(e), a = n.max(e); t.min = null === t.min ? i : Math.min(t.min, i), t.max = null === t.max ? a : Math.max(t.max, a) } }) } else n.each(a, function (e, a) { var o = i.getDatasetMeta(a); i.isDatasetVisible(a) && r(o) && n.each(e.data, function (e, i) { var n = +t.getRightValue(e); isNaN(n) || o.data[i].hidden || n < 0 || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n), 0 !== n && (null === t.minNotZero || n < t.minNotZero) && (t.minNotZero = n)) }) }); this.handleTickRangeOptions() }, handleTickRangeOptions: function () { var t = this, e = t.options.ticks, i = n.valueOrDefault; t.min = i(e.min, t.min), t.max = i(e.max, t.max), t.min === t.max && (0 !== t.min && null !== t.min ? (t.min = Math.pow(10, Math.floor(n.log10(t.min)) - 1), t.max = Math.pow(10, Math.floor(n.log10(t.max)) + 1)) : (t.min = 1, t.max = 10)), null === t.min && (t.min = Math.pow(10, Math.floor(n.log10(t.max)) - 1)), null === t.max && (t.max = 0 !== t.min ? Math.pow(10, Math.floor(n.log10(t.min)) + 1) : 10), null === t.minNotZero && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = Math.pow(10, Math.floor(n.log10(t.max))) : t.minNotZero = 1) }, buildTicks: function () { var t = this, e = t.options.ticks, i = !t.isHorizontal(), a = { min: e.min, max: e.max }, o = t.ticks = function (t, e) { var i, a, o = [], r = n.valueOrDefault, s = r(t.min, Math.pow(10, Math.floor(n.log10(e.min)))), l = Math.floor(n.log10(e.max)), u = Math.ceil(e.max / Math.pow(10, l)); 0 === s ? (i = Math.floor(n.log10(e.minNotZero)), a = Math.floor(e.minNotZero / Math.pow(10, i)), o.push(s), s = a * Math.pow(10, i)) : (i = Math.floor(n.log10(s)), a = Math.floor(s / Math.pow(10, i))); for (var d = i < 0 ? Math.pow(10, Math.abs(i)) : 1; o.push(s), 10 == ++a && (a = 1, d = ++i >= 0 ? 1 : d), s = Math.round(a * Math.pow(10, i) * d) / d, i < l || i === l && a < u;); var c = r(t.max, s); return o.push(c), o }(a, t); t.max = n.max(o), t.min = n.min(o), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && o.reverse() }, convertTicksToLabels: function () { this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickValues[t]) }, _getFirstTickValue: function (t) { var e = Math.floor(n.log10(t)); return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e) }, getPixelForValue: function (e) { var i, a, o, r, s, l = this, u = l.options.ticks.reverse, d = n.log10, c = l._getFirstTickValue(l.minNotZero), h = 0; return e = +l.getRightValue(e), u ? (o = l.end, r = l.start, s = -1) : (o = l.start, r = l.end, s = 1), l.isHorizontal() ? (i = l.width, a = u ? l.right : l.left) : (i = l.height, s *= -1, a = u ? l.top : l.bottom), e !== o && (0 === o && (i -= h = n.getValueOrDefault(l.options.ticks.fontSize, t.defaults.global.defaultFontSize), o = c), 0 !== e && (h += i / (d(r) - d(o)) * (d(e) - d(o))), a += s * h), a }, getValueForPixel: function (e) { var i, a, o, r, s = this, l = s.options.ticks.reverse, u = n.log10, d = s._getFirstTickValue(s.minNotZero); if (l ? (a = s.end, o = s.start) : (a = s.start, o = s.end), s.isHorizontal() ? (i = s.width, r = l ? s.right - e : e - s.left) : (i = s.height, r = l ? e - s.top : s.bottom - e), r !== a) { if (0 === a) { var c = n.getValueOrDefault(s.options.ticks.fontSize, t.defaults.global.defaultFontSize); r -= c, i -= c, a = d } r *= u(o) - u(a), r /= i, r = Math.pow(10, u(a) + r) } return r } }); t.scaleService.registerScaleType("logarithmic", i, e) } }, { 34: 34, 45: 45 }], 57: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(34); e.exports = function (t) { var e = n.global, i = { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1 }, gridLines: { circular: !1 }, ticks: { showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: o.formatters.linear }, pointLabels: { display: !0, fontSize: 10, callback: function (t) { return t } } }; function r(t) { var e = t.options; return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0 } function s(t) { var i = t.options.pointLabels, n = a.valueOrDefault(i.fontSize, e.defaultFontSize), o = a.valueOrDefault(i.fontStyle, e.defaultFontStyle), r = a.valueOrDefault(i.fontFamily, e.defaultFontFamily); return { size: n, style: o, family: r, font: a.fontString(n, o, r) } } function l(t, e, i, n, a) { return t === n || t === a ? { start: e - i / 2, end: e + i / 2 } : t < n || t > a ? { start: e - i - 5, end: e } : { start: e, end: e + i + 5 } } function u(t, e, i, n) { if (a.isArray(e)) for (var o = i.y, r = 1.5 * n, s = 0; s < e.length; ++s)t.fillText(e[s], i.x, o), o += r; else t.fillText(e, i.x, i.y) } function d(t) { return a.isNumber(t) ? t : 0 } var c = t.LinearScaleBase.extend({ setDimensions: function () { var t = this, i = t.options, n = i.ticks; t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2); var o = a.min([t.height, t.width]), r = a.valueOrDefault(n.fontSize, e.defaultFontSize); t.drawingArea = i.display ? o / 2 - (r / 2 + n.backdropPaddingY) : o / 2 }, determineDataLimits: function () { var t = this, e = t.chart, i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY; a.each(e.data.datasets, function (o, r) { if (e.isDatasetVisible(r)) { var s = e.getDatasetMeta(r); a.each(o.data, function (e, a) { var o = +t.getRightValue(e); isNaN(o) || s.data[a].hidden || (i = Math.min(o, i), n = Math.max(o, n)) }) } }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions() }, getTickLimit: function () { var t = this.options.ticks, i = a.valueOrDefault(t.fontSize, e.defaultFontSize); return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * i))) }, convertTicksToLabels: function () { var e = this; t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, fit: function () { var t, e; this.options.pointLabels.display ? function (t) { var e, i, n, o = s(t), u = Math.min(t.height / 2, t.width / 2), d = { r: t.width, l: 0, t: t.height, b: 0 }, c = {}; t.ctx.font = o.font, t._pointLabelSizes = []; var h, f, g, p = r(t); for (e = 0; e < p; e++) { n = t.getPointPosition(e, u), h = t.ctx, f = o.size, g = t.pointLabels[e] || "", i = a.isArray(g) ? { w: a.longestText(h, h.font, g), h: g.length * f + 1.5 * (g.length - 1) * f } : { w: h.measureText(g).width, h: f }, t._pointLabelSizes[e] = i; var m = t.getIndexAngle(e), v = a.toDegrees(m) % 360, b = l(v, n.x, i.w, 0, 180), x = l(v, n.y, i.h, 90, 270); b.start < d.l && (d.l = b.start, c.l = m), b.end > d.r && (d.r = b.end, c.r = m), x.start < d.t && (d.t = x.start, c.t = m), x.end > d.b && (d.b = x.end, c.b = m) } t.setReductions(u, d, c) }(this) : (t = this, e = Math.min(t.height / 2, t.width / 2), t.drawingArea = Math.round(e), t.setCenterPoint(0, 0, 0, 0)) }, setReductions: function (t, e, i) { var n = e.l / Math.sin(i.l), a = Math.max(e.r - this.width, 0) / Math.sin(i.r), o = -e.t / Math.cos(i.t), r = -Math.max(e.b - this.height, 0) / Math.cos(i.b); n = d(n), a = d(a), o = d(o), r = d(r), this.drawingArea = Math.min(Math.round(t - (n + a) / 2), Math.round(t - (o + r) / 2)), this.setCenterPoint(n, a, o, r) }, setCenterPoint: function (t, e, i, n) { var a = this, o = a.width - e - a.drawingArea, r = t + a.drawingArea, s = i + a.drawingArea, l = a.height - n - a.drawingArea; a.xCenter = Math.round((r + o) / 2 + a.left), a.yCenter = Math.round((s + l) / 2 + a.top) }, getIndexAngle: function (t) { return t * (2 * Math.PI / r(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360 }, getDistanceFromCenterForValue: function (t) { var e = this; if (null === t) return 0; var i = e.drawingArea / (e.max - e.min); return e.options.ticks.reverse ? (e.max - t) * i : (t - e.min) * i }, getPointPosition: function (t, e) { var i = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.round(Math.cos(i) * e) + this.xCenter, y: Math.round(Math.sin(i) * e) + this.yCenter } }, getPointPositionForValue: function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) }, getBasePosition: function () { var t = this.min, e = this.max; return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0) }, draw: function () { var t = this, i = t.options, n = i.gridLines, o = i.ticks, l = a.valueOrDefault; if (i.display) { var d = t.ctx, c = this.getIndexAngle(0), h = l(o.fontSize, e.defaultFontSize), f = l(o.fontStyle, e.defaultFontStyle), g = l(o.fontFamily, e.defaultFontFamily), p = a.fontString(h, f, g); a.each(t.ticks, function (i, s) { if (s > 0 || o.reverse) { var u = t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]); if (n.display && 0 !== s && function (t, e, i, n) { var o = t.ctx; if (o.strokeStyle = a.valueAtIndexOrDefault(e.color, n - 1), o.lineWidth = a.valueAtIndexOrDefault(e.lineWidth, n - 1), t.options.gridLines.circular) o.beginPath(), o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI), o.closePath(), o.stroke(); else { var s = r(t); if (0 === s) return; o.beginPath(); var l = t.getPointPosition(0, i); o.moveTo(l.x, l.y); for (var u = 1; u < s; u++)l = t.getPointPosition(u, i), o.lineTo(l.x, l.y); o.closePath(), o.stroke() } }(t, n, u, s), o.display) { var f = l(o.fontColor, e.defaultFontColor); if (d.font = p, d.save(), d.translate(t.xCenter, t.yCenter), d.rotate(c), o.showLabelBackdrop) { var g = d.measureText(i).width; d.fillStyle = o.backdropColor, d.fillRect(-g / 2 - o.backdropPaddingX, -u - h / 2 - o.backdropPaddingY, g + 2 * o.backdropPaddingX, h + 2 * o.backdropPaddingY) } d.textAlign = "center", d.textBaseline = "middle", d.fillStyle = f, d.fillText(i, 0, -u), d.restore() } } }), (i.angleLines.display || i.pointLabels.display) && function (t) { var i = t.ctx, n = t.options, o = n.angleLines, l = n.pointLabels; i.lineWidth = o.lineWidth, i.strokeStyle = o.color; var d, c, h, f, g = t.getDistanceFromCenterForValue(n.ticks.reverse ? t.min : t.max), p = s(t); i.textBaseline = "top"; for (var m = r(t) - 1; m >= 0; m--) { if (o.display) { var v = t.getPointPosition(m, g); i.beginPath(), i.moveTo(t.xCenter, t.yCenter), i.lineTo(v.x, v.y), i.stroke(), i.closePath() } if (l.display) { var b = t.getPointPosition(m, g + 5), x = a.valueAtIndexOrDefault(l.fontColor, m, e.defaultFontColor); i.font = p.font, i.fillStyle = x; var y = t.getIndexAngle(m), k = a.toDegrees(y); i.textAlign = 0 === (f = k) || 180 === f ? "center" : f < 180 ? "left" : "right", d = k, c = t._pointLabelSizes[m], h = b, 90 === d || 270 === d ? h.y -= c.h / 2 : (d > 270 || d < 90) && (h.y -= c.h), u(i, t.pointLabels[m] || "", b, p.size) } } }(t) } } }); t.scaleService.registerScaleType("radialLinear", c, i) } }, { 25: 25, 34: 34, 45: 45 }], 58: [function (t, e, i) { "use strict"; var n = t(1); n = "function" == typeof n ? n : window.moment; var a = t(25), o = t(45), r = Number.MIN_SAFE_INTEGER || -9007199254740991, s = Number.MAX_SAFE_INTEGER || 9007199254740991, l = { millisecond: { common: !0, size: 1, steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, second: { common: !0, size: 1e3, steps: [1, 2, 5, 10, 30] }, minute: { common: !0, size: 6e4, steps: [1, 2, 5, 10, 30] }, hour: { common: !0, size: 36e5, steps: [1, 2, 3, 6, 12] }, day: { common: !0, size: 864e5, steps: [1, 2, 5] }, week: { common: !1, size: 6048e5, steps: [1, 2, 3, 4] }, month: { common: !0, size: 2628e6, steps: [1, 2, 3] }, quarter: { common: !1, size: 7884e6, steps: [1, 2, 3, 4] }, year: { common: !0, size: 3154e7 } }, u = Object.keys(l); function d(t, e) { return t - e } function c(t) { var e, i, n, a = {}, o = []; for (e = 0, i = t.length; e < i; ++e)a[n = t[e]] || (a[n] = !0, o.push(n)); return o } function h(t, e, i, n) { var a = function (t, e, i) { for (var n, a, o, r = 0, s = t.length - 1; r >= 0 && r <= s;) { if (a = t[(n = r + s >> 1) - 1] || null, o = t[n], !a) return { lo: null, hi: o }; if (o[e] < i) r = n + 1; else { if (!(a[e] > i)) return { lo: a, hi: o }; s = n - 1 } } return { lo: o, hi: null } }(t, e, i), o = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0], r = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1], s = r[e] - o[e], l = s ? (i - o[e]) / s : 0, u = (r[n] - o[n]) * l; return o[n] + u } function f(t, e) { var i = e.parser, a = e.parser || e.format; return "function" == typeof i ? i(t) : "string" == typeof t && "string" == typeof a ? n(t, a) : (t instanceof n || (t = n(t)), t.isValid() ? t : "function" == typeof a ? a(t) : t) } function g(t, e) { if (o.isNullOrUndef(t)) return null; var i = e.options.time, n = f(e.getRightValue(t), i); return n.isValid() ? (i.round && n.startOf(i.round), n.valueOf()) : null } function p(t) { for (var e = u.indexOf(t) + 1, i = u.length; e < i; ++e)if (l[u[e]].common) return u[e] } function m(t, e, i, a) { var r, d = a.time, c = d.unit || function (t, e, i, n) { var a, o, r, d = u.length; for (a = u.indexOf(t); a < d - 1; ++a)if (r = (o = l[u[a]]).steps ? o.steps[o.steps.length - 1] : s, o.common && Math.ceil((i - e) / (r * o.size)) <= n) return u[a]; return u[d - 1] }(d.minUnit, t, e, i), h = p(c), f = o.valueOrDefault(d.stepSize, d.unitStepSize), g = "week" === c && d.isoWeekday, m = a.ticks.major.enabled, v = l[c], b = n(t), x = n(e), y = []; for (f || (f = function (t, e, i, n) { var a, o, r, s = e - t, u = l[i], d = u.size, c = u.steps; if (!c) return Math.ceil(s / (n * d)); for (a = 0, o = c.length; a < o && (r = c[a], !(Math.ceil(s / (d * r)) <= n)); ++a); return r }(t, e, c, i)), g && (b = b.isoWeekday(g), x = x.isoWeekday(g)), b = b.startOf(g ? "day" : c), (x = x.startOf(g ? "day" : c)) < e && x.add(1, c), r = n(b), m && h && !g && !d.round && (r.startOf(h), r.add(~~((b - r) / (v.size * f)) * f, c)); r < x; r.add(f, c))y.push(+r); return y.push(+r), y } e.exports = function (t) { var e = t.Scale.extend({ initialize: function () { if (!n) throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com"); this.mergeTicksOptions(), t.Scale.prototype.initialize.call(this) }, update: function () { var e = this.options; return e.time && e.time.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), t.Scale.prototype.update.apply(this, arguments) }, getRightValue: function (e) { return e && void 0 !== e.t && (e = e.t), t.Scale.prototype.getRightValue.call(this, e) }, determineDataLimits: function () { var t, e, i, a, l, u, h = this, f = h.chart, p = h.options.time, m = p.unit || "day", v = s, b = r, x = [], y = [], k = []; for (t = 0, i = f.data.labels.length; t < i; ++t)k.push(g(f.data.labels[t], h)); for (t = 0, i = (f.data.datasets || []).length; t < i; ++t)if (f.isDatasetVisible(t)) if (l = f.data.datasets[t].data, o.isObject(l[0])) for (y[t] = [], e = 0, a = l.length; e < a; ++e)u = g(l[e], h), x.push(u), y[t][e] = u; else x.push.apply(x, k), y[t] = k.slice(0); else y[t] = []; k.length && (k = c(k).sort(d), v = Math.min(v, k[0]), b = Math.max(b, k[k.length - 1])), x.length && (x = c(x).sort(d), v = Math.min(v, x[0]), b = Math.max(b, x[x.length - 1])), v = g(p.min, h) || v, b = g(p.max, h) || b, v = v === s ? +n().startOf(m) : v, b = b === r ? +n().endOf(m) + 1 : b, h.min = Math.min(v, b), h.max = Math.max(v + 1, b), h._horizontal = h.isHorizontal(), h._table = [], h._timestamps = { data: x, datasets: y, labels: k } }, buildTicks: function () { var t, e, i, a, o, r, s, d, c, v, b, x, y = this, k = y.min, M = y.max, w = y.options, S = w.time, C = [], _ = []; switch (w.ticks.source) { case "data": C = y._timestamps.data; break; case "labels": C = y._timestamps.labels; break; case "auto": default: C = m(k, M, y.getLabelCapacity(k), w) }for ("ticks" === w.bounds && C.length && (k = C[0], M = C[C.length - 1]), k = g(S.min, y) || k, M = g(S.max, y) || M, t = 0, e = C.length; t < e; ++t)(i = C[t]) >= k && i <= M && _.push(i); return y.min = k, y.max = M, y._unit = S.unit || function (t, e, i, a) { var o, r, s = n.duration(n(a).diff(n(i))); for (o = u.length - 1; o >= u.indexOf(e); o--)if (r = u[o], l[r].common && s.as(r) >= t.length) return r; return u[e ? u.indexOf(e) : 0] }(_, S.minUnit, y.min, y.max), y._majorUnit = p(y._unit), y._table = function (t, e, i, n) { if ("linear" === n || !t.length) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; var a, o, r, s, l, u = [], d = [e]; for (a = 0, o = t.length; a < o; ++a)(s = t[a]) > e && s < i && d.push(s); for (d.push(i), a = 0, o = d.length; a < o; ++a)l = d[a + 1], r = d[a - 1], s = d[a], void 0 !== r && void 0 !== l && Math.round((l + r) / 2) === s || u.push({ time: s, pos: a / (o - 1) }); return u }(y._timestamps.data, k, M, w.distribution), y._offsets = (a = y._table, o = _, r = k, s = M, b = 0, x = 0, (d = w).offset && o.length && (d.time.min || (c = o.length > 1 ? o[1] : s, v = o[0], b = (h(a, "time", c, "pos") - h(a, "time", v, "pos")) / 2), d.time.max || (c = o[o.length - 1], v = o.length > 1 ? o[o.length - 2] : r, x = (h(a, "time", c, "pos") - h(a, "time", v, "pos")) / 2)), { left: b, right: x }), y._labelFormat = function (t, e) { var i, n, a, o = t.length; for (i = 0; i < o; i++) { if (0 !== (n = f(t[i], e)).millisecond()) return "MMM D, YYYY h:mm:ss.SSS a"; 0 === n.second() && 0 === n.minute() && 0 === n.hour() || (a = !0) } return a ? "MMM D, YYYY h:mm:ss a" : "MMM D, YYYY" }(y._timestamps.data, S), function (t, e) { var i, a, o, r, s = []; for (i = 0, a = t.length; i < a; ++i)o = t[i], r = !!e && o === +n(o).startOf(e), s.push({ value: o, major: r }); return s }(_, y._majorUnit) }, getLabelForIndex: function (t, e) { var i = this.chart.data, n = this.options.time, a = i.labels && t < i.labels.length ? i.labels[t] : "", r = i.datasets[e].data[t]; return o.isObject(r) && (a = this.getRightValue(r)), n.tooltipFormat ? f(a, n).format(n.tooltipFormat) : "string" == typeof a ? a : f(a, n).format(this._labelFormat) }, tickFormatFunction: function (t, e, i, n) { var a = this.options, r = t.valueOf(), s = a.time.displayFormats, l = s[this._unit], u = this._majorUnit, d = s[u], c = t.clone().startOf(u).valueOf(), h = a.ticks.major, f = h.enabled && u && d && r === c, g = t.format(n || (f ? d : l)), p = f ? h : a.ticks.minor, m = o.valueOrDefault(p.callback, p.userCallback); return m ? m(g, e, i) : g }, convertTicksToLabels: function (t) { var e, i, a = []; for (e = 0, i = t.length; e < i; ++e)a.push(this.tickFormatFunction(n(t[e].value), e, t)); return a }, getPixelForOffset: function (t) { var e = this, i = e._horizontal ? e.width : e.height, n = e._horizontal ? e.left : e.top, a = h(e._table, "time", t, "pos"); return n + i * (e._offsets.left + a) / (e._offsets.left + 1 + e._offsets.right) }, getPixelForValue: function (t, e, i) { var n = null; if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), null === n && (n = g(t, this)), null !== n) return this.getPixelForOffset(n) }, getPixelForTick: function (t) { var e = this.getTicks(); return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null }, getValueForPixel: function (t) { var e = this, i = e._horizontal ? e.width : e.height, a = e._horizontal ? e.left : e.top, o = (i ? (t - a) / i : 0) * (e._offsets.left + 1 + e._offsets.left) - e._offsets.right, r = h(e._table, "pos", o, "time"); return n(r) }, getLabelWidth: function (t) { var e = this.options.ticks, i = this.ctx.measureText(t).width, n = o.toRadians(e.maxRotation), r = Math.cos(n), s = Math.sin(n); return i * r + o.valueOrDefault(e.fontSize, a.global.defaultFontSize) * s }, getLabelCapacity: function (t) { var e = this, i = e.options.time.displayFormats.millisecond, a = e.tickFormatFunction(n(t), 0, [], i), o = e.getLabelWidth(a), r = e.isHorizontal() ? e.width : e.height, s = Math.floor(r / o); return s > 0 ? s : 1 } }); t.scaleService.registerScaleType("time", e, { position: "bottom", distribution: "linear", bounds: "data", time: { parser: !1, format: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: { millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" } }, ticks: { autoSkip: !1, source: "auto", major: { enabled: !1 } } }) } }, { 1: 1, 25: 25, 45: 45 }] }, {}, [7])(7) });/*!smooth-scroll v14.2.1 | (c) 2018 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll*/window.Element && !Element.prototype.closest && (Element.prototype.closest = function (e) { var t, n = (this.document || this.ownerDocument).querySelectorAll(e), o = this; do { for (t = n.length; --t >= 0 && n.item(t) !== o;); } while (t < 0 && (o = o.parentElement)); return o }), (function () { function e(e, t) { t = t || { bubbles: !1, cancelable: !1, detail: void 0 }; var n = document.createEvent("CustomEvent"); return n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), n } if ("function" == typeof window.CustomEvent) return !1; e.prototype = window.Event.prototype, window.CustomEvent = e })(), (function () { for (var e = 0, t = ["ms", "moz", "webkit", "o"], n = 0; n < t.length && !window.requestAnimationFrame; ++n)window.requestAnimationFrame = window[t[n] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[t[n] + "CancelAnimationFrame"] || window[t[n] + "CancelRequestAnimationFrame"]; window.requestAnimationFrame || (window.requestAnimationFrame = function (t, n) { var o = (new Date).getTime(), i = Math.max(0, 16 - (o - e)), r = window.setTimeout((function () { t(o + i) }), i); return e = o + i, r }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (e) { clearTimeout(e) }) })(), (function (e, t) { "function" == typeof define && define.amd ? define([], (function () { return t(e) })) : "object" == typeof exports ? module.exports = t(e) : e.SmoothScroll = t(e) })("undefined" != typeof global ? global : "undefined" != typeof window ? window : this, (function (e) { "use strict"; var t = { ignore: "[data-scroll-ignore]", header: null, topOnEmptyHash: !0, speed: 500, clip: !0, offset: 0, easing: "easeInOutCubic", customEasing: null, updateURL: !0, popstate: !0, emitEvents: !0 }, n = function () { return "querySelector" in document && "addEventListener" in e && "requestAnimationFrame" in e && "closest" in e.Element.prototype }, o = function () { for (var e = {}, t = 0; t < arguments.length; t++)!(function (t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) })(arguments[t]); return e }, i = function (t) { return !!("matchMedia" in e && e.matchMedia("(prefers-reduced-motion)").matches) }, r = function (t) { return parseInt(e.getComputedStyle(t).height, 10) }, a = function (e) { var t; try { t = decodeURIComponent(e) } catch (n) { t = e } return t }, u = function (e) { "#" === e.charAt(0) && (e = e.substr(1)); for (var t, n = String(e), o = n.length, i = -1, r = "", a = n.charCodeAt(0); ++i < o;) { if (0 === (t = n.charCodeAt(i))) throw new InvalidCharacterError("Invalid character: the input contains U+0000."); t >= 1 && t <= 31 || 127 == t || 0 === i && t >= 48 && t <= 57 || 1 === i && t >= 48 && t <= 57 && 45 === a ? r += "\\" + t.toString(16) + " " : r += t >= 128 || 45 === t || 95 === t || t >= 48 && t <= 57 || t >= 65 && t <= 90 || t >= 97 && t <= 122 ? n.charAt(i) : "\\" + n.charAt(i) } var u; try { u = decodeURIComponent("#" + r) } catch (e) { u = "#" + r } return u }, c = function (e, t) { var n; return "easeInQuad" === e.easing && (n = t * t), "easeOutQuad" === e.easing && (n = t * (2 - t)), "easeInOutQuad" === e.easing && (n = t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1), "easeInCubic" === e.easing && (n = t * t * t), "easeOutCubic" === e.easing && (n = --t * t * t + 1), "easeInOutCubic" === e.easing && (n = t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1), "easeInQuart" === e.easing && (n = t * t * t * t), "easeOutQuart" === e.easing && (n = 1 - --t * t * t * t), "easeInOutQuart" === e.easing && (n = t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t), "easeInQuint" === e.easing && (n = t * t * t * t * t), "easeOutQuint" === e.easing && (n = 1 + --t * t * t * t * t), "easeInOutQuint" === e.easing && (n = t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t), e.customEasing && (n = e.customEasing(t)), n || t }, s = function () { return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) }, l = function (t, n, o, i) { var r = 0; if (t.offsetParent) do { r += t.offsetTop, t = t.offsetParent } while (t); return r = Math.max(r - n - o, 0), i && (r = Math.min(r, s() - e.innerHeight)), r }, m = function (e) { return e ? r(e) + e.offsetTop : 0 }, d = function (e, t, n) { t || history.pushState && n.updateURL && history.pushState({ smoothScroll: JSON.stringify(n), anchor: e.id }, document.title, e === document.documentElement ? "#top" : "#" + e.id) }, f = function (t, n, o) { 0 === t && document.body.focus(), o || (t.focus(), document.activeElement !== t && (t.setAttribute("tabindex", "-1"), t.focus(), t.style.outline = "none"), e.scrollTo(0, n)) }, h = function (t, n, o, i) { if (n.emitEvents && "function" == typeof e.CustomEvent) { var r = new CustomEvent(t, { bubbles: !0, detail: { anchor: o, toggle: i } }); document.dispatchEvent(r) } }; return function (r, p) { var g, v, w, y, E, b, S, A = {}; A.cancelScroll = function (e) { cancelAnimationFrame(S), S = null, e || h("scrollCancel", g) }, A.animateScroll = function (n, i, r) { var a = o(g || t, r || {}), u = "[object Number]" === Object.prototype.toString.call(n), p = u || !n.tagName ? null : n; if (u || p) { var v = e.pageYOffset; a.header && !y && (y = document.querySelector(a.header)), E || (E = m(y)); var w, b, C, O = u ? n : l(p, E, parseInt("function" == typeof a.offset ? a.offset(n, i) : a.offset, 10), a.clip), I = O - v, q = s(), F = 0, L = function (t, o) { var r = e.pageYOffset; if (t == o || r == o || (v < o && e.innerHeight + r) >= q) return A.cancelScroll(!0), f(n, o, u), h("scrollStop", a, n, i), w = null, S = null, !0 }, H = function (t) { w || (w = t), F += t - w, b = F / parseInt(a.speed, 10), b = b > 1 ? 1 : b, C = v + I * c(a, b), e.scrollTo(0, Math.floor(C)), L(C, O) || (S = e.requestAnimationFrame(H), w = t) }; 0 === e.pageYOffset && e.scrollTo(0, 0), d(n, u, a), h("scrollStart", a, n, i), A.cancelScroll(!0), e.requestAnimationFrame(H) } }; var C = function (t) { if (!i() && 0 === t.button && !t.metaKey && !t.ctrlKey && "closest" in t.target && (w = t.target.closest(r)) && "a" === w.tagName.toLowerCase() && !t.target.closest(g.ignore) && w.hostname === e.location.hostname && w.pathname === e.location.pathname && /#/.test(w.href)) { var n = u(a(w.hash)), o = g.topOnEmptyHash && "#" === n ? document.documentElement : document.querySelector(n); o = o || "#top" !== n ? o : document.documentElement, o && (t.preventDefault(), A.animateScroll(o, w)) } }, O = function (e) { if (null !== history.state && history.state.smoothScroll && history.state.smoothScroll === JSON.stringify(g) && history.state.anchor) { var t = document.querySelector(u(a(history.state.anchor))); t && A.animateScroll(t, null, { updateURL: !1 }) } }, I = function (e) { b || (b = setTimeout((function () { b = null, E = m(y) }), 66)) }; return A.destroy = function () { g && (document.removeEventListener("click", C, !1), e.removeEventListener("resize", I, !1), e.removeEventListener("popstate", O, !1), A.cancelScroll(), g = null, v = null, w = null, y = null, E = null, b = null, S = null) }, A.init = function (i) { if (!n()) throw "Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs."; A.destroy(), g = o(t, i || {}), y = g.header ? document.querySelector(g.header) : null, E = m(y), document.addEventListener("click", C, !1), y && e.addEventListener("resize", I, !1), g.updateURL && g.popstate && e.addEventListener("popstate", O, !1) }, A.init(p), A } }));/*!flipclock 2015-08-31*/var Base = function () { }; Base.extend = function (a, b) { "use strict"; var c = Base.prototype.extend; Base._prototyping = !0; var d = new this; c.call(d, a), d.base = function () { }, delete Base._prototyping; var e = d.constructor, f = d.constructor = function () { if (!Base._prototyping) if (this._constructing || this.constructor == f) this._constructing = !0, e.apply(this, arguments), delete this._constructing; else if (null !== arguments[0]) return (arguments[0].extend || c).call(arguments[0], d) }; return f.ancestor = this, f.extend = this.extend, f.forEach = this.forEach, f.implement = this.implement, f.prototype = d, f.toString = this.toString, f.valueOf = function (a) { return "object" == a ? f : e.valueOf() }, c.call(f, b), "function" == typeof f.init && f.init(), f }, Base.prototype = { extend: function (a, b) { if (arguments.length > 1) { var c = this[a]; if (c && "function" == typeof b && (!c.valueOf || c.valueOf() != b.valueOf()) && /\bbase\b/.test(b)) { var d = b.valueOf(); b = function () { var a = this.base || Base.prototype.base; this.base = c; var b = d.apply(this, arguments); return this.base = a, b }, b.valueOf = function (a) { return "object" == a ? b : d }, b.toString = Base.toString } this[a] = b } else if (a) { var e = Base.prototype.extend; Base._prototyping || "function" == typeof this || (e = this.extend || e); for (var f = { toSource: null }, g = ["constructor", "toString", "valueOf"], h = Base._prototyping ? 0 : 1; i = g[h++];)a[i] != f[i] && e.call(this, i, a[i]); for (var i in a) f[i] || e.call(this, i, a[i]) } return this } }, Base = Base.extend({ constructor: function () { this.extend(arguments[0]) } }, { ancestor: Object, version: "1.1", forEach: function (a, b, c) { for (var d in a) void 0 === this.prototype[d] && b.call(c, a[d], d, a) }, implement: function () { for (var a = 0; a < arguments.length; a++)"function" == typeof arguments[a] ? arguments[a](this.prototype) : this.prototype.extend(arguments[a]); return this }, toString: function () { return String(this.valueOf()) } }); var FlipClock; !function (a) { "use strict"; FlipClock = function (a, b, c) { return b instanceof Object && b instanceof Date == !1 && (c = b, b = 0), new FlipClock.Factory(a, b, c) }, FlipClock.Lang = {}, FlipClock.Base = Base.extend({ buildDate: "2014-12-12", version: "0.7.7", constructor: function (b, c) { "object" != typeof b && (b = {}), "object" != typeof c && (c = {}), this.setOptions(a.extend(!0, {}, b, c)) }, callback: function (a) { if ("function" == typeof a) { for (var b = [], c = 1; c <= arguments.length; c++)arguments[c] && b.push(arguments[c]); a.apply(this, b) } }, log: function (a) { window.console && console.log && console.log(a) }, getOption: function (a) { return this[a] ? this[a] : !1 }, getOptions: function () { return this }, setOption: function (a, b) { this[a] = b }, setOptions: function (a) { for (var b in a) "undefined" != typeof a[b] && this.setOption(b, a[b]) } }) }(jQuery), function (a) { "use strict"; FlipClock.Face = FlipClock.Base.extend({ autoStart: !0, dividers: [], factory: !1, lists: [], constructor: function (a, b) { this.dividers = [], this.lists = [], this.base(b), this.factory = a }, build: function () { this.autoStart && this.start() }, createDivider: function (b, c, d) { "boolean" != typeof c && c || (d = c, c = b); var e = ['<span class="' + this.factory.classes.dot + ' top"></span>', '<span class="' + this.factory.classes.dot + ' bottom"></span>'].join(""); d && (e = ""), b = this.factory.localize(b); var f = ['<span class="' + this.factory.classes.divider + " " + (c ? c : "").toLowerCase() + '">', '<span class="' + this.factory.classes.label + '">' + (b ? b : "") + "</span>", e, "</span>"], g = a(f.join("")); return this.dividers.push(g), g }, createList: function (a, b) { "object" == typeof a && (b = a, a = 0); var c = new FlipClock.List(this.factory, a, b); return this.lists.push(c), c }, reset: function () { this.factory.time = new FlipClock.Time(this.factory, this.factory.original ? Math.round(this.factory.original) : 0, { minimumDigits: this.factory.minimumDigits }), this.flip(this.factory.original, !1) }, appendDigitToClock: function (a) { a.$el.append(!1) }, addDigit: function (a) { var b = this.createList(a, { classes: { active: this.factory.classes.active, before: this.factory.classes.before, flip: this.factory.classes.flip } }); this.appendDigitToClock(b) }, start: function () { }, stop: function () { }, autoIncrement: function () { this.factory.countdown ? this.decrement() : this.increment() }, increment: function () { this.factory.time.addSecond() }, decrement: function () { 0 == this.factory.time.getTimeSeconds() ? this.factory.stop() : this.factory.time.subSecond() }, flip: function (b, c) { var d = this; a.each(b, function (a, b) { var e = d.lists[a]; e ? (c || b == e.digit || e.play(), e.select(b)) : d.addDigit(b) }) } }) }(jQuery), function (a) { "use strict"; FlipClock.Factory = FlipClock.Base.extend({ animationRate: 1e3, autoStart: !0, callbacks: { destroy: !1, create: !1, init: !1, interval: !1, start: !1, stop: !1, reset: !1 }, classes: { active: "flip-clock-active", before: "flip-clock-before", divider: "flip-clock-divider", dot: "flip-clock-dot", label: "flip-clock-label", flip: "flip", play: "play", wrapper: "flip-clock-wrapper" }, clockFace: "HourlyCounter", countdown: !1, defaultClockFace: "HourlyCounter", defaultLanguage: "english", $el: !1, face: !0, lang: !1, language: "english", minimumDigits: 0, original: !1, running: !1, time: !1, timer: !1, $wrapper: !1, constructor: function (b, c, d) { d || (d = {}), this.lists = [], this.running = !1, this.base(d), this.$el = a(b).addClass(this.classes.wrapper), this.$wrapper = this.$el, this.original = c instanceof Date ? c : c ? Math.round(c) : 0, this.time = new FlipClock.Time(this, this.original, { minimumDigits: this.minimumDigits, animationRate: this.animationRate }), this.timer = new FlipClock.Timer(this, d), this.loadLanguage(this.language), this.loadClockFace(this.clockFace, d), this.autoStart && this.start() }, loadClockFace: function (a, b) { var c, d = "Face", e = !1; return a = a.ucfirst() + d, this.face.stop && (this.stop(), e = !0), this.$el.html(""), this.time.minimumDigits = this.minimumDigits, c = FlipClock[a] ? new FlipClock[a](this, b) : new FlipClock[this.defaultClockFace + d](this, b), c.build(), this.face = c, e && this.start(), this.face }, loadLanguage: function (a) { var b; return b = FlipClock.Lang[a.ucfirst()] ? FlipClock.Lang[a.ucfirst()] : FlipClock.Lang[a] ? FlipClock.Lang[a] : FlipClock.Lang[this.defaultLanguage], this.lang = b }, localize: function (a, b) { var c = this.lang; if (!a) return null; var d = a.toLowerCase(); return "object" == typeof b && (c = b), c && c[d] ? c[d] : a }, start: function (a) { var b = this; b.running || b.countdown && !(b.countdown && b.time.time > 0) ? b.log("Trying to start timer when countdown already at 0") : (b.face.start(b.time), b.timer.start(function () { b.flip(), "function" == typeof a && a() })) }, stop: function (a) { this.face.stop(), this.timer.stop(a); for (var b in this.lists) this.lists.hasOwnProperty(b) && this.lists[b].stop() }, reset: function (a) { this.timer.reset(a), this.face.reset() }, setTime: function (a) { this.time.time = a, this.flip(!0) }, getTime: function (a) { return this.time }, setCountdown: function (a) { var b = this.running; this.countdown = a ? !0 : !1, b && (this.stop(), this.start()) }, flip: function (a) { this.face.flip(!1, a) } }) }(jQuery), function (a) { "use strict"; FlipClock.List = FlipClock.Base.extend({ digit: 0, classes: { active: "flip-clock-active", before: "flip-clock-before", flip: "flip" }, factory: !1, $el: !1, $obj: !1, items: [], lastDigit: 0, constructor: function (a, b, c) { this.factory = a, this.digit = b, this.lastDigit = b, this.$el = this.createList(), this.$obj = this.$el, b > 0 && this.select(b), this.factory.$el.append(this.$el) }, select: function (a) { if ("undefined" == typeof a ? a = this.digit : this.digit = a, this.digit != this.lastDigit) { var b = this.$el.find("." + this.classes.before).removeClass(this.classes.before); this.$el.find("." + this.classes.active).removeClass(this.classes.active).addClass(this.classes.before), this.appendListItem(this.classes.active, this.digit), b.remove(), this.lastDigit = this.digit } }, play: function () { this.$el.addClass(this.factory.classes.play) }, stop: function () { var a = this; setTimeout(function () { a.$el.removeClass(a.factory.classes.play) }, this.factory.timer.interval) }, createListItem: function (a, b) { return ['<li class="' + (a ? a : "") + '">', '<a href="#">', '<div class="up">', '<div class="shadow"></div>', '<div class="inn">' + (b ? b : "") + "</div>", "</div>", '<div class="down">', '<div class="shadow"></div>', '<div class="inn">' + (b ? b : "") + "</div>", "</div>", "</a>", "</li>"].join("") }, appendListItem: function (a, b) { var c = this.createListItem(a, b); this.$el.append(c) }, createList: function () { var b = this.getPrevDigit() ? this.getPrevDigit() : this.digit, c = a(['<ul class="' + this.classes.flip + " " + (this.factory.running ? this.factory.classes.play : "") + '">', this.createListItem(this.classes.before, b), this.createListItem(this.classes.active, this.digit), "</ul>"].join("")); return c }, getNextDigit: function () { return 9 == this.digit ? 0 : this.digit + 1 }, getPrevDigit: function () { return 0 == this.digit ? 9 : this.digit - 1 } }) }(jQuery), function (a) { "use strict"; String.prototype.ucfirst = function () { return this.substr(0, 1).toUpperCase() + this.substr(1) }, a.fn.FlipClock = function (b, c) { return new FlipClock(a(this), b, c) }, a.fn.flipClock = function (b, c) { return a.fn.FlipClock(b, c) } }(jQuery), function (a) { "use strict"; FlipClock.Time = FlipClock.Base.extend({ time: 0, factory: !1, minimumDigits: 0, constructor: function (a, b, c) { "object" != typeof c && (c = {}), c.minimumDigits || (c.minimumDigits = a.minimumDigits), this.base(c), this.factory = a, b && (this.time = b) }, convertDigitsToArray: function (a) { var b = []; a = a.toString(); for (var c = 0; c < a.length; c++)a[c].match(/^\d*$/g) && b.push(a[c]); return b }, digit: function (a) { var b = this.toString(), c = b.length; return b[c - a] ? b[c - a] : !1 }, digitize: function (b) { var c = []; if (a.each(b, function (a, b) { b = b.toString(), 1 == b.length && (b = "0" + b); for (var d = 0; d < b.length; d++)c.push(b.charAt(d)) }), c.length > this.minimumDigits && (this.minimumDigits = c.length), this.minimumDigits > c.length) for (var d = c.length; d < this.minimumDigits; d++)c.unshift("0"); return c }, getDateObject: function () { return this.time instanceof Date ? this.time : new Date((new Date).getTime() + 1e3 * this.getTimeSeconds()) }, getDayCounter: function (a) { var b = [this.getDays(), this.getHours(!0), this.getMinutes(!0)]; return a && b.push(this.getSeconds(!0)), this.digitize(b) }, getDays: function (a) { var b = this.getTimeSeconds() / 60 / 60 / 24; return a && (b %= 7), Math.floor(b) }, getHourCounter: function () { var a = this.digitize([this.getHours(), this.getMinutes(!0), this.getSeconds(!0)]); return a }, getHourly: function () { return this.getHourCounter() }, getHours: function (a) { var b = this.getTimeSeconds() / 60 / 60; return a && (b %= 24), Math.floor(b) }, getMilitaryTime: function (a, b) { "undefined" == typeof b && (b = !0), a || (a = this.getDateObject()); var c = [a.getHours(), a.getMinutes()]; return b === !0 && c.push(a.getSeconds()), this.digitize(c) }, getMinutes: function (a) { var b = this.getTimeSeconds() / 60; return a && (b %= 60), Math.floor(b) }, getMinuteCounter: function () { var a = this.digitize([this.getMinutes(), this.getSeconds(!0)]); return a }, getTimeSeconds: function (a) { return a || (a = new Date), this.time instanceof Date ? this.factory.countdown ? Math.max(this.time.getTime() / 1e3 - a.getTime() / 1e3, 0) : a.getTime() / 1e3 - this.time.getTime() / 1e3 : this.time }, getTime: function (a, b) { "undefined" == typeof b && (b = !0), a || (a = this.getDateObject()), console.log(a); var c = a.getHours(), d = [c > 12 ? c - 12 : 0 === c ? 12 : c, a.getMinutes()]; return b === !0 && d.push(a.getSeconds()), this.digitize(d) }, getSeconds: function (a) { var b = this.getTimeSeconds(); return a && (60 == b ? b = 0 : b %= 60), Math.ceil(b) }, getWeeks: function (a) { var b = this.getTimeSeconds() / 60 / 60 / 24 / 7; return a && (b %= 52), Math.floor(b) }, removeLeadingZeros: function (b, c) { var d = 0, e = []; return a.each(c, function (a, f) { b > a ? d += parseInt(c[a], 10) : e.push(c[a]) }), 0 === d ? e : c }, addSeconds: function (a) { this.time instanceof Date ? this.time.setSeconds(this.time.getSeconds() + a) : this.time += a }, addSecond: function () { this.addSeconds(1) }, subSeconds: function (a) { this.time instanceof Date ? this.time.setSeconds(this.time.getSeconds() - a) : this.time -= a }, subSecond: function () { this.subSeconds(1) }, toString: function () { return this.getTimeSeconds().toString() } }) }(jQuery), function (a) { "use strict"; FlipClock.Timer = FlipClock.Base.extend({ callbacks: { destroy: !1, create: !1, init: !1, interval: !1, start: !1, stop: !1, reset: !1 }, count: 0, factory: !1, interval: 1e3, animationRate: 1e3, constructor: function (a, b) { this.base(b), this.factory = a, this.callback(this.callbacks.init), this.callback(this.callbacks.create) }, getElapsed: function () { return this.count * this.interval }, getElapsedTime: function () { return new Date(this.time + this.getElapsed()) }, reset: function (a) { clearInterval(this.timer), this.count = 0, this._setInterval(a), this.callback(this.callbacks.reset) }, start: function (a) { this.factory.running = !0, this._createTimer(a), this.callback(this.callbacks.start) }, stop: function (a) { this.factory.running = !1, this._clearInterval(a), this.callback(this.callbacks.stop), this.callback(a) }, _clearInterval: function () { clearInterval(this.timer) }, _createTimer: function (a) { this._setInterval(a) }, _destroyTimer: function (a) { this._clearInterval(), this.timer = !1, this.callback(a), this.callback(this.callbacks.destroy) }, _interval: function (a) { this.callback(this.callbacks.interval), this.callback(a), this.count++ }, _setInterval: function (a) { var b = this; b._interval(a), b.timer = setInterval(function () { b._interval(a) }, this.interval) } }) }(jQuery), function (a) { FlipClock.TwentyFourHourClockFace = FlipClock.Face.extend({ constructor: function (a, b) { this.base(a, b) }, build: function (b) { var c = this, d = this.factory.$el.find("ul"); this.factory.time.time || (this.factory.original = new Date, this.factory.time = new FlipClock.Time(this.factory, this.factory.original)); var b = b ? b : this.factory.time.getMilitaryTime(!1, this.showSeconds); b.length > d.length && a.each(b, function (a, b) { c.createList(b) }), this.createDivider(), this.createDivider(), a(this.dividers[0]).insertBefore(this.lists[this.lists.length - 2].$el), a(this.dividers[1]).insertBefore(this.lists[this.lists.length - 4].$el), this.base() }, flip: function (a, b) { this.autoIncrement(), a = a ? a : this.factory.time.getMilitaryTime(!1, this.showSeconds), this.base(a, b) } }) }(jQuery), function (a) { FlipClock.CounterFace = FlipClock.Face.extend({ shouldAutoIncrement: !1, constructor: function (a, b) { "object" != typeof b && (b = {}), a.autoStart = b.autoStart ? !0 : !1, b.autoStart && (this.shouldAutoIncrement = !0), a.increment = function () { a.countdown = !1, a.setTime(a.getTime().getTimeSeconds() + 1) }, a.decrement = function () { a.countdown = !0; var b = a.getTime().getTimeSeconds(); b > 0 && a.setTime(b - 1) }, a.setValue = function (b) { a.setTime(b) }, a.setCounter = function (b) { a.setTime(b) }, this.base(a, b) }, build: function () { var b = this, c = this.factory.$el.find("ul"), d = this.factory.getTime().digitize([this.factory.getTime().time]); d.length > c.length && a.each(d, function (a, c) { var d = b.createList(c); d.select(c) }), a.each(this.lists, function (a, b) { b.play() }), this.base() }, flip: function (a, b) { this.shouldAutoIncrement && this.autoIncrement(), a || (a = this.factory.getTime().digitize([this.factory.getTime().time])), this.base(a, b) }, reset: function () { this.factory.time = new FlipClock.Time(this.factory, this.factory.original ? Math.round(this.factory.original) : 0), this.flip() } }) }(jQuery), function (a) { FlipClock.DailyCounterFace = FlipClock.Face.extend({ showSeconds: !0, constructor: function (a, b) { this.base(a, b) }, build: function (b) { var c = this, d = this.factory.$el.find("ul"), e = 0; b = b ? b : this.factory.time.getDayCounter(this.showSeconds), b.length > d.length && a.each(b, function (a, b) { c.createList(b) }), this.showSeconds ? a(this.createDivider("Seconds")).insertBefore(this.lists[this.lists.length - 2].$el) : e = 2, a(this.createDivider("Minutes")).insertBefore(this.lists[this.lists.length - 4 + e].$el), a(this.createDivider("Hours")).insertBefore(this.lists[this.lists.length - 6 + e].$el), a(this.createDivider("Days", !0)).insertBefore(this.lists[0].$el), this.base() }, flip: function (a, b) { a || (a = this.factory.time.getDayCounter(this.showSeconds)), this.autoIncrement(), this.base(a, b) } }) }(jQuery), function (a) { FlipClock.HourlyCounterFace = FlipClock.Face.extend({ constructor: function (a, b) { this.base(a, b) }, build: function (b, c) { var d = this, e = this.factory.$el.find("ul"); c = c ? c : this.factory.time.getHourCounter(), c.length > e.length && a.each(c, function (a, b) { d.createList(b) }), a(this.createDivider("Seconds")).insertBefore(this.lists[this.lists.length - 2].$el), a(this.createDivider("Minutes")).insertBefore(this.lists[this.lists.length - 4].$el), b || a(this.createDivider("Hours", !0)).insertBefore(this.lists[0].$el), this.base() }, flip: function (a, b) { a || (a = this.factory.time.getHourCounter()), this.autoIncrement(), this.base(a, b) }, appendDigitToClock: function (a) { this.base(a), this.dividers[0].insertAfter(this.dividers[0].next()) } }) }(jQuery), function (a) { FlipClock.MinuteCounterFace = FlipClock.HourlyCounterFace.extend({ clearExcessDigits: !1, constructor: function (a, b) { this.base(a, b) }, build: function () { this.base(!0, this.factory.time.getMinuteCounter()) }, flip: function (a, b) { a || (a = this.factory.time.getMinuteCounter()), this.base(a, b) } }) }(jQuery), function (a) { FlipClock.TwelveHourClockFace = FlipClock.TwentyFourHourClockFace.extend({ meridium: !1, meridiumText: "AM", build: function () { var b = this.factory.time.getTime(!1, this.showSeconds); this.base(b), this.meridiumText = this.getMeridium(), this.meridium = a(['<ul class="flip-clock-meridium">', "<li>", '<a href="#">' + this.meridiumText + "</a>", "</li>", "</ul>"].join("")), this.meridium.insertAfter(this.lists[this.lists.length - 1].$el) }, flip: function (a, b) { this.meridiumText != this.getMeridium() && (this.meridiumText = this.getMeridium(), this.meridium.find("a").html(this.meridiumText)), this.base(this.factory.time.getTime(!1, this.showSeconds), b) }, getMeridium: function () { return (new Date).getHours() >= 12 ? "PM" : "AM" }, isPM: function () { return "PM" == this.getMeridium() ? !0 : !1 }, isAM: function () { return "AM" == this.getMeridium() ? !0 : !1 } }) }(jQuery), function (a) { FlipClock.Lang.Arabic = { years: "Ø³Ù†ÙˆØ§Øª", months: "Ø´Ù‡ÙˆØ±", days: "Ø£ÙŠØ§Ù…", hours: "Ø³Ø§Ø¹Ø§Øª", minutes: "Ø¯Ù‚Ø§Ø¦Ù‚", seconds: "Ø«ÙˆØ§Ù†ÙŠ" }, FlipClock.Lang.ar = FlipClock.Lang.Arabic, FlipClock.Lang["ar-ar"] = FlipClock.Lang.Arabic, FlipClock.Lang.arabic = FlipClock.Lang.Arabic }(jQuery), function (a) { FlipClock.Lang.Danish = { years: "Ã…r", months: "MÃ¥neder", days: "Dage", hours: "Timer", minutes: "Minutter", seconds: "Sekunder" }, FlipClock.Lang.da = FlipClock.Lang.Danish, FlipClock.Lang["da-dk"] = FlipClock.Lang.Danish, FlipClock.Lang.danish = FlipClock.Lang.Danish }(jQuery), function (a) { FlipClock.Lang.German = { years: "Jahre", months: "Monate", days: "Tage", hours: "Stunden", minutes: "Minuten", seconds: "Sekunden" }, FlipClock.Lang.de = FlipClock.Lang.German, FlipClock.Lang["de-de"] = FlipClock.Lang.German, FlipClock.Lang.german = FlipClock.Lang.German }(jQuery), function (a) { FlipClock.Lang.English = { years: "Years", months: "Months", days: "Days", hours: "Hours", minutes: "Minutes", seconds: "Seconds" }, FlipClock.Lang.en = FlipClock.Lang.English, FlipClock.Lang["en-us"] = FlipClock.Lang.English, FlipClock.Lang.english = FlipClock.Lang.English }(jQuery), function (a) { FlipClock.Lang.Spanish = { years: "AÃ±os", months: "Meses", days: "DÃ­as", hours: "Horas", minutes: "Minutos", seconds: "Segundos" }, FlipClock.Lang.es = FlipClock.Lang.Spanish, FlipClock.Lang["es-es"] = FlipClock.Lang.Spanish, FlipClock.Lang.spanish = FlipClock.Lang.Spanish }(jQuery), function (a) { FlipClock.Lang.Finnish = { years: "Vuotta", months: "Kuukautta", days: "PÃ¤ivÃ¤Ã¤", hours: "Tuntia", minutes: "Minuuttia", seconds: "Sekuntia" }, FlipClock.Lang.fi = FlipClock.Lang.Finnish, FlipClock.Lang["fi-fi"] = FlipClock.Lang.Finnish, FlipClock.Lang.finnish = FlipClock.Lang.Finnish }(jQuery), function (a) { FlipClock.Lang.French = { years: "Ans", months: "Mois", days: "Jours", hours: "Heures", minutes: "Minutes", seconds: "Secondes" }, FlipClock.Lang.fr = FlipClock.Lang.French, FlipClock.Lang["fr-ca"] = FlipClock.Lang.French, FlipClock.Lang.french = FlipClock.Lang.French }(jQuery), function (a) { FlipClock.Lang.Italian = { years: "Anni", months: "Mesi", days: "Giorni", hours: "Ore", minutes: "Minuti", seconds: "Secondi" }, FlipClock.Lang.it = FlipClock.Lang.Italian, FlipClock.Lang["it-it"] = FlipClock.Lang.Italian, FlipClock.Lang.italian = FlipClock.Lang.Italian }(jQuery), function (a) { FlipClock.Lang.Latvian = { years: "Gadi", months: "MÄ“neÅ¡i", days: "Dienas", hours: "Stundas", minutes: "MinÅ«tes", seconds: "Sekundes" }, FlipClock.Lang.lv = FlipClock.Lang.Latvian, FlipClock.Lang["lv-lv"] = FlipClock.Lang.Latvian, FlipClock.Lang.latvian = FlipClock.Lang.Latvian }(jQuery), function (a) { FlipClock.Lang.Dutch = { years: "Jaren", months: "Maanden", days: "Dagen", hours: "Uren", minutes: "Minuten", seconds: "Seconden" }, FlipClock.Lang.nl = FlipClock.Lang.Dutch, FlipClock.Lang["nl-be"] = FlipClock.Lang.Dutch, FlipClock.Lang.dutch = FlipClock.Lang.Dutch }(jQuery), function (a) { FlipClock.Lang.Norwegian = { years: "Ã…r", months: "MÃ¥neder", days: "Dager", hours: "Timer", minutes: "Minutter", seconds: "Sekunder" }, FlipClock.Lang.no = FlipClock.Lang.Norwegian, FlipClock.Lang.nb = FlipClock.Lang.Norwegian, FlipClock.Lang["no-nb"] = FlipClock.Lang.Norwegian, FlipClock.Lang.norwegian = FlipClock.Lang.Norwegian }(jQuery), function (a) { FlipClock.Lang.Portuguese = { years: "Anos", months: "Meses", days: "Dias", hours: "Horas", minutes: "Minutos", seconds: "Segundos" }, FlipClock.Lang.pt = FlipClock.Lang.Portuguese, FlipClock.Lang["pt-br"] = FlipClock.Lang.Portuguese, FlipClock.Lang.portuguese = FlipClock.Lang.Portuguese }(jQuery), function (a) { FlipClock.Lang.Russian = { years: "Ð»ÐµÑ‚", months: "Ð¼ÐµÑÑÑ†ÐµÐ²", days: "Ð´Ð½ÐµÐ¹", hours: "Ñ‡Ð°ÑÐ¾Ð²", minutes: "Ð¼Ð¸Ð½ÑƒÑ‚", seconds: "ÑÐµÐºÑƒÐ½Ð´" }, FlipClock.Lang.ru = FlipClock.Lang.Russian, FlipClock.Lang["ru-ru"] = FlipClock.Lang.Russian, FlipClock.Lang.russian = FlipClock.Lang.Russian }(jQuery), function (a) { FlipClock.Lang.Swedish = { years: "Ã…r", months: "MÃ¥nader", days: "Dagar", hours: "Timmar", minutes: "Minuter", seconds: "Sekunder" }, FlipClock.Lang.sv = FlipClock.Lang.Swedish, FlipClock.Lang["sv-se"] = FlipClock.Lang.Swedish, FlipClock.Lang.swedish = FlipClock.Lang.Swedish }(jQuery), function (a) { FlipClock.Lang.Chinese = { years: "å¹´", months: "æœˆ", days: "æ—¥", hours: "æ—¶", minutes: "åˆ†", seconds: "ç§’" }, FlipClock.Lang.zh = FlipClock.Lang.Chinese, FlipClock.Lang["zh-cn"] = FlipClock.Lang.Chinese, FlipClock.Lang.chinese = FlipClock.Lang.Chinese }(jQuery); !function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.AOS = t() : e.AOS = t() }(this, function () { return function (e) { function t(o) { if (n[o]) return n[o].exports; var i = n[o] = { exports: {}, id: o, loaded: !1 }; return e[o].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports } var n = {}; return t.m = e, t.c = n, t.p = "dist/", t(0) }([function (e, t, n) { "use strict"; function o(e) { return e && e.__esModule ? e : { default: e } } var i = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]) } return e }, r = n(1), a = (o(r), n(6)), u = o(a), c = n(7), f = o(c), s = n(8), d = o(s), l = n(9), p = o(l), m = n(10), b = o(m), v = n(11), y = o(v), g = n(14), h = o(g), w = [], k = !1, x = document.all && !window.atob, j = { offset: 120, delay: 0, easing: "ease", duration: 400, disable: !1, once: !1, startEvent: "DOMContentLoaded" }, O = function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (e && (k = !0), k) return w = (0, y.default)(w, j), (0, b.default)(w, j.once), w }, S = function () { w = (0, h.default)(), O() }, _ = function () { w.forEach(function (e, t) { e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay") }) }, E = function (e) { return e === !0 || "mobile" === e && p.default.mobile() || "phone" === e && p.default.phone() || "tablet" === e && p.default.tablet() || "function" == typeof e && e() === !0 }, z = function (e) { return j = i(j, e), w = (0, h.default)(), E(j.disable) || x ? _() : (document.querySelector("body").setAttribute("data-aos-easing", j.easing), document.querySelector("body").setAttribute("data-aos-duration", j.duration), document.querySelector("body").setAttribute("data-aos-delay", j.delay), "DOMContentLoaded" === j.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 ? O(!0) : "load" === j.startEvent ? window.addEventListener(j.startEvent, function () { O(!0) }) : document.addEventListener(j.startEvent, function () { O(!0) }), window.addEventListener("resize", (0, f.default)(O, 50, !0)), window.addEventListener("orientationchange", (0, f.default)(O, 50, !0)), window.addEventListener("scroll", (0, u.default)(function () { (0, b.default)(w, j.once) }, 99)), document.addEventListener("DOMNodeRemoved", function (e) { var t = e.target; t && 1 === t.nodeType && t.hasAttribute && t.hasAttribute("data-aos") && (0, f.default)(S, 50, !0) }), (0, d.default)("[data-aos]", S), w) }; e.exports = { init: z, refresh: O, refreshHard: S } }, function (e, t) { }, , , , , function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function o(t) { var n = b, o = v; return b = v = void 0, k = t, g = e.apply(o, n) } function r(e) { return k = e, h = setTimeout(s, t), S ? o(e) : g } function a(e) { var n = e - w, o = e - k, i = t - n; return _ ? j(i, y - o) : i } function c(e) { var n = e - w, o = e - k; return void 0 === w || n >= t || n < 0 || _ && o >= y } function s() { var e = O(); return c(e) ? d(e) : void (h = setTimeout(s, a(e))) } function d(e) { return h = void 0, E && b ? o(e) : (b = v = void 0, g) } function l() { void 0 !== h && clearTimeout(h), k = 0, b = w = v = h = void 0 } function p() { return void 0 === h ? g : d(O()) } function m() { var e = O(), n = c(e); if (b = arguments, v = this, w = e, n) { if (void 0 === h) return r(w); if (_) return h = setTimeout(s, t), o(w) } return void 0 === h && (h = setTimeout(s, t)), g } var b, v, y, g, h, w, k = 0, S = !1, _ = !1, E = !0; if ("function" != typeof e) throw new TypeError(f); return t = u(t) || 0, i(n) && (S = !!n.leading, _ = "maxWait" in n, y = _ ? x(u(n.maxWait) || 0, t) : y, E = "trailing" in n ? !!n.trailing : E), m.cancel = l, m.flush = p, m } function o(e, t, o) { var r = !0, a = !0; if ("function" != typeof e) throw new TypeError(f); return i(o) && (r = "leading" in o ? !!o.leading : r, a = "trailing" in o ? !!o.trailing : a), n(e, t, { leading: r, maxWait: t, trailing: a }) } function i(e) { var t = "undefined" == typeof e ? "undefined" : c(e); return !!e && ("object" == t || "function" == t) } function r(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : c(e)) } function a(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : c(e)) || r(e) && k.call(e) == d } function u(e) { if ("number" == typeof e) return e; if (a(e)) return s; if (i(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = i(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(l, ""); var n = m.test(e); return n || b.test(e) ? v(e.slice(2), n ? 2 : 8) : p.test(e) ? s : +e } var c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, f = "Expected a function", s = NaN, d = "[object Symbol]", l = /^\s+|\s+$/g, p = /^[-+]0x[0-9a-f]+$/i, m = /^0b[01]+$/i, b = /^0o[0-7]+$/i, v = parseInt, y = "object" == ("undefined" == typeof t ? "undefined" : c(t)) && t && t.Object === Object && t, g = "object" == ("undefined" == typeof self ? "undefined" : c(self)) && self && self.Object === Object && self, h = y || g || Function("return this")(), w = Object.prototype, k = w.toString, x = Math.max, j = Math.min, O = function () { return h.Date.now() }; e.exports = o }).call(t, function () { return this }()) }, function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function i(t) { var n = b, o = v; return b = v = void 0, O = t, g = e.apply(o, n) } function r(e) { return O = e, h = setTimeout(s, t), S ? i(e) : g } function u(e) { var n = e - w, o = e - O, i = t - n; return _ ? x(i, y - o) : i } function f(e) { var n = e - w, o = e - O; return void 0 === w || n >= t || n < 0 || _ && o >= y } function s() { var e = j(); return f(e) ? d(e) : void (h = setTimeout(s, u(e))) } function d(e) { return h = void 0, E && b ? i(e) : (b = v = void 0, g) } function l() { void 0 !== h && clearTimeout(h), O = 0, b = w = v = h = void 0 } function p() { return void 0 === h ? g : d(j()) } function m() { var e = j(), n = f(e); if (b = arguments, v = this, w = e, n) { if (void 0 === h) return r(w); if (_) return h = setTimeout(s, t), i(w) } return void 0 === h && (h = setTimeout(s, t)), g } var b, v, y, g, h, w, O = 0, S = !1, _ = !1, E = !0; if ("function" != typeof e) throw new TypeError(c); return t = a(t) || 0, o(n) && (S = !!n.leading, _ = "maxWait" in n, y = _ ? k(a(n.maxWait) || 0, t) : y, E = "trailing" in n ? !!n.trailing : E), m.cancel = l, m.flush = p, m } function o(e) { var t = "undefined" == typeof e ? "undefined" : u(e); return !!e && ("object" == t || "function" == t) } function i(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : u(e)) } function r(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : u(e)) || i(e) && w.call(e) == s } function a(e) { if ("number" == typeof e) return e; if (r(e)) return f; if (o(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = o(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(d, ""); var n = p.test(e); return n || m.test(e) ? b(e.slice(2), n ? 2 : 8) : l.test(e) ? f : +e } var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, c = "Expected a function", f = NaN, s = "[object Symbol]", d = /^\s+|\s+$/g, l = /^[-+]0x[0-9a-f]+$/i, p = /^0b[01]+$/i, m = /^0o[0-7]+$/i, b = parseInt, v = "object" == ("undefined" == typeof t ? "undefined" : u(t)) && t && t.Object === Object && t, y = "object" == ("undefined" == typeof self ? "undefined" : u(self)) && self && self.Object === Object && self, g = v || y || Function("return this")(), h = Object.prototype, w = h.toString, k = Math.max, x = Math.min, j = function () { return g.Date.now() }; e.exports = n }).call(t, function () { return this }()) }, function (e, t) { "use strict"; function n(e, t) { a.push({ selector: e, fn: t }), !u && r && (u = new r(o), u.observe(i.documentElement, { childList: !0, subtree: !0, removedNodes: !0 })), o() } function o() { for (var e, t, n = 0, o = a.length; n < o; n++) { e = a[n], t = i.querySelectorAll(e.selector); for (var r, u = 0, c = t.length; u < c; u++)r = t[u], r.ready || (r.ready = !0, e.fn.call(r, r)) } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = window.document, r = window.MutationObserver || window.WebKitMutationObserver, a = [], u = void 0; t.default = n }, function (e, t) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function o() { return navigator.userAgent || navigator.vendor || window.opera || "" } Object.defineProperty(t, "__esModule", { value: !0 }); var i = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var o = t[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } return function (t, n, o) { return n && e(t.prototype, n), o && e(t, o), t } }(), r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, u = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i, c = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, f = function () { function e() { n(this, e) } return i(e, [{ key: "phone", value: function () { var e = o(); return !(!r.test(e) && !a.test(e.substr(0, 4))) } }, { key: "mobile", value: function () { var e = o(); return !(!u.test(e) && !c.test(e.substr(0, 4))) } }, { key: "tablet", value: function () { return this.mobile() && !this.phone() } }]), e }(); t.default = new f }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e, t, n) { var o = e.node.getAttribute("data-aos-once"); t > e.position ? e.node.classList.add("aos-animate") : "undefined" != typeof o && ("false" === o || !n && "true" !== o) && e.node.classList.remove("aos-animate") }, o = function (e, t) { var o = window.pageYOffset, i = window.innerHeight; e.forEach(function (e, r) { n(e, i + o, t) }) }; t.default = o }, function (e, t, n) { "use strict"; function o(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(12), r = o(i), a = function (e, t) { return e.forEach(function (e, n) { e.node.classList.add("aos-init"), e.position = (0, r.default)(e.node, t.offset) }), e }; t.default = a }, function (e, t, n) { "use strict"; function o(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(13), r = o(i), a = function (e, t) { var n = 0, o = 0, i = window.innerHeight, a = { offset: e.getAttribute("data-aos-offset"), anchor: e.getAttribute("data-aos-anchor"), anchorPlacement: e.getAttribute("data-aos-anchor-placement") }; switch (a.offset && !isNaN(a.offset) && (o = parseInt(a.offset)), a.anchor && document.querySelectorAll(a.anchor) && (e = document.querySelectorAll(a.anchor)[0]), n = (0, r.default)(e).top, a.anchorPlacement) { case "top-bottom": break; case "center-bottom": n += e.offsetHeight / 2; break; case "bottom-bottom": n += e.offsetHeight; break; case "top-center": n += i / 2; break; case "bottom-center": n += i / 2 + e.offsetHeight; break; case "center-center": n += i / 2 + e.offsetHeight / 2; break; case "top-top": n += i; break; case "bottom-top": n += e.offsetHeight + i; break; case "center-top": n += e.offsetHeight / 2 + i }return a.anchorPlacement || a.offset || isNaN(t) || (o = t), n + o }; t.default = a }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);)t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent; return { top: n, left: t } }; t.default = n }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { e = e || document.querySelectorAll("[data-aos]"); var t = []; return [].forEach.call(e, function (e, n) { t.push({ node: e }) }), t }; t.default = n }]) }); !function (t) { "use strict"; "function" == typeof define && define.amd ? define(["jquery"], t) : "undefined" != typeof module && module.exports ? module.exports = t(require("jquery")) : t(jQuery) }(function (t) { var e = -1, o = -1, n = function (t) { return parseFloat(t) || 0 }, a = function (e) { var o = 1, a = t(e), i = null, r = []; return a.each(function () { var e = t(this), a = e.offset().top - n(e.css("margin-top")), s = r.length > 0 ? r[r.length - 1] : null; null === s ? r.push(e) : Math.floor(Math.abs(i - a)) <= o ? r[r.length - 1] = s.add(e) : r.push(e), i = a }), r }, i = function (e) { var o = { byRow: !0, property: "height", target: null, remove: !1 }; return "object" == typeof e ? t.extend(o, e) : ("boolean" == typeof e ? o.byRow = e : "remove" === e && (o.remove = !0), o) }, r = t.fn.matchHeight = function (e) { var o = i(e); if (o.remove) { var n = this; return this.css(o.property, ""), t.each(r._groups, function (t, e) { e.elements = e.elements.not(n) }), this } return this.length <= 1 && !o.target ? this : (r._groups.push({ elements: this, options: o }), r._apply(this, o), this) }; r.version = "0.7.2", r._groups = [], r._throttle = 80, r._maintainScroll = !1, r._beforeUpdate = null, r._afterUpdate = null, r._rows = a, r._parse = n, r._parseOptions = i, r._apply = function (e, o) { var s = i(o), h = t(e), l = [h], c = t(window).scrollTop(), p = t("html").outerHeight(!0), u = h.parents().filter(":hidden"); return u.each(function () { var e = t(this); e.data("style-cache", e.attr("style")) }), u.css("display", "block"), s.byRow && !s.target && (h.each(function () { var e = t(this), o = e.css("display"); "inline-block" !== o && "flex" !== o && "inline-flex" !== o && (o = "block"), e.data("style-cache", e.attr("style")), e.css({ display: o, "padding-top": "0", "padding-bottom": "0", "margin-top": "0", "margin-bottom": "0", "border-top-width": "0", "border-bottom-width": "0", height: "100px", overflow: "hidden" }) }), l = a(h), h.each(function () { var e = t(this); e.attr("style", e.data("style-cache") || "") })), t.each(l, function (e, o) { var a = t(o), i = 0; if (s.target) i = s.target.outerHeight(!1); else { if (s.byRow && a.length <= 1) return void a.css(s.property, ""); a.each(function () { var e = t(this), o = e.attr("style"), n = e.css("display"); "inline-block" !== n && "flex" !== n && "inline-flex" !== n && (n = "block"); var a = { display: n }; a[s.property] = "", e.css(a), e.outerHeight(!1) > i && (i = e.outerHeight(!1)), o ? e.attr("style", o) : e.css("display", "") }) } a.each(function () { var e = t(this), o = 0; s.target && e.is(s.target) || ("border-box" !== e.css("box-sizing") && (o += n(e.css("border-top-width")) + n(e.css("border-bottom-width")), o += n(e.css("padding-top")) + n(e.css("padding-bottom"))), e.css(s.property, i - o + "px")) }) }), u.each(function () { var e = t(this); e.attr("style", e.data("style-cache") || null) }), r._maintainScroll && t(window).scrollTop(c / p * t("html").outerHeight(!0)), this }, r._applyDataApi = function () { var e = {}; t("[data-match-height], [data-mh]").each(function () { var o = t(this), n = o.attr("data-mh") || o.attr("data-match-height"); n in e ? e[n] = e[n].add(o) : e[n] = o }), t.each(e, function () { this.matchHeight(!0) }) }; var s = function (e) { r._beforeUpdate && r._beforeUpdate(e, r._groups), t.each(r._groups, function () { r._apply(this.elements, this.options) }), r._afterUpdate && r._afterUpdate(e, r._groups) }; r._update = function (n, a) { if (a && "resize" === a.type) { var i = t(window).width(); if (i === e) return; e = i; } n ? o === -1 && (o = setTimeout(function () { s(a), o = -1 }, r._throttle)) : s(a) }, t(r._applyDataApi); var h = t.fn.on ? "on" : "bind"; t(window)[h]("load", function (t) { r._update(!1, t) }), t(window)[h]("resize orientationchange", function (t) { r._update(!0, t) }) }); (function ($) {
    var useWindow = window; if (!Object.keys) {
        Object.keys = (function () {
            'use strict'; var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'), dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'], dontEnumsLength = dontEnums.length; return function (obj) {
                if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) { throw new TypeError('Object.keys called on non-object'); }
                var result = [], prop, i; for (prop in obj) { if (hasOwnProperty.call(obj, prop)) { result.push(prop); } }
                if (hasDontEnumBug) { for (i = 0; i < dontEnumsLength; i++) { if (hasOwnProperty.call(obj, dontEnums[i])) { result.push(dontEnums[i]); } } }
                return result;
            };
        }());
    }
    var limited_mode = false; var tick_duration = 200; var debug = (location.hash === "#debug"); function debug_log(msg) { if (debug) { console.log(msg); } }
    var allUnits = ["Days", "Hours", "Minutes", "Seconds"]; var nextUnits = { Seconds: "Minutes", Minutes: "Hours", Hours: "Days", Days: "Years" }; var secondsIn = { Seconds: 1, Minutes: 60, Hours: 3600, Days: 86400, Months: 2678400, Years: 31536000 }; function hexToRgb(hex) {
        var rgba = /^rgba?\(([\d]+),([\d]+),([\d]+)(,([\d\.]+))?\)$/; if (rgba.test(hex)) { var result = rgba.exec(hex); return { r: parseInt(result[1]), g: parseInt(result[2]), b: parseInt(result[3]), a: parseInt(result[5] ? result[5] : 1) }; }
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; hex = hex.replace(shorthandRegex, function (m, r, g, b) { return r + r + g + g + b + b; }); var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
    }
    function isCanvasSupported() { var elem = document.createElement('canvas'); return !!(elem.getContext && elem.getContext('2d')); }
    function s4() { return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); }
    function guid() {
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (elt) {
            var len = this.length >>> 0; var from = Number(arguments[1]) || 0; from = (from < 0) ? Math.ceil(from) : Math.floor(from); if (from < 0)
                from += len; for (; from < len; from++) {
                if (from in this && this[from] === elt)
                    return from;
            }
            return -1;
        };
    }
    function parse_date(str) {
        var match = str.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}\s[0-9]{1,2}:[0-9]{2}:[0-9]{2}$/); if (match !== null && match.length > 0) { var parts = str.split(" "); var date = parts[0].split("-"); var time = parts[1].split(":"); return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]); }
        var d = Date.parse(str); if (!isNaN(d))
            return d; d = Date.parse(str.replace(/-/g, '/').replace('T', ' ')); if (!isNaN(d))
            return d; return new Date();
    }
    function parse_times(diff, old_diff, total_duration, units, floor) {
        var raw_time = {}; var raw_old_time = {}; var time = {}; var pct = {}; var old_pct = {}; var old_time = {}; var greater_unit = null; for (var i = 0; i < units.length; i++) {
            var unit = units[i]; var maxUnits; if (greater_unit === null) { maxUnits = total_duration / secondsIn[unit]; }
            else { maxUnits = secondsIn[greater_unit] / secondsIn[unit]; }
            var curUnits = (diff / secondsIn[unit]); var oldUnits = (old_diff / secondsIn[unit]); if (floor) { if (curUnits > 0) curUnits = Math.floor(curUnits); else curUnits = Math.ceil(curUnits); if (oldUnits > 0) oldUnits = Math.floor(oldUnits); else oldUnits = Math.ceil(oldUnits); }
            if (unit !== "Days") { curUnits = curUnits % maxUnits; oldUnits = oldUnits % maxUnits; }
            raw_time[unit] = curUnits; time[unit] = Math.abs(curUnits); raw_old_time[unit] = oldUnits; old_time[unit] = Math.abs(oldUnits); pct[unit] = Math.abs(curUnits) / maxUnits; old_pct[unit] = Math.abs(oldUnits) / maxUnits; greater_unit = unit;
        }
        return { raw_time: raw_time, raw_old_time: raw_old_time, time: time, old_time: old_time, pct: pct, old_pct: old_pct };
    }
    var TC_Instance_List = {}; function updateUsedWindow() {
        if (typeof useWindow.TC_Instance_List !== "undefined") { TC_Instance_List = useWindow.TC_Instance_List; }
        else { useWindow.TC_Instance_List = TC_Instance_List; }
        initializeAnimationFrameHandler(useWindow);
    }; function initializeAnimationFrameHandler(w) {
        var vendors = ['webkit', 'moz']; for (var x = 0; x < vendors.length && !w.requestAnimationFrame; ++x) { w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']; w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame']; }
        if (!w.requestAnimationFrame || !w.cancelAnimationFrame) {
            w.requestAnimationFrame = function (callback, element, instance) {
                if (typeof instance === "undefined")
                    instance = { data: { last_frame: 0 } }; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - instance.data.last_frame)); var id = w.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall); instance.data.last_frame = currTime + timeToCall; return id;
            }; w.cancelAnimationFrame = function (id) { clearTimeout(id); };
        }
    }; var TC_Instance = function (element, options) { this.element = element; this.container; this.listeners = null; this.data = { paused: false, last_frame: 0, animation_frame: null, interval_fallback: null, timer: false, total_duration: null, prev_time: null, drawn_units: [], text_elements: { Days: null, Hours: null, Minutes: null, Seconds: null }, attributes: { canvas: null, context: null, item_size: null, line_width: null, radius: null, outer_radius: null }, state: { fading: { Days: false, Hours: false, Minutes: false, Seconds: false } } }; this.config = null; this.setOptions(options); this.initialize(); }; TC_Instance.prototype.clearListeners = function () { this.listeners = { all: [], visible: [] }; }; TC_Instance.prototype.addTime = function (seconds_to_add) {
        if (this.data.attributes.ref_date instanceof Date) { var d = this.data.attributes.ref_date; d.setSeconds(d.getSeconds() + seconds_to_add); }
        else if (!isNaN(this.data.attributes.ref_date)) { this.data.attributes.ref_date += (seconds_to_add * 1000); }
    }; TC_Instance.prototype.initialize = function (clear_listeners) {
        this.data.drawn_units = []; for (var i = 0; i < Object.keys(this.config.time).length; i++) { var unit = Object.keys(this.config.time)[i]; if (this.config.time[unit].show) { this.data.drawn_units.push(unit); } }
        $(this.element).children('div.time_circles').remove(); if (typeof clear_listeners === "undefined")
            clear_listeners = true; if (clear_listeners || this.listeners === null) { this.clearListeners(); }
        this.container = $("<div>"); this.container.addClass('time_circles'); this.container.appendTo(this.element); var height = this.element.offsetHeight; var width = this.element.offsetWidth; if (height === 0)
            height = $(this.element).height(); if (width === 0)
            width = $(this.element).width(); if (height === 0 && width > 0)
            height = width / this.data.drawn_units.length; else if (width === 0 && height > 0)
            width = height * this.data.drawn_units.length; var canvasElement = document.createElement('canvas'); canvasElement.width = width; canvasElement.height = height; this.data.attributes.canvas = $(canvasElement); this.data.attributes.canvas.appendTo(this.container); var canvasSupported = isCanvasSupported(); if (!canvasSupported && typeof G_vmlCanvasManager !== "undefined") { G_vmlCanvasManager.initElement(canvasElement); limited_mode = true; canvasSupported = true; }
        if (canvasSupported) { this.data.attributes.context = canvasElement.getContext('2d'); }
        this.data.attributes.item_size = Math.min(width / this.data.drawn_units.length, height); this.data.attributes.line_width = this.data.attributes.item_size * this.config.fg_width; this.data.attributes.radius = ((this.data.attributes.item_size * 0.8) - this.data.attributes.line_width) / 2; this.data.attributes.outer_radius = this.data.attributes.radius + 0.5 * Math.max(this.data.attributes.line_width, this.data.attributes.line_width * this.config.bg_width); var i = 0; for (var key in this.data.text_elements) {
            if (!this.config.time[key].show)
                continue; var textElement = $("<div>"); textElement.addClass('textDiv_' + key); textElement.css("top", Math.round(0.35 * this.data.attributes.item_size)); textElement.css("left", Math.round(i++ * this.data.attributes.item_size)); textElement.css("width", this.data.attributes.item_size); textElement.appendTo(this.container); var headerElement = $("<h4>"); headerElement.text(this.config.time[key].text); headerElement.css("font-size", Math.round(this.config.text_size * this.data.attributes.item_size)); headerElement.appendTo(textElement); var numberElement = $("<span>"); numberElement.css("font-size", Math.round(this.config.number_size * this.data.attributes.item_size)); numberElement.appendTo(textElement); this.data.text_elements[key] = numberElement;
        }
        this.start(); if (!this.config.start) { this.data.paused = true; }
        var _this = this; this.data.interval_fallback = useWindow.setInterval(function () { _this.update.call(_this, true); }, 100);
    }; TC_Instance.prototype.update = function (nodraw) {
        if (typeof nodraw === "undefined") { nodraw = false; }
        else if (nodraw && this.data.paused) { return; }
        if (limited_mode) { this.data.attributes.context.clearRect(0, 0, this.data.attributes.canvas[0].width, this.data.attributes.canvas[0].hright); }
        var diff, old_diff; var prevDate = this.data.prev_time; var curDate = new Date(); this.data.prev_time = curDate; if (prevDate === null)
            prevDate = curDate; if (!this.config.count_past_zero) {
                if (curDate > this.data.attributes.ref_date) {
                    for (var i = 0; i < this.data.drawn_units.length; i++) { var key = this.data.drawn_units[i]; this.data.text_elements[key].text("0"); var x = (i * this.data.attributes.item_size) + (this.data.attributes.item_size / 2); var y = this.data.attributes.item_size / 2; var color = this.config.time[key].color; this.drawArc(x, y, color, 0); }
                    this.stop(); return;
                }
            }
        diff = (this.data.attributes.ref_date - curDate) / 1000; old_diff = (this.data.attributes.ref_date - prevDate) / 1000; var floor = this.config.animation !== "smooth"; var visible_times = parse_times(diff, old_diff, this.data.total_duration, this.data.drawn_units, floor); var all_times = parse_times(diff, old_diff, secondsIn["Years"], allUnits, floor); var i = 0; var j = 0; var lastKey = null; var cur_shown = this.data.drawn_units.slice(); for (var i in allUnits) {
            var key = allUnits[i]; if (Math.floor(all_times.raw_time[key]) !== Math.floor(all_times.raw_old_time[key])) { this.notifyListeners(key, Math.floor(all_times.time[key]), Math.floor(diff), "all"); }
            if (cur_shown.indexOf(key) < 0)
                continue; if (Math.floor(visible_times.raw_time[key]) !== Math.floor(visible_times.raw_old_time[key])) { this.notifyListeners(key, Math.floor(visible_times.time[key]), Math.floor(diff), "visible"); }
            if (!nodraw) {
                this.data.text_elements[key].text(Math.floor(Math.abs(visible_times.time[key]))); var x = (j * this.data.attributes.item_size) + (this.data.attributes.item_size / 2); var y = this.data.attributes.item_size / 2; var color = this.config.time[key].color; if (this.config.animation === "smooth") {
                    if (lastKey !== null && !limited_mode) {
                        if (Math.floor(visible_times.time[lastKey]) > Math.floor(visible_times.old_time[lastKey])) { this.radialFade(x, y, color, 1, key); this.data.state.fading[key] = true; }
                        else if (Math.floor(visible_times.time[lastKey]) < Math.floor(visible_times.old_time[lastKey])) { this.radialFade(x, y, color, 0, key); this.data.state.fading[key] = true; }
                    }
                    if (!this.data.state.fading[key]) { this.drawArc(x, y, color, visible_times.pct[key]); }
                }
                else { this.animateArc(x, y, color, visible_times.pct[key], visible_times.old_pct[key], (new Date()).getTime() + tick_duration); }
            }
            lastKey = key; j++;
        }
        if (this.data.paused || nodraw) { return; }
        var _this = this; var update = function () { _this.update.call(_this); }; if (this.config.animation === "smooth") { this.data.animation_frame = useWindow.requestAnimationFrame(update, _this.element, _this); }
        else {
            var delay = (diff % 1) * 1000; if (delay < 0)
                delay = 1000 + delay; delay += 50; _this.data.animation_frame = useWindow.setTimeout(function () { _this.data.animation_frame = useWindow.requestAnimationFrame(update, _this.element, _this); }, delay);
        }
    }; TC_Instance.prototype.animateArc = function (x, y, color, target_pct, cur_pct, animation_end) {
        if (this.data.attributes.context === null)
            return; var diff = cur_pct - target_pct; if (Math.abs(diff) > 0.5) {
                if (target_pct === 0) { this.radialFade(x, y, color, 1); }
                else { this.radialFade(x, y, color, 0); }
            }
        else {
            var progress = (tick_duration - (animation_end - (new Date()).getTime())) / tick_duration; if (progress > 1)
                progress = 1; var pct = (cur_pct * (1 - progress)) + (target_pct * progress); this.drawArc(x, y, color, pct); if (progress >= 1)
                return; var _this = this; useWindow.requestAnimationFrame(function () { _this.animateArc(x, y, color, target_pct, cur_pct, animation_end); }, this.element);
        }
    }; TC_Instance.prototype.drawArc = function (x, y, color, pct) {
        if (this.data.attributes.context === null)
            return; var clear_radius = Math.max(this.data.attributes.outer_radius, this.data.attributes.item_size / 2); if (!limited_mode) { this.data.attributes.context.clearRect(x - clear_radius, y - clear_radius, clear_radius * 2, clear_radius * 2); }
        if (this.config.use_background) { this.data.attributes.context.beginPath(); this.data.attributes.context.arc(x, y, this.data.attributes.radius, 0, 2 * Math.PI, false); this.data.attributes.context.lineWidth = this.data.attributes.line_width * this.config.bg_width; this.data.attributes.context.strokeStyle = this.config.circle_bg_color; this.data.attributes.context.stroke(); }
        var startAngle, endAngle, counterClockwise; var defaultOffset = (-0.5 * Math.PI); var fullCircle = 2 * Math.PI; startAngle = defaultOffset + (this.config.start_angle / 360 * fullCircle); var offset = (2 * pct * Math.PI); if (this.config.direction === "Both") { counterClockwise = false; startAngle -= (offset / 2); endAngle = startAngle + offset; }
        else {
            if (this.config.direction === "Clockwise") { counterClockwise = false; endAngle = startAngle + offset; }
            else { counterClockwise = true; endAngle = startAngle - offset; }
        }
        this.data.attributes.context.beginPath(); this.data.attributes.context.arc(x, y, this.data.attributes.radius, startAngle, endAngle, counterClockwise); this.data.attributes.context.lineWidth = this.data.attributes.line_width; this.data.attributes.context.strokeStyle = color; this.data.attributes.context.stroke();
    }; TC_Instance.prototype.radialFade = function (x, y, color, from, key) {
        var rgb = hexToRgb(color); var _this = this; var step = 0.2 * ((from === 1) ? -1 : 1); var i; for (i = 0; from <= 1 && from >= 0; i++) { (function () { var delay = 50 * i; var rgba = "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + (Math.round(from * 10) / 10) + ")"; useWindow.setTimeout(function () { _this.drawArc(x, y, rgba, 1); }, delay); }()); from += step; }
        if (typeof key !== undefined) { useWindow.setTimeout(function () { _this.data.state.fading[key] = false; }, 50 * i); }
    }; TC_Instance.prototype.timeLeft = function () {
        if (this.data.paused && typeof this.data.timer === "number") { return this.data.timer; }
        var now = new Date(); return ((this.data.attributes.ref_date - now) / 1000);
    }; TC_Instance.prototype.start = function () {
        useWindow.cancelAnimationFrame(this.data.animation_frame); useWindow.clearTimeout(this.data.animation_frame)
        var attr_data_date = $(this.element).data('date'); if (typeof attr_data_date === "undefined") { attr_data_date = $(this.element).attr('data-date'); }
        if (typeof attr_data_date === "string") { this.data.attributes.ref_date = parse_date(attr_data_date); }
        else if (typeof this.data.timer === "number") { if (this.data.paused) { this.data.attributes.ref_date = (new Date()).getTime() + (this.data.timer * 1000); } }
        else {
            var attr_data_timer = $(this.element).data('timer'); if (typeof attr_data_timer === "undefined") { attr_data_timer = $(this.element).attr('data-timer'); }
            if (typeof attr_data_timer === "string") { attr_data_timer = parseFloat(attr_data_timer); }
            if (typeof attr_data_timer === "number") { this.data.timer = attr_data_timer; this.data.attributes.ref_date = (new Date()).getTime() + (attr_data_timer * 1000); }
            else { this.data.attributes.ref_date = this.config.ref_date; }
        }
        this.data.paused = false; this.update.call(this);
    }; TC_Instance.prototype.restart = function () { this.data.timer = false; this.start(); }; TC_Instance.prototype.stop = function () {
        if (typeof this.data.timer === "number") { this.data.timer = this.timeLeft(this); }
        this.data.paused = true; useWindow.cancelAnimationFrame(this.data.animation_frame);
    }; TC_Instance.prototype.destroy = function () { this.clearListeners(); this.stop(); useWindow.clearInterval(this.data.interval_fallback); this.data.interval_fallback = null; this.container.remove(); $(this.element).removeAttr('data-tc-id'); $(this.element).removeData('tc-id'); }; TC_Instance.prototype.setOptions = function (options) {
        if (this.config === null) { this.default_options.ref_date = new Date(); this.config = $.extend(true, {}, this.default_options); }
        $.extend(true, this.config, options); if (this.config.use_top_frame) { useWindow = window.top; }
        else { useWindow = window; }
        updateUsedWindow(); this.data.total_duration = this.config.total_duration; if (typeof this.data.total_duration === "string") {
            if (typeof secondsIn[this.data.total_duration] !== "undefined") { this.data.total_duration = secondsIn[this.data.total_duration]; }
            else if (this.data.total_duration === "Auto") { for (var i = 0; i < Object.keys(this.config.time).length; i++) { var unit = Object.keys(this.config.time)[i]; if (this.config.time[unit].show) { this.data.total_duration = secondsIn[nextUnits[unit]]; break; } } }
            else { this.data.total_duration = secondsIn["Years"]; console.error("Valid values for TimeCircles config.total_duration are either numeric, or (string) Years, Months, Days, Hours, Minutes, Auto"); }
        }
    }; TC_Instance.prototype.addListener = function (f, context, type) {
        if (typeof f !== "function")
            return; if (typeof type === "undefined")
            type = "visible"; this.listeners[type].push({ func: f, scope: context });
    }; TC_Instance.prototype.notifyListeners = function (unit, value, total, type) { for (var i = 0; i < this.listeners[type].length; i++) { var listener = this.listeners[type][i]; listener.func.apply(listener.scope, [unit, value, total]); } }; TC_Instance.prototype.default_options = { ref_date: new Date(), start: true, animation: "smooth", count_past_zero: true, circle_bg_color: "#60686F", use_background: true, fg_width: 0.1, bg_width: 1.2, text_size: 0.07, number_size: 0.28, total_duration: "Auto", direction: "Clockwise", use_top_frame: false, start_angle: 0, time: { Days: { show: true, text: "Days", color: "#FC6" }, Hours: { show: true, text: "Hours", color: "#9CF" }, Minutes: { show: true, text: "Minutes", color: "#BFB" }, Seconds: { show: true, text: "Seconds", color: "#F99" } } }; var TC_Class = function (elements, options) { this.elements = elements; this.options = options; this.foreach(); }; TC_Class.prototype.getInstance = function (element) {
        var instance; var cur_id = $(element).data("tc-id"); if (typeof cur_id === "undefined") { cur_id = guid(); $(element).attr("data-tc-id", cur_id); }
        if (typeof TC_Instance_List[cur_id] === "undefined") {
            var options = this.options; var element_options = $(element).data('options'); if (typeof element_options === "string") { element_options = JSON.parse(element_options); }
            if (typeof element_options === "object") { options = $.extend(true, {}, this.options, element_options); }
            instance = new TC_Instance(element, options); TC_Instance_List[cur_id] = instance;
        }
        else { instance = TC_Instance_List[cur_id]; if (typeof this.options !== "undefined") { instance.setOptions(this.options); } }
        return instance;
    }; TC_Class.prototype.addTime = function (seconds_to_add) { this.foreach(function (instance) { instance.addTime(seconds_to_add); }); }; TC_Class.prototype.foreach = function (callback) { var _this = this; this.elements.each(function () { var instance = _this.getInstance(this); if (typeof callback === "function") { callback(instance); } }); return this; }; TC_Class.prototype.start = function () { this.foreach(function (instance) { instance.start(); }); return this; }; TC_Class.prototype.stop = function () { this.foreach(function (instance) { instance.stop(); }); return this; }; TC_Class.prototype.restart = function () { this.foreach(function (instance) { instance.restart(); }); return this; }; TC_Class.prototype.rebuild = function () { this.foreach(function (instance) { instance.initialize(false); }); return this; }; TC_Class.prototype.getTime = function () { return this.getInstance(this.elements[0]).timeLeft(); }; TC_Class.prototype.addListener = function (f, type) {
        if (typeof type === "undefined")
            type = "visible"; var _this = this; this.foreach(function (instance) { instance.addListener(f, _this.elements, type); }); return this;
    }; TC_Class.prototype.destroy = function () { this.foreach(function (instance) { instance.destroy(); }); return this; }; TC_Class.prototype.end = function () { return this.elements; }; $.fn.TimeCircles = function (options) { return new TC_Class(this, options); };
}(jQuery)); jQuery(function ($) {
    jQuery(document).ready(function ($) {
        var $ = jQuery; setTimeout(function () { $('.preloader-default').fadeOut(); }, 500); setTimeout(function () { $('.promo').addClass('active'); }, 600); $('.btn-menu').click(function () { $('.fixed-menu').addClass('open'); }); $('.btn-close').click(function () { $('.fixed-menu').removeClass('open'); }); $('.select').each(function () {
            var $this = $(this), numberOfOptions = $(this).children('option').length, onmobileoff = $this.hasClass('mob-off'); var onmobile_off = (onmobileoff == true) ? ' mob-off' : ''; $this.addClass('select-hidden'); $this.wrap('<div class="select' + onmobile_off + '"></div>'); $this.after('<div class="select-styled"></div>'); var $styledSelect = $this.next('div.select-styled'); $styledSelect.text($this.children('option').eq(0).text()); var $list = $('<ul />', { 'class': 'select-options' }).insertAfter($styledSelect); for (var i = 0; i < numberOfOptions; i++) { $('<li />', { text: $this.children('option').eq(i).text(), rel: $this.children('option').eq(i).val() }).appendTo($list); }
            var $listItems = $list.children('li'); $styledSelect.click(function (e) { e.stopPropagation(); $('div.select-styled.active').not(this).each(function () { $(this).removeClass('active').next('ul.select-options').hide(); }); $(this).toggleClass('active').next('ul.select-options').fadeToggle(); }); $listItems.click(function (e) { e.stopPropagation(); $styledSelect.text($(this).text()).removeClass('active'); $this.val($(this).attr('rel')); $list.fadeOut(); }); $(document).click(function () { $styledSelect.removeClass('active'); $list.fadeOut(); });
        }); $(".form__input").focus(function () { $(this).addClass("in"); }); $(".form__input").focusout(function () { if ($.trim($(this).val()) == '') { $(this).removeClass('in') } }); var pressloop = $(".press-carousel").attr('data-loop') == 'yes' ? true : false; var pressautoplay = $(".press-carousel").attr('data-autoplay') == 'yes' ? true : false; var showitems = $(".press-carousel").attr('data-show-items') != '' ? $(".press-carousel").attr('data-show-items') : 2; var pressdotclr = $(".press-carousel").is('[data-dotclr]') ? $(".press-carousel").attr('data-dotclr') : ''; var pressactivedotclr = $(".press-carousel").is('[data-active-dotclr]') ? $(".press-carousel").attr('data-active-dotclr') : ''; $(".press-carousel").owlCarousel({ items: 2, margin: 30, loop: pressloop, autoplay: pressautoplay, dots: true, dotClass: 'owl-dot ' + pressdotclr + ' ' + pressactivedotclr, responsive: { 0: { items: 1, }, 768: { items: 2, } }, onInitialized: pressDotClr }); function pressDotClr(event) { if (pressdotclr) { $(".press-carousel .owl-dots .owl-dot").css('background-color', pressdotclr); } else { return false; } }
        var pressloop2 = $(".press-carousel2").attr('data-loop') == 'yes' ? true : false; var pressautoplay2 = $(".press-carousel2").attr('data-autoplay') == 'yes' ? true : false; var pressdotclr2 = $(".press-carousel2").is('[data-dotclr]') ? $(".press-carousel2").attr('data-dotclr') : ''; var pressactivedotclr2 = $(".press-carousel2").is('[data-active-dotclr]') ? $(".press-carousel2").attr('data-active-dotclr') : ''; $(".press-carousel2").owlCarousel({ items: 1, loop: pressloop2, autoplay: pressautoplay2, dots: true, dotClass: 'owl-dot ' + pressdotclr2 + ' ' + pressactivedotclr2, onInitialized: pressDotClr2 }); function pressDotClr2(event) { if (pressdotclr2) { $(".press-carousel2 .owl-dots .owl-dot").css('background-color', pressdotclr2); } else { return false; } }
        var newsloop = $(".news-carousel").attr('data-loop') == 'yes' ? true : false; var newsautoplay = $(".news-carousel").attr('data-autoplay') == 'yes' ? true : false; var newsdotclr = $(".news-carousel").is('[data-dotclr]') ? $(".news-carousel").attr('data-dotclr') : ''; var newsactivedotclr = $(".news-carousel").is('[data-active-dotclr]') ? $(".news-carousel").attr('data-active-dotclr') : ''; var showitems = 3; var newsperpage = $(".news-carousel").attr('data-post-per-page'); var newslooped = (newsperpage != 'all') && (parseInt(newsperpage) < showitems) ? true : newsloop; $(".news-carousel").owlCarousel({ items: showitems, margin: 30, loop: newslooped, autoplay: newsautoplay, dots: true, dotClass: 'owl-dot ' + newsdotclr + ' ' + newsactivedotclr, responsive: { 0: { items: 1, }, 768: { items: 2, }, 992: { items: 3, }, }, onInitialized: newsDotClr }); function newsDotClr(event) { if (newsdotclr) { $(".press-carousel2 .owl-dots .owl-dot").css('background-color', newsdotclr); } else { return false; } }
        var get_Date1 = $(".timer1").attr('data-date'); var countDownDate1 = new Date(get_Date1).getTime(); var x = setInterval(function () {
            var now1 = new Date().getTime(); var distance1 = countDownDate1 - now1; var days1 = Math.floor(distance1 / (1000 * 60 * 60 * 24)); var hours1 = Math.floor((distance1 % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)); var minutes1 = Math.floor((distance1 % (1000 * 60 * 60)) / (1000 * 60)); var seconds1 = Math.floor((distance1 % (1000 * 60)) / 1000); var timer1 = $(".timer1").size(); if (timer1 > 0) {
                document.getElementById("timer1").innerHTML = "<div class='timer__item'><div class='timer__value'>" + days1 + "</div><div class='timer__item-title'>Days</div></div> <div class='timer__item'><div class='timer__value'>" + hours1 + "</div><div class='timer__item-title'>Hours</div></div> <div class='timer__item'><div class='timer__value'>"
                    + minutes1 + "</div><div class='timer__item-title'>Minutes</div></div> <div class='timer__item'><div class='timer__value'>" + seconds1 + "</div><div class='timer__item-title'>Seconds</div></div> "; if (distance1 < 0) { clearInterval(x); document.getElementById("timer1").innerHTML = "EXPIRED"; }
            }
        }, 1000); var get_Date = $(".timer11").attr('data-date'); var countDownDate = new Date(get_Date).getTime(); var x = setInterval(function () {
            var now = new Date().getTime(); var distance = countDownDate - now; var days = Math.floor(distance / (1000 * 60 * 60 * 24)); var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)); var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60)); var seconds = Math.floor((distance % (1000 * 60)) / 1000); var timer = $(".timer11").size(); if (timer > 0) {
                document.getElementById("timer11").innerHTML = "<div class='timer__item'><div class='timer__value'>" + days + "</div><div class='timer__item-title'>Days</div></div> <div class='timer__item'><div class='timer__value'>" + hours + "</div><div class='timer__item-title'>Hours</div></div> <div class='timer__item'><div class='timer__value'>"
                    + minutes + "</div><div class='timer__item-title'>Minutes</div></div> <div class='timer__item'><div class='timer__value'>" + seconds + "</div><div class='timer__item-title'>Seconds</div></div> "; if (distance < 0) { clearInterval(x); document.getElementById("timer11").innerHTML = "EXPIRED"; }
            }
        }, 1000); var get_date2 = $(".timer2").attr('data-date'); if (get_date2) { get_Date2 = get_date2.split(',').map(x => parseInt(x, 10)); console.log(get_Date2[0]); var flipdate2 = new Date(get_Date2[0], get_Date2[1], get_Date2[2], get_Date2[3], get_Date2[4], get_Date2[5], get_Date2[6]); var flipnow2 = new Date(); var flipdiff2 = (flipdate2.getTime() / 1000) - (flipnow2.getTime() / 1000); var clock = $('.timer2').FlipClock(flipdiff2, { clockFace: 'DailyCounter', countdown: true, }); }
        var get_date3 = $(".timer3").attr('data-date'); if (get_date3) { get_Date3 = get_date3.split(',').map(x => parseInt(x, 10)); console.log(get_Date3[0]); var flipdate3 = new Date(get_Date3[0], get_Date3[1], get_Date3[2], get_Date3[3], get_Date3[4], get_Date3[5], get_Date3[6]); var flipnow3 = new Date(); var flipdiff3 = (flipdate3.getTime() / 1000) - (flipnow3.getTime() / 1000); var clock = $('.timer3').FlipClock(flipdiff3, { clockFace: 'DailyCounter', countdown: true, }); }
        var chartdef = $("#myChart").length; if (chartdef > 0) {
            var chart_count = $(".chart__legend li").size(), lbl = [], clr = [], val = []; for (var i = 1; i < chart_count + 1; i++) { var get_label = $(".chart__legend li:nth-child(" + i + ")").attr('data-chart-label'); var get_color = $(".chart__legend li:nth-child(" + i + ")").attr('data-chart-color'); var get_value = $(".chart__legend li:nth-child(" + i + ")").attr('data-chart-value'); lbl.push(get_label); clr.push(get_color); val.push(get_value); }
            var get_cutout = $(".chart__wrap").attr('data-chart-cutout'); var get_cutout = (typeof get_cutout !== typeof undefined && get_cutout !== false) ? parseInt(get_cutout) : ''; var get_brd = $(".chart__wrap").attr('data-chart-brd'); var get_brd = (typeof get_brd !== typeof undefined && get_brd !== false) ? parseInt(get_brd) : 0; var get_brdclr = $(".chart__wrap").attr('data-chart-brdclr'); var get_brdclr = (typeof get_brdclr !== typeof undefined && get_brdclr !== false) ? '' + get_brdclr + '' : 'transparent'; var ctx = document.getElementById("myChart"); var myChart = new Chart(ctx, { type: 'doughnut', data: { labels: lbl, datasets: [{ label: '# of Votes', data: val, backgroundColor: clr, borderWidth: parseInt(get_brd), borderColor: get_brdclr }] }, options: { legend: { display: false }, cutoutPercentage: get_cutout, } });
        }
        $('.counter').countUp({ 'time': 2000, 'delay': 10 }); $('.popup-youtube').magnificPopup({ type: 'iframe', mainClass: 'mfp-fade', removalDelay: 160, preloader: false, fixedContentPos: false }); $('.new__title').matchHeight(); $('.same_height').matchHeight(); $('.press__item.home4').matchHeight(); AOS.init({ disable: 'mobile', duration: 1000, once: true }); var scroll = new SmoothScroll('a[href*="#"]', { ignore: '[data-vc-accordion]', header: null, topOnEmptyHash: true, speed: 1000, clip: true, easing: 'easeInOutCubic', offset: 110, customEasing: function (time) { return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; }, offset: function (anchor) { $('.fixed-menu').removeClass('open'); if ($('.mob-menu__link').closest('.fixed-menu')) { $('.fixed-menu').removeClass('open'); return 120; } else { return 120; } }, updateURL: true, popstate: true, emitEvents: true }); $('.scroll-down').on('click', function (e) { $('html, body').animate({ scrollTop: getHeight() }, 1000); }); var canvaslength = $('canvas.scene--full').size(); if (canvaslength > 0) {
            var canvas = document.querySelector('.scene--full'); var width = canvas.offsetWidth, height = canvas.offsetHeight; var renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true }); renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1); renderer.setSize(width, height); renderer.setClearColor(0x000000, 0); var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(25, width / height, 0.1, 1000); camera.position.set(0, 0, 350); var sphere = new THREE.Group(); scene.add(sphere); var material = new THREE.LineBasicMaterial({ color: 0x19395e }); var linesAmount = 25; var radius = 100; var verticesAmount = 50; for (var j = 0; j < linesAmount; j++) {
                var index = j; var geometry = new THREE.Geometry(); geometry.y = (index / linesAmount) * radius * 2; for (var i = 0; i <= verticesAmount; i++) { var vector = new THREE.Vector3(); vector.x = Math.cos(i / verticesAmount * Math.PI * 2); vector.z = Math.sin(i / verticesAmount * Math.PI * 2); vector._o = vector.clone(); geometry.vertices.push(vector); }
                var line = new THREE.Line(geometry, material); sphere.add(line);
            }
            function updateVertices(a) {
                for (var j = 0; j < sphere.children.length; j++) {
                    var line = sphere.children[j]; line.geometry.y += 0.3; if (line.geometry.y > radius * 2) { line.geometry.y = 0; }
                    var radiusHeight = Math.sqrt(line.geometry.y * (2 * radius - line.geometry.y)); for (var i = 0; i <= verticesAmount; i++) { var vector = line.geometry.vertices[i]; var ratio = noise.simplex3(vector.x * 0.009, vector.z * 0.009 + a * 0.0006, line.geometry.y * 0.009) * 15; vector.copy(vector._o); vector.multiplyScalar(radiusHeight + ratio); vector.y = line.geometry.y - radius; }
                    line.geometry.verticesNeedUpdate = true;
                }
            }
            function render(a) { requestAnimationFrame(render); updateVertices(a); renderer.render(scene, camera); }
            function onResize() { canvas.style.width = ''; canvas.style.height = ''; width = canvas.offsetWidth; height = canvas.offsetHeight; camera.aspect = width / height; camera.updateProjectionMatrix(); renderer.setSize(width, height); }
            var mouse = new THREE.Vector2(0.8, 0.5); function onMouseMove(e) { mouse.y = e.clientY / window.innerHeight; TweenMax.to(sphere.rotation, 2, { x: (mouse.y * 1), ease: Power1.easeOut }); }
            requestAnimationFrame(render); window.addEventListener("mousemove", onMouseMove); var resizeTm; window.addEventListener("resize", function () { resizeTm = clearTimeout(resizeTm); resizeTm = setTimeout(onResize, 200); });
        }
    }); $(window).resize(function () { $(".js-TimeCircles").TimeCircles().rebuild(); });
}); var $window = jQuery(window); function getHeight() { return jQuery('.promo').outerHeight(); }
$window.on('scroll', function () { if ($window.scrollTop() > 1) { jQuery('.header').addClass('sticky'); jQuery('.fixed-menu').addClass('sticky'); } else { jQuery('.header').removeClass('sticky'); jQuery('.fixed-menu').removeClass('sticky'); } }); (function () { var oInterval = setInterval(function () { if (typeof window.jQuery !== 'undefined') { clearInterval(oInterval); jQuery(document).ready(function ($) { var ctimer = $(".js-TimeCircles").size(); var get_ctimer = $(".js-TimeCircles").attr('data-label'); var get_ctimerclr = $(".js-TimeCircles").attr('data-progresclr'); var get_circlebg = $(".js-TimeCircles").attr('data-circlebg'); if (ctimer > 0) { var get_ctimerr = new Array(); get_ctimerr = get_ctimer.split(","); var get_ctimerclrr = new Array(); get_ctimerclrr = get_ctimerclr.split(","); jQuery('.js-TimeCircles').TimeCircles({ "animation": "smooth", "bg_width": 1.1, "fg_width": 0.05, "circle_bg_color": get_circlebg, "number_size": 0.2, "time": { "Days": { "text": get_ctimerr[0], "color": get_ctimerclrr[0], "show": true }, "Hours": { "text": get_ctimerr[1], "color": get_ctimerclrr[1], "show": true }, "Minutes": { "text": get_ctimerr[2], "color": get_ctimerclrr[2], "show": true }, "Seconds": { "text": get_ctimerr[3], "color": get_ctimerclrr[3], "show": true } } }); } }); } }, 500); })();;/*!This file is auto-generated*/window.addComment = function (v) { var I, C, h, E = v.document, b = { commentReplyClass: "comment-reply-link", commentReplyTitleId: "reply-title", cancelReplyId: "cancel-comment-reply-link", commentFormId: "commentform", temporaryFormId: "wp-temp-form-div", parentIdFieldId: "comment_parent", postIdFieldId: "comment_post_ID" }, e = v.MutationObserver || v.WebKitMutationObserver || v.MozMutationObserver, r = "querySelector" in E && "addEventListener" in v, n = !!E.documentElement.dataset; function t() { d(), e && new e(o).observe(E.body, { childList: !0, subtree: !0 }) } function d(e) { if (r && (I = g(b.cancelReplyId), C = g(b.commentFormId), I)) { I.addEventListener("touchstart", l), I.addEventListener("click", l); function t(e) { if ((e.metaKey || e.ctrlKey) && 13 === e.keyCode) return C.removeEventListener("keydown", t), e.preventDefault(), C.submit.click(), !1 } C && C.addEventListener("keydown", t); for (var n, d = function (e) { var t = b.commentReplyClass; e && e.childNodes || (e = E); t = E.getElementsByClassName ? e.getElementsByClassName(t) : e.querySelectorAll("." + t); return t }(e), o = 0, i = d.length; o < i; o++)(n = d[o]).addEventListener("touchstart", a), n.addEventListener("click", a) } } function l(e) { var t, n, d = g(b.temporaryFormId); d && h && (g(b.parentIdFieldId).value = "0", t = d.textContent, d.parentNode.replaceChild(h, d), this.style.display = "none", n = (d = (n = g(b.commentReplyTitleId)) && n.firstChild) && d.nextSibling, d && d.nodeType === Node.TEXT_NODE && t && (n && "A" === n.nodeName && n.id !== b.cancelReplyId && (n.style.display = ""), d.textContent = t), e.preventDefault()) } function a(e) { var t = g(b.commentReplyTitleId), n = t && t.firstChild.textContent, d = this, o = m(d, "belowelement"), i = m(d, "commentid"), r = m(d, "respondelement"), t = m(d, "postid"), n = m(d, "replyto") || n; o && i && r && t && !1 === v.addComment.moveForm(o, i, r, t, n) && e.preventDefault() } function o(e) { for (var t = e.length; t--;)if (e[t].addedNodes.length) return void d() } function m(e, t) { return n ? e.dataset[t] : e.getAttribute("data-" + t) } function g(e) { return E.getElementById(e) } return r && "loading" !== E.readyState ? t() : r && v.addEventListener("DOMContentLoaded", t, !1), { init: d, moveForm: function (e, t, n, d, o) { var i = g(e); h = g(n); var r, l, a, m, c, s = g(b.parentIdFieldId), y = g(b.postIdFieldId), p = (c = g(b.commentReplyTitleId)) && c.firstChild, u = p && p.nextSibling; if (i && h && s) { void 0 === o && (o = p && p.textContent), m = h, e = b.temporaryFormId, n = g(e), c = (c = g(b.commentReplyTitleId)) ? c.firstChild.textContent : "", n || ((n = E.createElement("div")).id = e, n.style.display = "none", n.textContent = c, m.parentNode.insertBefore(n, m)), d && y && (y.value = d), s.value = t, I.style.display = "", i.parentNode.insertBefore(h, i.nextSibling), p && p.nodeType === Node.TEXT_NODE && (u && "A" === u.nodeName && u.id !== b.cancelReplyId && (u.style.display = "none"), p.textContent = o), I.onclick = function () { return !1 }; try { for (var f = 0; f < C.elements.length; f++)if (r = C.elements[f], l = !1, "getComputedStyle" in v ? a = v.getComputedStyle(r) : E.documentElement.currentStyle && (a = r.currentStyle), (r.offsetWidth <= 0 && r.offsetHeight <= 0 || "hidden" === a.visibility) && (l = !0), "hidden" !== r.type && !r.disabled && !l) { r.focus(); break } } catch (e) { } return !1 } } } }(window);; function vc_js() { vc_toggleBehaviour(), vc_tabsBehaviour(), vc_accordionBehaviour(), vc_teaserGrid(), vc_carouselBehaviour(), vc_slidersBehaviour(), vc_prettyPhoto(), vc_googleplus(), vc_pinterest(), vc_progress_bar(), vc_plugin_flexslider(), vc_google_fonts(), vc_gridBehaviour(), vc_rowBehaviour(), vc_prepareHoverBox(), vc_googleMapsPointer(), vc_ttaActivation(), jQuery(document).trigger("vc_js"), window.setTimeout(vc_waypoints, 500) } document.documentElement.className += " js_active ", document.documentElement.className += "ontouchstart" in document.documentElement ? " vc_mobile " : " vc_desktop ", function () { for (var prefix = ["-webkit-", "-moz-", "-ms-", "-o-", ""], i = 0; i < prefix.length; i++)prefix[i] + "transform" in document.documentElement.style && (document.documentElement.className += " vc_transform ") }(), "function" != typeof window.vc_plugin_flexslider && (window.vc_plugin_flexslider = function ($parent) { ($parent ? $parent.find(".wpb_flexslider") : jQuery(".wpb_flexslider")).each(function () { var this_element = jQuery(this), sliderTimeout = 1e3 * parseInt(this_element.attr("data-interval")), sliderFx = this_element.attr("data-flex_fx"), slideshow = !0; 0 === sliderTimeout && (slideshow = !1), this_element.is(":visible") && this_element.flexslider({ animation: sliderFx, slideshow: slideshow, slideshowSpeed: sliderTimeout, sliderSpeed: 800, smoothHeight: !0 }) }) }), "function" != typeof window.vc_googleplus && (window.vc_googleplus = function () { 0 < jQuery(".wpb_googleplus").length && function () { var po = document.createElement("script"); po.type = "text/javascript", po.async = !0, po.src = "https://apis.google.com/js/plusone.js"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(po, s) }() }), "function" != typeof window.vc_pinterest && (window.vc_pinterest = function () { 0 < jQuery(".wpb_pinterest").length && function () { var po = document.createElement("script"); po.type = "text/javascript", po.async = !0, po.src = "https://assets.pinterest.com/js/pinit.js"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(po, s) }() }), "function" != typeof window.vc_progress_bar && (window.vc_progress_bar = function () { void 0 !== jQuery.fn.waypoint && jQuery(".vc_progress_bar").waypoint(function () { jQuery(this).find(".vc_single_bar").each(function (index) { var bar = jQuery(this).find(".vc_bar"), val = bar.data("percentage-value"); setTimeout(function () { bar.css({ width: val + "%" }) }, 200 * index) }) }, { offset: "85%" }) }), "function" != typeof window.vc_waypoints && (window.vc_waypoints = function () { void 0 !== jQuery.fn.waypoint && jQuery(".wpb_animate_when_almost_visible:not(.wpb_start_animation)").waypoint(function () { jQuery(this).addClass("wpb_start_animation animated") }, { offset: "85%" }) }), "function" != typeof window.vc_toggleBehaviour && (window.vc_toggleBehaviour = function ($el) { function event(e) { e && e.preventDefault && e.preventDefault(); var element = jQuery(this).closest(".vc_toggle"), content = element.find(".vc_toggle_content"); element.hasClass("vc_toggle_active") ? content.slideUp({ duration: 300, complete: function () { element.removeClass("vc_toggle_active") } }) : content.slideDown({ duration: 300, complete: function () { element.addClass("vc_toggle_active") } }) } $el ? $el.hasClass("vc_toggle_title") ? $el.unbind("click").click(event) : $el.find(".vc_toggle_title").unbind("click").click(event) : jQuery(".vc_toggle_title").unbind("click").on("click", event) }), "function" != typeof window.vc_tabsBehaviour && (window.vc_tabsBehaviour = function ($tab) { if (jQuery.ui) { var $call = $tab || jQuery(".wpb_tabs, .wpb_tour"), ver = jQuery.ui && jQuery.ui.version ? jQuery.ui.version.split(".") : "1.10", old_version = 1 === parseInt(ver[0]) && parseInt(ver[1]) < 9; $call.each(function (index) { var $tabs, interval = jQuery(this).attr("data-interval"), tabs_array = []; if ($tabs = jQuery(this).find(".wpb_tour_tabs_wrapper").tabs({ show: function (event, ui) { wpb_prepare_tab_content(event, ui) }, beforeActivate: function (event, ui) { 1 !== ui.newPanel.index() && ui.newPanel.find(".vc_pie_chart:not(.vc_ready)") }, activate: function (event, ui) { wpb_prepare_tab_content(event, ui) } }), interval && 0 < interval) try { $tabs.tabs("rotate", 1e3 * interval) } catch (e) { window.console && window.console.warn && console.warn(e) } jQuery(this).find(".wpb_tab").each(function () { tabs_array.push(this.id) }), jQuery(this).find(".wpb_tabs_nav li").click(function (e) { return e.preventDefault(), old_version ? $tabs.tabs("select", jQuery("a", this).attr("href")) : $tabs.tabs("option", "active", jQuery(this).index()), !1 }), jQuery(this).find(".wpb_prev_slide a, .wpb_next_slide a").click(function (e) { if (e.preventDefault(), old_version) { var index = $tabs.tabs("option", "selected"); jQuery(this).parent().hasClass("wpb_next_slide") ? index++ : index--, index < 0 ? index = $tabs.tabs("length") - 1 : index >= $tabs.tabs("length") && (index = 0), $tabs.tabs("select", index) } else { index = $tabs.tabs("option", "active"); var length = $tabs.find(".wpb_tab").length; index = jQuery(this).parent().hasClass("wpb_next_slide") ? length <= index + 1 ? 0 : index + 1 : index - 1 < 0 ? length - 1 : index - 1, $tabs.tabs("option", "active", index) } }) }) } }), "function" != typeof window.vc_accordionBehaviour && (window.vc_accordionBehaviour = function () { jQuery(".wpb_accordion").each(function (index) { var $tabs, $this = jQuery(this), active_tab = ($this.attr("data-interval"), !isNaN(jQuery(this).data("active-tab")) && 0 < parseInt($this.data("active-tab")) && parseInt($this.data("active-tab")) - 1), collapsible = !1 === active_tab || "yes" === $this.data("collapsible"); $tabs = $this.find(".wpb_accordion_wrapper").accordion({ header: "> div > h3", autoHeight: !1, heightStyle: "content", active: active_tab, collapsible: collapsible, navigation: !0, activate: vc_accordionActivate, change: function (event, ui) { void 0 !== jQuery.fn.isotope && ui.newContent.find(".isotope").isotope("layout"), vc_carouselBehaviour(ui.newPanel) } }), !0 === $this.data("vcDisableKeydown") && ($tabs.data("uiAccordion")._keydown = function () { }) }) }), "function" != typeof window.vc_teaserGrid && (window.vc_teaserGrid = function () { var layout_modes = { fitrows: "fitRows", masonry: "masonry" }; jQuery(".wpb_grid .teaser_grid_container:not(.wpb_carousel), .wpb_filtered_grid .teaser_grid_container:not(.wpb_carousel)").each(function () { var $container = jQuery(this), $thumbs = $container.find(".wpb_thumbnails"), layout_mode = $thumbs.attr("data-layout-mode"); $thumbs.isotope({ itemSelector: ".isotope-item", layoutMode: void 0 === layout_modes[layout_mode] ? "fitRows" : layout_modes[layout_mode] }), $container.find(".categories_filter a").data("isotope", $thumbs).click(function (e) { e.preventDefault(); var $thumbs = jQuery(this).data("isotope"); jQuery(this).parent().parent().find(".active").removeClass("active"), jQuery(this).parent().addClass("active"), $thumbs.isotope({ filter: jQuery(this).attr("data-filter") }) }), jQuery(window).bind("load resize", function () { $thumbs.isotope("layout") }) }) }), "function" != typeof window.vc_carouselBehaviour && (window.vc_carouselBehaviour = function ($parent) { ($parent ? $parent.find(".wpb_carousel") : jQuery(".wpb_carousel")).each(function () { var $this = jQuery(this); if (!0 !== $this.data("carousel_enabled") && $this.is(":visible")) { $this.data("carousel_enabled", !0); getColumnsCount(jQuery(this)); jQuery(this).hasClass("columns_count_1") && 900; var carousele_li = jQuery(this).find(".wpb_thumbnails-fluid li"); carousele_li.css({ "margin-right": carousele_li.css("margin-left"), "margin-left": 0 }); var fluid_ul = jQuery(this).find("ul.wpb_thumbnails-fluid"); fluid_ul.width(fluid_ul.width() + 300), jQuery(window).resize(function () { screen_size != (screen_size = getSizeName()) && window.setTimeout("location.reload()", 20) }) } }) }), "function" != typeof window.vc_slidersBehaviour && (window.vc_slidersBehaviour = function () { jQuery(".wpb_gallery_slides").each(function (index) { var $imagesGrid, this_element = jQuery(this); if (this_element.hasClass("wpb_slider_nivo")) { var sliderTimeout = 1e3 * this_element.attr("data-interval"); 0 === sliderTimeout && (sliderTimeout = 9999999999), this_element.find(".nivoSlider").nivoSlider({ effect: "boxRainGrow,boxRain,boxRainReverse,boxRainGrowReverse", slices: 15, boxCols: 8, boxRows: 4, animSpeed: 800, pauseTime: sliderTimeout, startSlide: 0, directionNav: !0, directionNavHide: !0, controlNav: !0, keyboardNav: !1, pauseOnHover: !0, manualAdvance: !1, prevText: "Prev", nextText: "Next" }) } else this_element.hasClass("wpb_image_grid") && (jQuery.fn.imagesLoaded ? $imagesGrid = this_element.find(".wpb_image_grid_ul").imagesLoaded(function () { $imagesGrid.isotope({ itemSelector: ".isotope-item", layoutMode: "fitRows" }) }) : this_element.find(".wpb_image_grid_ul").isotope({ itemSelector: ".isotope-item", layoutMode: "fitRows" })) }) }), "function" != typeof window.vc_prettyPhoto && (window.vc_prettyPhoto = function () { try { jQuery && jQuery.fn && jQuery.fn.prettyPhoto && jQuery('a.prettyphoto, .gallery-icon a[href*=".jpg"]').prettyPhoto({ animationSpeed: "normal", hook: "data-rel", padding: 15, opacity: .7, showTitle: !0, allowresize: !0, counter_separator_label: "/", hideflash: !1, deeplinking: !1, modal: !1, callback: function () { -1 < location.href.indexOf("#!prettyPhoto") && (location.hash = "") }, social_tools: "" }) } catch (err) { window.console && window.console.warn && console.warn(err) } }), "function" != typeof window.vc_google_fonts && (window.vc_google_fonts = function () { return !1 }), window.vcParallaxSkroll = !1, "function" != typeof window.vc_rowBehaviour && (window.vc_rowBehaviour = function () { var vcSkrollrOptions, callSkrollInit, $ = window.jQuery; function fullWidthRow() { var $elements = $('[data-vc-full-width="true"]'); $.each($elements, function (key, item) { var $el = $(this); $el.addClass("vc_hidden"); var $el_full = $el.next(".vc_row-full-width"); if ($el_full.length || ($el_full = $el.parent().next(".vc_row-full-width")), $el_full.length) { var padding, paddingRight, el_margin_left = parseInt($el.css("margin-left"), 10), el_margin_right = parseInt($el.css("margin-right"), 10), offset = 0 - $el_full.offset().left - el_margin_left, width = $(window).width(); if ("rtl" === $el.css("direction") && (offset -= $el_full.width(), offset += width, offset += el_margin_left, offset += el_margin_right), $el.css({ position: "relative", left: offset, "box-sizing": "border-box", width: width }), !$el.data("vcStretchContent")) "rtl" === $el.css("direction") ? ((padding = offset) < 0 && (padding = 0), (paddingRight = offset) < 0 && (paddingRight = 0)) : ((padding = -1 * offset) < 0 && (padding = 0), (paddingRight = width - padding - $el_full.width() + el_margin_left + el_margin_right) < 0 && (paddingRight = 0)), $el.css({ "padding-left": padding + "px", "padding-right": paddingRight + "px" }); $el.attr("data-vc-full-width-init", "true"), $el.removeClass("vc_hidden"), $(document).trigger("vc-full-width-row-single", { el: $el, offset: offset, marginLeft: el_margin_left, marginRight: el_margin_right, elFull: $el_full, width: width }) } }), $(document).trigger("vc-full-width-row", $elements) } function fullHeightRow() { var windowHeight, offsetTop, fullHeight, $element = $(".vc_row-o-full-height:first"); $element.length && (windowHeight = $(window).height(), (offsetTop = $element.offset().top) < windowHeight && (fullHeight = 100 - offsetTop / (windowHeight / 100), $element.css("min-height", fullHeight + "vh"))); $(document).trigger("vc-full-height-row", $element) } $(window).off("resize.vcRowBehaviour").on("resize.vcRowBehaviour", fullWidthRow).on("resize.vcRowBehaviour", fullHeightRow), fullWidthRow(), fullHeightRow(), (0 < window.navigator.userAgent.indexOf("MSIE ") || navigator.userAgent.match(/Trident.*rv\:11\./)) && $(".vc_row-o-full-height").each(function () { "flex" === $(this).css("display") && $(this).wrap('<div class="vc_ie-flexbox-fixer"></div>') }), vc_initVideoBackgrounds(), callSkrollInit = !1, window.vcParallaxSkroll && window.vcParallaxSkroll.destroy(), $(".vc_parallax-inner").remove(), $("[data-5p-top-bottom]").removeAttr("data-5p-top-bottom data-30p-top-bottom"), $("[data-vc-parallax]").each(function () { var skrollrSize, skrollrStart, $parallaxElement, parallaxImage, youtubeId; callSkrollInit = !0, "on" === $(this).data("vcParallaxOFade") && $(this).children().attr("data-5p-top-bottom", "opacity:0;").attr("data-30p-top-bottom", "opacity:1;"), skrollrSize = 100 * $(this).data("vcParallax"), ($parallaxElement = $("<div />").addClass("vc_parallax-inner").appendTo($(this))).height(skrollrSize + "%"), (youtubeId = vcExtractYoutubeId(parallaxImage = $(this).data("vcParallaxImage"))) ? insertYoutubeVideoAsBackground($parallaxElement, youtubeId) : void 0 !== parallaxImage && $parallaxElement.css("background-image", "url(" + parallaxImage + ")"), skrollrStart = -(skrollrSize - 100), $parallaxElement.attr("data-bottom-top", "top: " + skrollrStart + "%;").attr("data-top-bottom", "top: 0%;") }), callSkrollInit && window.skrollr && (vcSkrollrOptions = { forceHeight: !1, smoothScrolling: !1, mobileCheck: function () { return !1 } }, window.vcParallaxSkroll = skrollr.init(vcSkrollrOptions), window.vcParallaxSkroll) }), "function" != typeof window.vc_gridBehaviour && (window.vc_gridBehaviour = function () { jQuery.fn.vcGrid && jQuery("[data-vc-grid]").vcGrid() }), "function" != typeof window.getColumnsCount && (window.getColumnsCount = function (el) { for (var find = !1, i = 1; !1 === find;) { if (el.hasClass("columns_count_" + i)) return find = !0, i; i++ } }); var screen_size = getSizeName(); function getSizeName() { var screen_w = jQuery(window).width(); return 1170 < screen_w ? "desktop_wide" : 960 < screen_w && screen_w < 1169 ? "desktop" : 768 < screen_w && screen_w < 959 ? "tablet" : 300 < screen_w && screen_w < 767 ? "mobile" : screen_w < 300 ? "mobile_portrait" : "" } function loadScript(url, $obj, callback) { var script = document.createElement("script"); script.type = "text/javascript", script.readyState && (script.onreadystatechange = function () { "loaded" !== script.readyState && "complete" !== script.readyState || (script.onreadystatechange = null, callback()) }), script.src = url, $obj.get(0).appendChild(script) } function vc_ttaActivation() { jQuery("[data-vc-accordion]").on("show.vc.accordion", function (e) { var $ = window.jQuery, ui = {}; ui.newPanel = $(this).data("vc.accordion").getTarget(), window.wpb_prepare_tab_content(e, ui) }) } function vc_accordionActivate(event, ui) { if (ui.newPanel.length && ui.newHeader.length) { var $pie_charts = ui.newPanel.find(".vc_pie_chart:not(.vc_ready)"), $round_charts = ui.newPanel.find(".vc_round-chart"), $line_charts = ui.newPanel.find(".vc_line-chart"), $carousel = ui.newPanel.find('[data-ride="vc_carousel"]'); void 0 !== jQuery.fn.isotope && ui.newPanel.find(".isotope, .wpb_image_grid_ul").isotope("layout"), ui.newPanel.find(".vc_masonry_media_grid, .vc_masonry_grid").length && ui.newPanel.find(".vc_masonry_media_grid, .vc_masonry_grid").each(function () { var grid = jQuery(this).data("vcGrid"); grid && grid.gridBuilder && grid.gridBuilder.setMasonry && grid.gridBuilder.setMasonry() }), vc_carouselBehaviour(ui.newPanel), vc_plugin_flexslider(ui.newPanel), $pie_charts.length && jQuery.fn.vcChat && $pie_charts.vcChat(), $round_charts.length && jQuery.fn.vcRoundChart && $round_charts.vcRoundChart({ reload: !1 }), $line_charts.length && jQuery.fn.vcLineChart && $line_charts.vcLineChart({ reload: !1 }), $carousel.length && jQuery.fn.carousel && $carousel.carousel("resizeAction"), ui.newPanel.parents(".isotope").length && ui.newPanel.parents(".isotope").each(function () { jQuery(this).isotope("layout") }) } } function initVideoBackgrounds() { return window.console && window.console.warn && window.console.warn("this function is deprecated use vc_initVideoBackgrounds"), vc_initVideoBackgrounds() } function vc_initVideoBackgrounds() { jQuery("[data-vc-video-bg]").each(function () { var youtubeId, $element = jQuery(this); $element.data("vcVideoBg") ? ((youtubeId = vcExtractYoutubeId($element.data("vcVideoBg"))) && ($element.find(".vc_video-bg").remove(), insertYoutubeVideoAsBackground($element, youtubeId)), jQuery(window).on("grid:items:added", function (event, $grid) { $element.has($grid).length && vcResizeVideoBackground($element) })) : $element.find(".vc_video-bg").remove() }) } function insertYoutubeVideoAsBackground($element, youtubeId, counter) { if ("undefined" == typeof YT || void 0 === YT.Player) return 100 < (counter = void 0 === counter ? 0 : counter) ? void console.warn("Too many attempts to load YouTube api") : void setTimeout(function () { insertYoutubeVideoAsBackground($element, youtubeId, counter++) }, 100); var $container = $element.prepend('<div class="vc_video-bg vc_hidden-xs"><div class="inner"></div></div>').find(".inner"); new YT.Player($container[0], { width: "100%", height: "100%", videoId: youtubeId, playerVars: { playlist: youtubeId, iv_load_policy: 3, enablejsapi: 1, disablekb: 1, autoplay: 1, controls: 0, showinfo: 0, rel: 0, loop: 1, wmode: "transparent" }, events: { onReady: function (event) { event.target.mute().setLoop(!0) } } }), vcResizeVideoBackground($element), jQuery(window).bind("resize", function () { vcResizeVideoBackground($element) }) } function vcResizeVideoBackground($element) { var iframeW, iframeH, marginLeft, marginTop, containerW = $element.innerWidth(), containerH = $element.innerHeight(); containerW / containerH < 16 / 9 ? (iframeW = containerH * (16 / 9), iframeH = containerH, marginLeft = -Math.round((iframeW - containerW) / 2) + "px", marginTop = -Math.round((iframeH - containerH) / 2) + "px") : (iframeH = (iframeW = containerW) * (9 / 16), marginTop = -Math.round((iframeH - containerH) / 2) + "px", marginLeft = -Math.round((iframeW - containerW) / 2) + "px"), iframeW += "px", iframeH += "px", $element.find(".vc_video-bg iframe").css({ maxWidth: "1000%", marginLeft: marginLeft, marginTop: marginTop, width: iframeW, height: iframeH }) } function vcExtractYoutubeId(url) { if (void 0 === url) return !1; var id = url.match(/(?:https?:\/{2})?(?:w{3}\.)?youtu(?:be)?\.(?:com|be)(?:\/watch\?v=|\/)([^\s&]+)/); return null !== id && id[1] } if ("function" != typeof window.wpb_prepare_tab_content && (window.wpb_prepare_tab_content = function (event, ui) { var $ui_panel, $google_maps, panel = ui.panel || ui.newPanel, $pie_charts = panel.find(".vc_pie_chart:not(.vc_ready)"), $round_charts = panel.find(".vc_round-chart"), $line_charts = panel.find(".vc_line-chart"), $carousel = panel.find('[data-ride="vc_carousel"]'); if (vc_carouselBehaviour(), vc_plugin_flexslider(panel), ui.newPanel.find(".vc_masonry_media_grid, .vc_masonry_grid").length && ui.newPanel.find(".vc_masonry_media_grid, .vc_masonry_grid").each(function () { var grid = jQuery(this).data("vcGrid"); grid && grid.gridBuilder && grid.gridBuilder.setMasonry && grid.gridBuilder.setMasonry() }), panel.find(".vc_masonry_media_grid, .vc_masonry_grid").length && panel.find(".vc_masonry_media_grid, .vc_masonry_grid").each(function () { var grid = jQuery(this).data("vcGrid"); grid && grid.gridBuilder && grid.gridBuilder.setMasonry && grid.gridBuilder.setMasonry() }), $pie_charts.length && jQuery.fn.vcChat && $pie_charts.vcChat(), $round_charts.length && jQuery.fn.vcRoundChart && $round_charts.vcRoundChart({ reload: !1 }), $line_charts.length && jQuery.fn.vcLineChart && $line_charts.vcLineChart({ reload: !1 }), $carousel.length && jQuery.fn.carousel && $carousel.carousel("resizeAction"), $ui_panel = panel.find(".isotope, .wpb_image_grid_ul"), $google_maps = panel.find(".wpb_gmaps_widget"), 0 < $ui_panel.length && $ui_panel.isotope("layout"), $google_maps.length && !$google_maps.is(".map_ready")) { var $frame = $google_maps.find("iframe"); $frame.attr("src", $frame.attr("src")), $google_maps.addClass("map_ready") } panel.parents(".isotope").length && panel.parents(".isotope").each(function () { jQuery(this).isotope("layout") }) }), "function" != typeof window.vc_googleMapsPointer) function vc_googleMapsPointer() { var $ = window.jQuery, $wpbGmapsWidget = $(".wpb_gmaps_widget"); $wpbGmapsWidget.click(function () { $("iframe", this).css("pointer-events", "auto") }), $wpbGmapsWidget.mouseleave(function () { $("iframe", this).css("pointer-events", "none") }), $(".wpb_gmaps_widget iframe").css("pointer-events", "none") } function vc_setHoverBoxPerspective(hoverBox) { hoverBox.each(function () { var $this = jQuery(this), perspective = 4 * $this.width() + "px"; $this.css("perspective", perspective) }) } function vc_setHoverBoxHeight(hoverBox) { hoverBox.each(function () { var $this = jQuery(this), hoverBoxInner = $this.find(".vc-hoverbox-inner"); hoverBoxInner.css("min-height", 0); var frontHeight = $this.find(".vc-hoverbox-front-inner").outerHeight(), backHeight = $this.find(".vc-hoverbox-back-inner").outerHeight(), hoverBoxHeight = backHeight < frontHeight ? frontHeight : backHeight; hoverBoxHeight < 250 && (hoverBoxHeight = 250), hoverBoxInner.css("min-height", hoverBoxHeight + "px") }) } function vc_prepareHoverBox() { var hoverBox = jQuery(".vc-hoverbox"); vc_setHoverBoxHeight(hoverBox), vc_setHoverBoxPerspective(hoverBox) } jQuery(document).ready(vc_prepareHoverBox), jQuery(window).resize(vc_prepareHoverBox), jQuery(document).ready(function ($) { window.vc_js() });; (function () { var t = [].indexOf || function (t) { for (var e = 0, n = this.length; e < n; e++) { if (e in this && this[e] === t) return e } return -1 }, e = [].slice; (function (t, e) { if (typeof define === "function" && define.amd) { return define("waypoints", ["jquery"], function (n) { return e(n, t) }) } else { return e(t.jQuery, t) } })(this, function (n, r) { var i, o, l, s, f, u, a, c, h, d, p, y, v, w, g, m; i = n(r); c = t.call(r, "ontouchstart") >= 0; s = { horizontal: {}, vertical: {} }; f = 1; a = {}; u = "waypoints-context-id"; p = "resize.waypoints"; y = "scroll.waypoints"; v = 1; w = "waypoints-waypoint-ids"; g = "waypoint"; m = "waypoints"; o = function () { function t(t) { var e = this; this.$element = t; this.element = t[0]; this.didResize = false; this.didScroll = false; this.id = "context" + f++; this.oldScroll = { x: t.scrollLeft(), y: t.scrollTop() }; this.waypoints = { horizontal: {}, vertical: {} }; t.data(u, this.id); a[this.id] = this; t.bind(y, function () { var t; if (!(e.didScroll || c)) { e.didScroll = true; t = function () { e.doScroll(); return e.didScroll = false }; return r.setTimeout(t, n[m].settings.scrollThrottle) } }); t.bind(p, function () { var t; if (!e.didResize) { e.didResize = true; t = function () { n[m]("refresh"); return e.didResize = false }; return r.setTimeout(t, n[m].settings.resizeThrottle) } }) } t.prototype.doScroll = function () { var t, e = this; t = { horizontal: { newScroll: this.$element.scrollLeft(), oldScroll: this.oldScroll.x, forward: "right", backward: "left" }, vertical: { newScroll: this.$element.scrollTop(), oldScroll: this.oldScroll.y, forward: "down", backward: "up" } }; if (c && (!t.vertical.oldScroll || !t.vertical.newScroll)) { n[m]("refresh") } n.each(t, function (t, r) { var i, o, l; l = []; o = r.newScroll > r.oldScroll; i = o ? r.forward : r.backward; n.each(e.waypoints[t], function (t, e) { var n, i; if (r.oldScroll < (n = e.offset) && n <= r.newScroll) { return l.push(e) } else if (r.newScroll < (i = e.offset) && i <= r.oldScroll) { return l.push(e) } }); l.sort(function (t, e) { return t.offset - e.offset }); if (!o) { l.reverse() } return n.each(l, function (t, e) { if (e.options.continuous || t === l.length - 1) { return e.trigger([i]) } }) }); return this.oldScroll = { x: t.horizontal.newScroll, y: t.vertical.newScroll } }; t.prototype.refresh = function () { var t, e, r, i = this; r = n.isWindow(this.element); e = this.$element.offset(); this.doScroll(); t = { horizontal: { contextOffset: r ? 0 : e.left, contextScroll: r ? 0 : this.oldScroll.x, contextDimension: this.$element.width(), oldScroll: this.oldScroll.x, forward: "right", backward: "left", offsetProp: "left" }, vertical: { contextOffset: r ? 0 : e.top, contextScroll: r ? 0 : this.oldScroll.y, contextDimension: r ? n[m]("viewportHeight") : this.$element.height(), oldScroll: this.oldScroll.y, forward: "down", backward: "up", offsetProp: "top" } }; return n.each(t, function (t, e) { return n.each(i.waypoints[t], function (t, r) { var i, o, l, s, f; i = r.options.offset; l = r.offset; o = n.isWindow(r.element) ? 0 : r.$element.offset()[e.offsetProp]; if (n.isFunction(i)) { i = i.apply(r.element) } else if (typeof i === "string") { i = parseFloat(i); if (r.options.offset.indexOf("%") > -1) { i = Math.ceil(e.contextDimension * i / 100) } } r.offset = o - e.contextOffset + e.contextScroll - i; if (r.options.onlyOnScroll && l != null || !r.enabled) { return } if (l !== null && l < (s = e.oldScroll) && s <= r.offset) { return r.trigger([e.backward]) } else if (l !== null && l > (f = e.oldScroll) && f >= r.offset) { return r.trigger([e.forward]) } else if (l === null && e.oldScroll >= r.offset) { return r.trigger([e.forward]) } }) }) }; t.prototype.checkEmpty = function () { if (n.isEmptyObject(this.waypoints.horizontal) && n.isEmptyObject(this.waypoints.vertical)) { this.$element.unbind([p, y].join(" ")); return delete a[this.id] } }; return t }(); l = function () { function t(t, e, r) { var i, o; r = n.extend({}, n.fn[g].defaults, r); if (r.offset === "bottom-in-view") { r.offset = function () { var t; t = n[m]("viewportHeight"); if (!n.isWindow(e.element)) { t = e.$element.height() } return t - n(this).outerHeight() } } this.$element = t; this.element = t[0]; this.axis = r.horizontal ? "horizontal" : "vertical"; this.callback = r.handler; this.context = e; this.enabled = r.enabled; this.id = "waypoints" + v++; this.offset = null; this.options = r; e.waypoints[this.axis][this.id] = this; s[this.axis][this.id] = this; i = (o = t.data(w)) != null ? o : []; i.push(this.id); t.data(w, i) } t.prototype.trigger = function (t) { if (!this.enabled) { return } if (this.callback != null) { this.callback.apply(this.element, t) } if (this.options.triggerOnce) { return this.destroy() } }; t.prototype.disable = function () { return this.enabled = false }; t.prototype.enable = function () { this.context.refresh(); return this.enabled = true }; t.prototype.destroy = function () { delete s[this.axis][this.id]; delete this.context.waypoints[this.axis][this.id]; return this.context.checkEmpty() }; t.getWaypointsByElement = function (t) { var e, r; r = n(t).data(w); if (!r) { return [] } e = n.extend({}, s.horizontal, s.vertical); return n.map(r, function (t) { return e[t] }) }; return t }(); d = { init: function (t, e) { var r; if (e == null) { e = {} } if ((r = e.handler) == null) { e.handler = t } this.each(function () { var t, r, i, s; t = n(this); i = (s = e.context) != null ? s : n.fn[g].defaults.context; if (!n.isWindow(i)) { i = t.closest(i) } i = n(i); r = a[i.data(u)]; if (!r) { r = new o(i) } return new l(t, r, e) }); n[m]("refresh"); return this }, disable: function () { return d._invoke(this, "disable") }, enable: function () { return d._invoke(this, "enable") }, destroy: function () { return d._invoke(this, "destroy") }, prev: function (t, e) { return d._traverse.call(this, t, e, function (t, e, n) { if (e > 0) { return t.push(n[e - 1]) } }) }, next: function (t, e) { return d._traverse.call(this, t, e, function (t, e, n) { if (e < n.length - 1) { return t.push(n[e + 1]) } }) }, _traverse: function (t, e, i) { var o, l; if (t == null) { t = "vertical" } if (e == null) { e = r } l = h.aggregate(e); o = []; this.each(function () { var e; e = n.inArray(this, l[t]); return i(o, e, l[t]) }); return this.pushStack(o) }, _invoke: function (t, e) { t.each(function () { var t; t = l.getWaypointsByElement(this); return n.each(t, function (t, n) { n[e](); return true }) }); return this } }; n.fn[g] = function () { var t, r; r = arguments[0], t = 2 <= arguments.length ? e.call(arguments, 1) : []; if (d[r]) { return d[r].apply(this, t) } else if (n.isFunction(r)) { return d.init.apply(this, arguments) } else if (n.isPlainObject(r)) { return d.init.apply(this, [null, r]) } else if (!r) { return n.error("jQuery Waypoints needs a callback function or handler option.") } else { return n.error("The " + r + " method does not exist in jQuery Waypoints.") } }; n.fn[g].defaults = { context: r, continuous: true, enabled: true, horizontal: false, offset: 0, triggerOnce: false }; h = { refresh: function () { return n.each(a, function (t, e) { return e.refresh() }) }, viewportHeight: function () { var t; return (t = r.innerHeight) != null ? t : i.height() }, aggregate: function (t) { var e, r, i; e = s; if (t) { e = (i = a[n(t).data(u)]) != null ? i.waypoints : void 0 } if (!e) { return [] } r = { horizontal: [], vertical: [] }; n.each(r, function (t, i) { n.each(e[t], function (t, e) { return i.push(e) }); i.sort(function (t, e) { return t.offset - e.offset }); r[t] = n.map(i, function (t) { return t.element }); return r[t] = n.unique(r[t]) }); return r }, above: function (t) { if (t == null) { t = r } return h._filter(t, "vertical", function (t, e) { return e.offset <= t.oldScroll.y }) }, below: function (t) { if (t == null) { t = r } return h._filter(t, "vertical", function (t, e) { return e.offset > t.oldScroll.y }) }, left: function (t) { if (t == null) { t = r } return h._filter(t, "horizontal", function (t, e) { return e.offset <= t.oldScroll.x }) }, right: function (t) { if (t == null) { t = r } return h._filter(t, "horizontal", function (t, e) { return e.offset > t.oldScroll.x }) }, enable: function () { return h._invoke("enable") }, disable: function () { return h._invoke("disable") }, destroy: function () { return h._invoke("destroy") }, extendFn: function (t, e) { return d[t] = e }, _invoke: function (t) { var e; e = n.extend({}, s.vertical, s.horizontal); return n.each(e, function (e, n) { n[t](); return true }) }, _filter: function (t, e, r) { var i, o; i = a[n(t).data(u)]; if (!i) { return [] } o = []; n.each(i.waypoints[e], function (t, e) { if (r(i, e)) { return o.push(e) } }); o.sort(function (t, e) { return t.offset - e.offset }); return n.map(o, function (t) { return t.element }) } }; n[m] = function () { var t, n; n = arguments[0], t = 2 <= arguments.length ? e.call(arguments, 1) : []; if (h[n]) { return h[n].apply(null, t) } else { return h.aggregate.call(null, n) } }; n[m].settings = { resizeThrottle: 100, scrollThrottle: 30 }; return i.load(function () { return n[m]("refresh") }) }) }).call(this);; !function ($) { "use strict"; var Accordion, clickHandler, old, hashNavigation; function Plugin(action, options) { var args; return args = Array.prototype.slice.call(arguments, 1), this.each(function () { var $this, data; (data = ($this = $(this)).data("vc.accordion")) || (data = new Accordion($this, $.extend(!0, {}, options)), $this.data("vc.accordion", data)), "string" == typeof action && data[action].apply(data, args) }) } (Accordion = function ($element, options) { this.$element = $element, this.activeClass = "vc_active", this.animatingClass = "vc_animating", this.useCacheFlag = void 0, this.$target = void 0, this.$targetContent = void 0, this.selector = void 0, this.$container = void 0, this.animationDuration = void 0, this.index = 0 }).transitionEvent = function () { var transition, transitions, el; for (transition in el = document.createElement("vcFakeElement"), transitions = { transition: "transitionend", MSTransition: "msTransitionEnd", MozTransition: "transitionend", WebkitTransition: "webkitTransitionEnd" }) if (void 0 !== el.style[transition]) return transitions[transition] }, Accordion.emulateTransitionEnd = function ($el, duration) { var called; called = !1, duration || (duration = 250), $el.one(Accordion.transitionName, function () { called = !0 }), setTimeout(function () { called || $el.trigger(Accordion.transitionName) }, duration) }, Accordion.DEFAULT_TYPE = "collapse", Accordion.transitionName = Accordion.transitionEvent(), Accordion.prototype.controller = function (options) { var $this; $this = this.$element; var action = options; "string" != typeof action && (action = $this.data("vcAction") || this.getContainer().data("vcAction")), void 0 === action && (action = Accordion.DEFAULT_TYPE), "string" == typeof action && Plugin.call($this, action, options) }, Accordion.prototype.isCacheUsed = function () { var useCache, that; return useCache = function () { return !1 !== that.$element.data("vcUseCache") }, void 0 === (that = this).useCacheFlag && (this.useCacheFlag = useCache()), this.useCacheFlag }, Accordion.prototype.getSelector = function () { var findSelector, $this; return $this = this.$element, findSelector = function () { var selector; return (selector = $this.data("vcTarget")) || (selector = $this.attr("href")), selector }, this.isCacheUsed() ? (void 0 === this.selector && (this.selector = findSelector()), this.selector) : findSelector() }, Accordion.prototype.findContainer = function () { var $container; return ($container = this.$element.closest(this.$element.data("vcContainer"))).length || ($container = $("body")), $container }, Accordion.prototype.getContainer = function () { return this.isCacheUsed() ? (void 0 === this.$container && (this.$container = this.findContainer()), this.$container) : this.findContainer() }, Accordion.prototype.getTarget = function () { var selector, that, getTarget; return selector = (that = this).getSelector(), getTarget = function () { var element; return (element = that.getContainer().find(selector)).length || (element = that.getContainer().filter(selector)), element }, this.isCacheUsed() ? (void 0 === this.$target && (this.$target = getTarget()), this.$target) : getTarget() }, Accordion.prototype.getTargetContent = function () { var $target, $targetContent; return $target = this.getTarget(), this.isCacheUsed() ? (void 0 === this.$targetContent && (($targetContent = $target).data("vcContent") && (($targetContent = $target.find($target.data("vcContent"))).length || ($targetContent = $target)), this.$targetContent = $targetContent), this.$targetContent) : $target.data("vcContent") && ($targetContent = $target.find($target.data("vcContent"))).length ? $targetContent : $target }, Accordion.prototype.getTriggers = function () { var i; return i = 0, this.getContainer().find("[data-vc-accordion]").each(function () { var accordion, $this; void 0 === (accordion = ($this = $(this)).data("vc.accordion")) && ($this.vcAccordion(), accordion = $this.data("vc.accordion")), accordion && accordion.setIndex && accordion.setIndex(i++) }) }, Accordion.prototype.setIndex = function (index) { this.index = index }, Accordion.prototype.getIndex = function () { return this.index }, Accordion.prototype.triggerEvent = function (event, opt) { var $event; "string" == typeof event && ($event = $.Event(event), this.$element.trigger($event, opt)) }, Accordion.prototype.getActiveTriggers = function () { return this.getTriggers().filter(function () { var accordion; return (accordion = $(this).data("vc.accordion")).getTarget().hasClass(accordion.activeClass) }) }, Accordion.prototype.changeLocationHash = function () { var id, $target; ($target = this.getTarget()).length && (id = $target.attr("id")), id && (history.pushState ? history.pushState(null, null, "#" + id) : location.hash = "#" + id) }, Accordion.prototype.isActive = function () { return this.getTarget().hasClass(this.activeClass) }, Accordion.prototype.getAnimationDuration = function () { var findAnimationDuration, that; return findAnimationDuration = function () { return void 0 === Accordion.transitionName ? "0s" : that.getTargetContent().css("transition-duration").split(",")[0] }, (that = this).isCacheUsed() ? (void 0 === this.animationDuration && (this.animationDuration = findAnimationDuration()), this.animationDuration) : findAnimationDuration() }, Accordion.prototype.getAnimationDurationMilliseconds = function () { var duration; return "ms" === (duration = this.getAnimationDuration()).substr(-2) ? parseInt(duration) : "s" === duration.substr(-1) ? Math.round(1e3 * parseFloat(duration)) : void 0 }, Accordion.prototype.isAnimated = function () { return 0 < parseFloat(this.getAnimationDuration()) }, Accordion.prototype.show = function (opt) { var $target, that, $targetContent; $target = (that = this).getTarget(), $targetContent = that.getTargetContent(), that.isActive() || (that.isAnimated() ? (that.triggerEvent("beforeShow.vc.accordion"), $target.queue(function (next) { $targetContent.one(Accordion.transitionName, function () { $target.removeClass(that.animatingClass), $targetContent.attr("style", ""), that.triggerEvent("afterShow.vc.accordion", opt) }), Accordion.emulateTransitionEnd($targetContent, that.getAnimationDurationMilliseconds() + 100), next() }).queue(function (next) { $targetContent.attr("style", ""), $targetContent.css({ position: "absolute", visibility: "hidden", display: "block" }); var height = $targetContent.height(); $targetContent.data("vcHeight", height), $targetContent.attr("style", ""), next() }).queue(function (next) { $targetContent.height(0), $targetContent.css({ "padding-top": 0, "padding-bottom": 0 }), next() }).queue(function (next) { $target.addClass(that.animatingClass), $target.addClass(that.activeClass), ("object" == typeof opt && opt.hasOwnProperty("changeHash") && opt.changeHash || void 0 === opt) && that.changeLocationHash(), that.triggerEvent("show.vc.accordion", opt), next() }).queue(function (next) { var height = $targetContent.data("vcHeight"); $targetContent.animate({ height: height }, { duration: that.getAnimationDurationMilliseconds(), complete: function () { $targetContent.data("events") || $targetContent.attr("style", "") } }), $targetContent.css({ "padding-top": "", "padding-bottom": "" }), next() })) : ($target.addClass(that.activeClass), that.triggerEvent("show.vc.accordion", opt))) }, Accordion.prototype.hide = function (opt) { var $target, that, $targetContent; $target = (that = this).getTarget(), $targetContent = that.getTargetContent(), that.isActive() && (that.isAnimated() ? (that.triggerEvent("beforeHide.vc.accordion"), $target.queue(function (next) { $targetContent.one(Accordion.transitionName, function () { $target.removeClass(that.animatingClass), $targetContent.attr("style", ""), that.triggerEvent("afterHide.vc.accordion", opt) }), Accordion.emulateTransitionEnd($targetContent, that.getAnimationDurationMilliseconds() + 100), next() }).queue(function (next) { $target.addClass(that.animatingClass), $target.removeClass(that.activeClass), that.triggerEvent("hide.vc.accordion", opt), next() }).queue(function (next) { var height = $targetContent.height(); $targetContent.height(height), next() }).queue(function (next) { $targetContent.animate({ height: 0 }, that.getAnimationDurationMilliseconds()), $targetContent.css({ "padding-top": 0, "padding-bottom": 0 }), next() })) : ($target.removeClass(that.activeClass), that.triggerEvent("hide.vc.accordion", opt))) }, Accordion.prototype.toggle = function (opt) { var $this; $this = this.$element, this.isActive() ? Plugin.call($this, "hide", opt) : Plugin.call($this, "show", opt) }, Accordion.prototype.dropdown = function (opt) { var $this; $this = this.$element, this.isActive() ? Plugin.call($this, "hide", opt) : (Plugin.call($this, "show", opt), $(document).on("click.vc.accordion.data-api.dropdown", function (e) { Plugin.call($this, "hide", opt), $(document).off(e) })) }, Accordion.prototype.collapse = function (opt) { var $this, $triggers; $this = this.$element, ($triggers = this.getActiveTriggers().filter(function () { return $this[0] !== this })).length && Plugin.call($triggers, "hide", opt), Plugin.call($this, "show", opt) }, Accordion.prototype.collapseAll = function (opt) { var $this, $triggers; $this = this.$element, ($triggers = this.getActiveTriggers().filter(function () { return $this[0] !== this })).length && Plugin.call($triggers, "hide", opt), Plugin.call($this, "toggle", opt) }, Accordion.prototype.showNext = function (opt) { var $triggers, $activeTriggers, activeIndex; if ($triggers = this.getTriggers(), $activeTriggers = this.getActiveTriggers(), $triggers.length) { var lastActiveAccordion; if ($activeTriggers.length) (lastActiveAccordion = $activeTriggers.eq($activeTriggers.length - 1).vcAccordion().data("vc.accordion")) && lastActiveAccordion.getIndex && (activeIndex = lastActiveAccordion.getIndex()); -1 < activeIndex && activeIndex + 1 < $triggers.length ? Plugin.call($triggers.eq(activeIndex + 1), "controller", opt) : Plugin.call($triggers.eq(0), "controller", opt) } }, Accordion.prototype.showPrev = function (opt) { var $triggers, $activeTriggers, activeIndex; if ($triggers = this.getTriggers(), $activeTriggers = this.getActiveTriggers(), $triggers.length) { var lastActiveAccordion; if ($activeTriggers.length) (lastActiveAccordion = $activeTriggers.eq($activeTriggers.length - 1).vcAccordion().data("vc.accordion")) && lastActiveAccordion.getIndex && (activeIndex = lastActiveAccordion.getIndex()); Plugin.call(-1 < activeIndex ? 0 <= activeIndex - 1 ? $triggers.eq(activeIndex - 1) : $triggers.eq($triggers.length - 1) : $triggers.eq(0), "controller", opt) } }, Accordion.prototype.showAt = function (index, opt) { var $triggers; ($triggers = this.getTriggers()).length && index && index < $triggers.length && Plugin.call($triggers.eq(index), "controller", opt) }, Accordion.prototype.scrollToActive = function (opt) { var that, $targetElement; (void 0 === opt || void 0 === opt.scrollTo || opt.scrollTo) && (($targetElement = $((that = this).getTarget())).length && this.$element.length && setTimeout(function () { $targetElement.offset().top - $(window).scrollTop() - 1 * that.$element.outerHeight() < 0 && $("html, body").animate({ scrollTop: $targetElement.offset().top - 1 * that.$element.outerHeight() }, 300) }, 300)) }, old = $.fn.vcAccordion, $.fn.vcAccordion = Plugin, $.fn.vcAccordion.Constructor = Accordion, $.fn.vcAccordion.noConflict = function () { return $.fn.vcAccordion = old, this }, clickHandler = function (e) { var $this; $this = $(this), e.preventDefault(), Plugin.call($this, "controller") }, hashNavigation = function () { var hash, $targetElement, $accordion; (hash = window.location.hash) && ($targetElement = $(hash)).length && ($accordion = $targetElement.find('[data-vc-accordion][href="' + hash + '"],[data-vc-accordion][data-vc-target="' + hash + '"]')).length && (setTimeout(function () { $("html, body").animate({ scrollTop: $targetElement.offset().top - .2 * $(window).height() }, 0) }, 300), $accordion.trigger("click")) }, $(window).on("hashchange.vc.accordion", hashNavigation), $(document).on("click.vc.accordion.data-api", "[data-vc-accordion]", clickHandler), $(document).ready(hashNavigation), $(document).on("afterShow.vc.accordion", function (e, opt) { Plugin.call($(e.target), "scrollToActive", opt) }) }(window.jQuery);; !function ($) { "use strict"; var Plugin, TtaAutoPlay, old; Plugin = function (action, options) { var args; return args = Array.prototype.slice.call(arguments, 1), this.each(function () { var $this, data; (data = ($this = $(this)).data("vc.tta.autoplay")) || (data = new TtaAutoPlay($this, $.extend(!0, {}, TtaAutoPlay.DEFAULTS, $this.data("vc-tta-autoplay"), options)), $this.data("vc.tta.autoplay", data)), "string" == typeof action ? data[action].apply(data, args) : data.start(args) }) }, (TtaAutoPlay = function ($element, options) { this.$element = $element, this.options = options }).DEFAULTS = { delay: 5e3, pauseOnHover: !0, stopOnClick: !0 }, TtaAutoPlay.prototype.show = function () { this.$element.find("[data-vc-accordion]:eq(0)").vcAccordion("showNext", { changeHash: !1, scrollTo: !1 }) }, TtaAutoPlay.prototype.hasTimer = function () { return void 0 !== this.$element.data("vc.tta.autoplay.timer") }, TtaAutoPlay.prototype.setTimer = function (windowInterval) { this.$element.data("vc.tta.autoplay.timer", windowInterval) }, TtaAutoPlay.prototype.getTimer = function () { return this.$element.data("vc.tta.autoplay.timer") }, TtaAutoPlay.prototype.deleteTimer = function () { this.$element.removeData("vc.tta.autoplay.timer") }, TtaAutoPlay.prototype.start = function () { var $this, that; $this = this.$element, (that = this).hasTimer() || (this.setTimer(window.setInterval(this.show.bind(this), this.options.delay)), this.options.stopOnClick && $this.on("click.vc.tta.autoplay.data-api", "[data-vc-accordion]", function (e) { e.preventDefault && e.preventDefault(), that.hasTimer() && Plugin.call($this, "stop") }), this.options.pauseOnHover && $this.hover(function (e) { e.preventDefault && e.preventDefault(), that.hasTimer() && Plugin.call($this, "mouseleave" === e.type ? "resume" : "pause") })) }, TtaAutoPlay.prototype.resume = function () { this.hasTimer() && this.setTimer(window.setInterval(this.show.bind(this), this.options.delay)) }, TtaAutoPlay.prototype.stop = function () { this.pause(), this.deleteTimer(), this.$element.off("click.vc.tta.autoplay.data-api mouseenter mouseleave") }, TtaAutoPlay.prototype.pause = function () { var timer; void 0 !== (timer = this.getTimer()) && window.clearInterval(timer) }, old = $.fn.vcTtaAutoPlay, $.fn.vcTtaAutoPlay = Plugin, $.fn.vcTtaAutoPlay.Constructor = TtaAutoPlay, $.fn.vcTtaAutoPlay.noConflict = function () { return $.fn.vcTtaAutoPlay = old, this }, $(document).ready(function () { $("[data-vc-tta-autoplay]").each(function () { $(this).vcTtaAutoPlay() }) }) }(window.jQuery);;